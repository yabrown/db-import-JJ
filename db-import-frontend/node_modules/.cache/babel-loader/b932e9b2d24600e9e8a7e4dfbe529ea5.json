{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\nvar retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * The programmatic identifier of the retryPolicy.\n */\nvar retryPolicyName = \"retryPolicy\";\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    maxRetries: DEFAULT_RETRY_POLICY_COUNT\n  };\n  var logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    sendRequest: function sendRequest(request, next) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _a, _b, response, responseError, retryCount, abortError, _iterator, _step, strategy, strategyLogger, modifiers, errorToThrow, retryAfterInMs, redirectTo;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              retryCount = -1; // eslint-disable-next-line no-constant-condition\n            case 1:\n              if (!true) {\n                _context.next = 78;\n                break;\n              }\n              retryCount += 1;\n              response = undefined;\n              responseError = undefined;\n              _context.prev = 5;\n              logger.info(\"Retry \".concat(retryCount, \": Attempting to send request\"), request.requestId);\n              _context.next = 9;\n              return next(request);\n            case 9:\n              response = _context.sent;\n              logger.info(\"Retry \".concat(retryCount, \": Received a response from request\"), request.requestId);\n              _context.next = 20;\n              break;\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](5);\n              logger.error(\"Retry \".concat(retryCount, \": Received an error from request\"), request.requestId);\n              // RestErrors are valid targets for the retry strategies.\n              // If none of the retry strategies can work with them, they will be thrown later in this policy.\n              // If the received error is not a RestError, it is immediately thrown.\n              responseError = _context.t0;\n              if (!(!_context.t0 || responseError.name !== \"RestError\")) {\n                _context.next = 19;\n                break;\n              }\n              throw _context.t0;\n            case 19:\n              response = responseError.response;\n            case 20:\n              if (!((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted)) {\n                _context.next = 24;\n                break;\n              }\n              logger.error(\"Retry \".concat(retryCount, \": Request aborted.\"));\n              abortError = new AbortError();\n              throw abortError;\n            case 24:\n              if (!(retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT))) {\n                _context.next = 35;\n                break;\n              }\n              logger.info(\"Retry \".concat(retryCount, \": Maximum retries reached. Returning the last received response, or throwing the last received error.\"));\n              if (!responseError) {\n                _context.next = 30;\n                break;\n              }\n              throw responseError;\n            case 30:\n              if (!response) {\n                _context.next = 34;\n                break;\n              }\n              return _context.abrupt(\"return\", response);\n            case 34:\n              throw new Error(\"Maximum retries reached with no response or error to throw\");\n            case 35:\n              logger.info(\"Retry \".concat(retryCount, \": Processing \").concat(strategies.length, \" retry strategies.\"));\n              _iterator = _createForOfIteratorHelper(strategies);\n              _context.prev = 37;\n              _iterator.s();\n            case 39:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 62;\n                break;\n              }\n              strategy = _step.value;\n              strategyLogger = strategy.logger || retryPolicyLogger;\n              strategyLogger.info(\"Retry \".concat(retryCount, \": Processing retry strategy \").concat(strategy.name, \".\"));\n              modifiers = strategy.retry({\n                retryCount: retryCount,\n                response: response,\n                responseError: responseError\n              });\n              if (!modifiers.skipStrategy) {\n                _context.next = 47;\n                break;\n              }\n              strategyLogger.info(\"Retry \".concat(retryCount, \": Skipped.\"));\n              return _context.abrupt(\"continue\", 60);\n            case 47:\n              errorToThrow = modifiers.errorToThrow, retryAfterInMs = modifiers.retryAfterInMs, redirectTo = modifiers.redirectTo;\n              if (!errorToThrow) {\n                _context.next = 51;\n                break;\n              }\n              strategyLogger.error(\"Retry \".concat(retryCount, \": Retry strategy \").concat(strategy.name, \" throws error:\"), errorToThrow);\n              throw errorToThrow;\n            case 51:\n              if (!(retryAfterInMs || retryAfterInMs === 0)) {\n                _context.next = 56;\n                break;\n              }\n              strategyLogger.info(\"Retry \".concat(retryCount, \": Retry strategy \").concat(strategy.name, \" retries after \").concat(retryAfterInMs));\n              _context.next = 55;\n              return delay(retryAfterInMs, undefined, {\n                abortSignal: request.abortSignal\n              });\n            case 55:\n              return _context.abrupt(\"continue\", 1);\n            case 56:\n              if (!redirectTo) {\n                _context.next = 60;\n                break;\n              }\n              strategyLogger.info(\"Retry \".concat(retryCount, \": Retry strategy \").concat(strategy.name, \" redirects to \").concat(redirectTo));\n              request.url = redirectTo;\n              return _context.abrupt(\"continue\", 1);\n            case 60:\n              _context.next = 39;\n              break;\n            case 62:\n              _context.next = 67;\n              break;\n            case 64:\n              _context.prev = 64;\n              _context.t1 = _context[\"catch\"](37);\n              _iterator.e(_context.t1);\n            case 67:\n              _context.prev = 67;\n              _iterator.f();\n              return _context.finish(67);\n            case 70:\n              if (!responseError) {\n                _context.next = 73;\n                break;\n              }\n              logger.info(\"None of the retry strategies could work with the received error. Throwing it.\");\n              throw responseError;\n            case 73:\n              if (!response) {\n                _context.next = 76;\n                break;\n              }\n              logger.info(\"None of the retry strategies could work with the received response. Returning it.\");\n              return _context.abrupt(\"return\", response);\n            case 76:\n              _context.next = 1;\n              break;\n            case 78:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[5, 13], [37, 64, 67, 70]]);\n      }))();\n    }\n  };\n}","map":{"version":3,"names":["delay","createClientLogger","AbortError","DEFAULT_RETRY_POLICY_COUNT","retryPolicyLogger","retryPolicyName","retryPolicy","strategies","options","arguments","length","undefined","maxRetries","logger","name","sendRequest","request","next","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_a","_b","response","responseError","retryCount","abortError","_iterator","_step","strategy","strategyLogger","modifiers","errorToThrow","retryAfterInMs","redirectTo","wrap","_callee$","_context","prev","info","concat","requestId","sent","t0","error","abortSignal","aborted","abrupt","Error","_createForOfIteratorHelper","s","n","done","value","retry","skipStrategy","url","t1","e","f","finish","stop"],"sources":["../../../src/policies/retryPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { RetryStrategy } from \"../retryStrategies/retryStrategy\";\nimport { RestError } from \"../restError\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { AzureLogger } from \"@azure/logger\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n\n/**\n * Options to the {@link retryPolicy}\n */\nexport interface RetryPolicyOptions {\n  /**\n   * Maximum number of retries. If not specified, it will limit to 3 retries.\n   */\n  maxRetries?: number;\n  /**\n   * Logger. If it's not provided, a default logger is used.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(\n  strategies: RetryStrategy[],\n  options: RetryPolicyOptions = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }\n): PipelinePolicy {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let response: PipelineResponse | undefined;\n      let responseError: RestError | undefined;\n      let retryCount = -1;\n\n      // eslint-disable-next-line no-constant-condition\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e: any) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e as RestError;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n\n          response = responseError.response;\n        }\n\n        if (request.abortSignal?.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n\n        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(\n            `Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`\n          );\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || retryPolicyLogger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError,\n          });\n\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n\n          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n\n          if (errorToThrow) {\n            strategyLogger.error(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`,\n              errorToThrow\n            );\n            throw errorToThrow;\n          }\n\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`\n            );\n            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n            continue retryRequest;\n          }\n\n          if (redirectTo) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`\n            );\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n\n        if (responseError) {\n          logger.info(\n            `None of the retry strategies could work with the received error. Throwing it.`\n          );\n          throw responseError;\n        }\n        if (response) {\n          logger.info(\n            `None of the retry strategies could work with the received response. Returning it.`\n          );\n          return response;\n        }\n\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}