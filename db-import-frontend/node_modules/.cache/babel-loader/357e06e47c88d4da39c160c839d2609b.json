{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport var bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\nfunction defaultAuthorizeRequest(_x) {\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction _defaultAuthorizeRequest() {\n  _defaultAuthorizeRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {\n    var scopes, getAccessToken, request, getTokenOptions, accessToken;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          scopes = options.scopes, getAccessToken = options.getAccessToken, request = options.request;\n          getTokenOptions = {\n            abortSignal: request.abortSignal,\n            tracingOptions: request.tracingOptions\n          };\n          _context2.next = 4;\n          return getAccessToken(scopes, getTokenOptions);\n        case 4:\n          accessToken = _context2.sent;\n          if (accessToken) {\n            options.request.headers.set(\"Authorization\", \"Bearer \".concat(accessToken.token));\n          }\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\nfunction getChallenge(response) {\n  var challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a;\n  var credential = options.credential,\n    scopes = options.scopes,\n    challengeCallbacks = options.challengeCallbacks;\n  var logger = options.logger || coreLogger;\n  var callbacks = Object.assign({\n    authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge\n  }, challengeCallbacks);\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  var getAccessToken = credential ? createTokenCycler(credential /* , options */) : function () {\n    return Promise.resolve(null);\n  };\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    sendRequest: function sendRequest(request, next) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var response, error, shouldSendRequest;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (request.url.toLowerCase().startsWith(\"https://\")) {\n                _context.next = 2;\n                break;\n              }\n              throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n            case 2:\n              _context.next = 4;\n              return callbacks.authorizeRequest({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request: request,\n                getAccessToken: getAccessToken,\n                logger: logger\n              });\n            case 4:\n              _context.prev = 4;\n              _context.next = 7;\n              return next(request);\n            case 7:\n              response = _context.sent;\n              _context.next = 14;\n              break;\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](4);\n              error = _context.t0;\n              response = _context.t0.response;\n            case 14:\n              if (!(callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response))) {\n                _context.next = 20;\n                break;\n              }\n              _context.next = 17;\n              return callbacks.authorizeRequestOnChallenge({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request: request,\n                response: response,\n                getAccessToken: getAccessToken,\n                logger: logger\n              });\n            case 17:\n              shouldSendRequest = _context.sent;\n              if (!shouldSendRequest) {\n                _context.next = 20;\n                break;\n              }\n              return _context.abrupt(\"return\", next(request));\n            case 20:\n              if (!error) {\n                _context.next = 24;\n                break;\n              }\n              throw error;\n            case 24:\n              return _context.abrupt(\"return\", response);\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[4, 10]]);\n      }))();\n    }\n  };\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","bearerTokenAuthenticationPolicyName","defaultAuthorizeRequest","_x","_defaultAuthorizeRequest","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","options","scopes","getAccessToken","request","getTokenOptions","accessToken","wrap","_callee2$","_context2","prev","next","abortSignal","tracingOptions","sent","headers","set","concat","token","stop","getChallenge","response","challenge","get","status","bearerTokenAuthenticationPolicy","credential","challengeCallbacks","callbacks","Object","assign","authorizeRequest","_a","authorizeRequestOnChallenge","Promise","resolve","name","sendRequest","_callee","error","shouldSendRequest","_callee$","_context","url","toLowerCase","startsWith","Error","Array","isArray","t0","abrupt"],"sources":["../../../src/policies/bearerTokenAuthenticationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { AzureLogger } from \"@azure/logger\";\nimport { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options sent to the authorizeRequest callback\n */\nexport interface AuthorizeRequestOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options sent to the authorizeRequestOnChallenge callback\n */\nexport interface AuthorizeRequestOnChallengeOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * Response containing the challenge.\n   */\n  response: PipelineResponse;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options to override the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n */\nexport interface ChallengeCallbacks {\n  /**\n   * Allows for the authorization of the main request of this policy before it's sent.\n   */\n  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;\n  /**\n   * Allows to handle authentication challenges and to re-authorize the request.\n   * The response containing the challenge is `options.response`.\n   * If this method returns true, the underlying request will be sent once again.\n   * The request may be modified before being sent.\n   */\n  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;\n}\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential?: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n  /**\n   * Allows for the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.\n   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.\n   */\n  challengeCallbacks?: ChallengeCallbacks;\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n  };\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions\n): PipelinePolicy {\n  const { credential, scopes, challengeCallbacks } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest: challengeCallbacks?.authorizeRequest ?? defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge,\n    // keep all other properties\n    ...challengeCallbacks,\n  };\n\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential\n    ? createTokenCycler(credential /* , options */)\n    : () => Promise.resolve(null);\n\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\"\n        );\n      }\n\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger,\n      });\n\n      let response: PipelineResponse;\n      let error: Error | undefined;\n      try {\n        response = await next(request);\n      } catch (err: any) {\n        error = err;\n        response = err.response;\n      }\n\n      if (\n        callbacks.authorizeRequestOnChallenge &&\n        response?.status === 401 &&\n        getChallenge(response)\n      ) {\n        // processes challenge\n        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          response,\n          getAccessToken,\n          logger,\n        });\n\n        if (shouldSendRequest) {\n          return next(request);\n        }\n      }\n\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}