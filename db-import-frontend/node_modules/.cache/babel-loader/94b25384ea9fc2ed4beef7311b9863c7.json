{"ast":null,"code":"'use strict';\n\nvar Url = require('url');\nvar http = require('http');\nvar https = require('https');\nvar zlib = require('minizlib');\nvar Minipass = require('minipass');\nvar Body = require('./body.js');\nvar writeToStream = Body.writeToStream,\n  getTotalBytes = Body.getTotalBytes;\nvar Response = require('./response.js');\nvar Headers = require('./headers.js');\nvar createHeadersLenient = Headers.createHeadersLenient;\nvar Request = require('./request.js');\nvar getNodeRequestOptions = Request.getNodeRequestOptions;\nvar FetchError = require('./fetch-error.js');\nvar AbortError = require('./abort-error.js');\nvar resolveUrl = Url.resolve;\nvar fetch = function fetch(url, opts) {\n  if (/^data:/.test(url)) {\n    var request = new Request(url, opts);\n    try {\n      var split = url.split(',');\n      var data = Buffer.from(split[1], 'base64');\n      var type = split[0].match(/^data:(.*);base64$/)[1];\n      return Promise.resolve(new Response(data, {\n        headers: {\n          'Content-Type': type,\n          'Content-Length': data.length\n        }\n      }));\n    } catch (er) {\n      return Promise.reject(new FetchError(\"[\".concat(request.method, \"] \").concat(request.url, \" invalid URL, \").concat(er.message), 'system', er));\n    }\n  }\n  return new Promise(function (resolve, reject) {\n    // build request object\n    var request = new Request(url, opts);\n    var options;\n    try {\n      options = getNodeRequestOptions(request);\n    } catch (er) {\n      return reject(er);\n    }\n    var send = (options.protocol === 'https:' ? https : http).request;\n    var signal = request.signal;\n    var response = null;\n    var abort = function abort() {\n      var error = new AbortError('The user aborted a request.');\n      reject(error);\n      if (Minipass.isStream(request.body) && typeof request.body.destroy === 'function') {\n        request.body.destroy(error);\n      }\n      if (response && response.body) {\n        response.body.emit('error', error);\n      }\n    };\n    if (signal && signal.aborted) return abort();\n    var abortAndFinalize = function abortAndFinalize() {\n      abort();\n      finalize();\n    };\n    var finalize = function finalize() {\n      req.abort();\n      if (signal) signal.removeEventListener('abort', abortAndFinalize);\n      clearTimeout(reqTimeout);\n    };\n\n    // send request\n    var req = send(options);\n    if (signal) signal.addEventListener('abort', abortAndFinalize);\n    var reqTimeout = null;\n    if (request.timeout) {\n      req.once('socket', function (socket) {\n        reqTimeout = setTimeout(function () {\n          reject(new FetchError(\"network timeout at: \".concat(request.url), 'request-timeout'));\n          finalize();\n        }, request.timeout);\n      });\n    }\n    req.on('error', function (er) {\n      // if a 'response' event is emitted before the 'error' event, then by the\n      // time this handler is run it's too late to reject the Promise for the\n      // response. instead, we forward the error event to the response stream\n      // so that the error will surface to the user when they try to consume\n      // the body. this is done as a side effect of aborting the request except\n      // for in windows, where we must forward the event manually, otherwise\n      // there is no longer a ref'd socket attached to the request and the\n      // stream never ends so the event loop runs out of work and the process\n      // exits without warning.\n      // coverage skipped here due to the difficulty in testing\n      // istanbul ignore next\n      if (req.res) req.res.emit('error', er);\n      reject(new FetchError(\"request to \".concat(request.url, \" failed, reason: \").concat(er.message), 'system', er));\n      finalize();\n    });\n    req.on('response', function (res) {\n      clearTimeout(reqTimeout);\n      var headers = createHeadersLenient(res.headers);\n\n      // HTTP fetch step 5\n      if (fetch.isRedirect(res.statusCode)) {\n        // HTTP fetch step 5.2\n        var location = headers.get('Location');\n\n        // HTTP fetch step 5.3\n        var locationURL = location === null ? null : resolveUrl(request.url, location);\n\n        // HTTP fetch step 5.5\n        switch (request.redirect) {\n          case 'error':\n            reject(new FetchError(\"uri requested responds with a redirect, redirect mode is set to error: \".concat(request.url), 'no-redirect'));\n            finalize();\n            return;\n          case 'manual':\n            // node-fetch-specific step: make manual redirect a bit easier to\n            // use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL);\n              } catch (err) {\n                /* istanbul ignore next: nodejs server prevent invalid\n                   response headers, we can't test this through normal\n                   request */\n                reject(err);\n              }\n            }\n            break;\n          case 'follow':\n            // HTTP-redirect fetch step 2\n            if (locationURL === null) {\n              break;\n            }\n\n            // HTTP-redirect fetch step 5\n            if (request.counter >= request.follow) {\n              reject(new FetchError(\"maximum redirect reached at: \".concat(request.url), 'max-redirect'));\n              finalize();\n              return;\n            }\n\n            // HTTP-redirect fetch step 9\n            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n              reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n              finalize();\n              return;\n            }\n\n            // Update host due to redirection\n            request.headers.set('host', Url.parse(locationURL).host);\n\n            // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n            var requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout\n            };\n\n            // HTTP-redirect fetch step 11\n            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n              requestOpts.method = 'GET';\n              requestOpts.body = undefined;\n              requestOpts.headers.delete('content-length');\n            }\n\n            // HTTP-redirect fetch step 15\n            resolve(fetch(new Request(locationURL, requestOpts)));\n            finalize();\n            return;\n        }\n      } // end if(isRedirect)\n\n      // prepare response\n      res.once('end', function () {\n        return signal && signal.removeEventListener('abort', abortAndFinalize);\n      });\n      var body = new Minipass();\n      // exceedingly rare that the stream would have an error,\n      // but just in case we proxy it to the stream in use.\n      res.on('error', /* istanbul ignore next */function (er) {\n        return body.emit('error', er);\n      });\n      res.on('data', function (chunk) {\n        return body.write(chunk);\n      });\n      res.on('end', function () {\n        return body.end();\n      });\n      var responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout,\n        counter: request.counter,\n        trailer: new Promise(function (resolve) {\n          return res.on('end', function () {\n            return resolve(createHeadersLenient(res.trailers));\n          });\n        })\n      };\n\n      // HTTP-network fetch step 12.1.1.3\n      var codings = headers.get('Content-Encoding');\n\n      // HTTP-network fetch step 12.1.1.4: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        response = new Response(body, responseOptions);\n        resolve(response);\n        return;\n      }\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      var zlibOptions = {\n        flush: zlib.constants.Z_SYNC_FLUSH,\n        finishFlush: zlib.constants.Z_SYNC_FLUSH\n      };\n\n      // for gzip\n      if (codings == 'gzip' || codings == 'x-gzip') {\n        var unzip = new zlib.Gunzip(zlibOptions);\n        response = new Response(\n        // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n        body.on('error', /* istanbul ignore next */function (er) {\n          return unzip.emit('error', er);\n        }).pipe(unzip), responseOptions);\n        resolve(response);\n        return;\n      }\n\n      // for deflate\n      if (codings == 'deflate' || codings == 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        var raw = res.pipe(new Minipass());\n        raw.once('data', function (chunk) {\n          // see http://stackoverflow.com/questions/37519828\n          var decoder = (chunk[0] & 0x0F) === 0x08 ? new zlib.Inflate() : new zlib.InflateRaw();\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */function (er) {\n            return decoder.emit('error', er);\n          }).pipe(decoder);\n          response = new Response(decoder, responseOptions);\n          resolve(response);\n        });\n        return;\n      }\n\n      // for br\n      if (codings == 'br') {\n        // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n        // istanbul ignore next\n        try {\n          var decoder = new zlib.BrotliDecompress();\n        } catch (err) {\n          reject(err);\n          finalize();\n          return;\n        }\n        // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n        body.on('error', /* istanbul ignore next */function (er) {\n          return decoder.emit('error', er);\n        }).pipe(decoder);\n        response = new Response(decoder, responseOptions);\n        resolve(response);\n        return;\n      }\n\n      // otherwise, use response as-is\n      response = new Response(body, responseOptions);\n      resolve(response);\n    });\n    writeToStream(req, request);\n  });\n};\nmodule.exports = fetch;\nfetch.isRedirect = function (code) {\n  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\nfetch.Headers = Headers;\nfetch.Request = Request;\nfetch.Response = Response;\nfetch.FetchError = FetchError;","map":{"version":3,"names":["Url","require","http","https","zlib","Minipass","Body","writeToStream","getTotalBytes","Response","Headers","createHeadersLenient","Request","getNodeRequestOptions","FetchError","AbortError","resolveUrl","resolve","fetch","url","opts","test","request","split","data","Buffer","from","type","match","Promise","headers","length","er","reject","concat","method","message","options","send","protocol","signal","response","abort","error","isStream","body","destroy","emit","aborted","abortAndFinalize","finalize","req","removeEventListener","clearTimeout","reqTimeout","addEventListener","timeout","once","socket","setTimeout","on","res","isRedirect","statusCode","location","get","locationURL","redirect","set","err","counter","follow","parse","host","requestOpts","agent","compress","undefined","delete","chunk","write","end","responseOptions","status","statusText","statusMessage","size","trailer","trailers","codings","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","unzip","Gunzip","pipe","raw","decoder","Inflate","InflateRaw","BrotliDecompress","module","exports","code"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/minipass-fetch/lib/index.js"],"sourcesContent":["'use strict'\nconst Url = require('url')\nconst http = require('http')\nconst https = require('https')\nconst zlib = require('minizlib')\nconst Minipass = require('minipass')\n\nconst Body = require('./body.js')\nconst { writeToStream, getTotalBytes } = Body\nconst Response = require('./response.js')\nconst Headers = require('./headers.js')\nconst { createHeadersLenient } = Headers\nconst Request = require('./request.js')\nconst { getNodeRequestOptions } = Request\nconst FetchError = require('./fetch-error.js')\nconst AbortError = require('./abort-error.js')\n\nconst resolveUrl = Url.resolve\n\nconst fetch = (url, opts) => {\n  if (/^data:/.test(url)) {\n    const request = new Request(url, opts)\n    try {\n      const split = url.split(',')\n      const data = Buffer.from(split[1], 'base64')\n      const type = split[0].match(/^data:(.*);base64$/)[1]\n      return Promise.resolve(new Response(data, {\n        headers: {\n          'Content-Type': type,\n          'Content-Length': data.length,\n        }\n      }))\n    } catch (er) {\n      return Promise.reject(new FetchError(`[${request.method}] ${\n        request.url} invalid URL, ${er.message}`, 'system', er))\n    }\n  }\n\n  return new Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(url, opts)\n    let options\n    try {\n      options = getNodeRequestOptions(request)\n    } catch (er) {\n      return reject(er)\n    }\n\n    const send = (options.protocol === 'https:' ? https : http).request\n    const { signal } = request\n    let response = null\n    const abort = () => {\n      const error = new AbortError('The user aborted a request.')\n      reject(error)\n      if (Minipass.isStream(request.body) &&\n          typeof request.body.destroy === 'function') {\n        request.body.destroy(error)\n      }\n      if (response && response.body) {\n        response.body.emit('error', error)\n      }\n    }\n\n    if (signal && signal.aborted)\n      return abort()\n\n    const abortAndFinalize = () => {\n      abort()\n      finalize()\n    }\n\n    const finalize = () => {\n      req.abort()\n      if (signal)\n        signal.removeEventListener('abort', abortAndFinalize)\n      clearTimeout(reqTimeout)\n    }\n\n    // send request\n    const req = send(options)\n\n    if (signal)\n      signal.addEventListener('abort', abortAndFinalize)\n\n    let reqTimeout = null\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          reject(new FetchError(`network timeout at: ${\n            request.url}`, 'request-timeout'))\n          finalize()\n        }, request.timeout)\n      })\n    }\n\n    req.on('error', er => {\n      // if a 'response' event is emitted before the 'error' event, then by the\n      // time this handler is run it's too late to reject the Promise for the\n      // response. instead, we forward the error event to the response stream\n      // so that the error will surface to the user when they try to consume\n      // the body. this is done as a side effect of aborting the request except\n      // for in windows, where we must forward the event manually, otherwise\n      // there is no longer a ref'd socket attached to the request and the\n      // stream never ends so the event loop runs out of work and the process\n      // exits without warning.\n      // coverage skipped here due to the difficulty in testing\n      // istanbul ignore next\n      if (req.res)\n        req.res.emit('error', er)\n      reject(new FetchError(`request to ${request.url} failed, reason: ${\n        er.message}`, 'system', er))\n      finalize()\n    })\n\n    req.on('response', res => {\n      clearTimeout(reqTimeout)\n\n      const headers = createHeadersLenient(res.headers)\n\n      // HTTP fetch step 5\n      if (fetch.isRedirect(res.statusCode)) {\n        // HTTP fetch step 5.2\n        const location = headers.get('Location')\n\n        // HTTP fetch step 5.3\n        const locationURL = location === null ? null\n          : resolveUrl(request.url, location)\n\n        // HTTP fetch step 5.5\n        switch (request.redirect) {\n          case 'error':\n            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${\n              request.url}`, 'no-redirect'))\n            finalize()\n            return\n\n          case 'manual':\n            // node-fetch-specific step: make manual redirect a bit easier to\n            // use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL)\n              } catch (err) {\n                /* istanbul ignore next: nodejs server prevent invalid\n                   response headers, we can't test this through normal\n                   request */\n                reject(err)\n              }\n            }\n            break\n\n          case 'follow':\n            // HTTP-redirect fetch step 2\n            if (locationURL === null) {\n              break\n            }\n\n            // HTTP-redirect fetch step 5\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${\n                request.url}`, 'max-redirect'))\n              finalize()\n              return\n            }\n\n            // HTTP-redirect fetch step 9\n            if (res.statusCode !== 303 &&\n                request.body &&\n                getTotalBytes(request) === null) {\n              reject(new FetchError(\n                'Cannot follow redirect with body being a readable stream',\n                'unsupported-redirect'\n              ))\n              finalize()\n              return\n            }\n\n            // Update host due to redirection\n            request.headers.set('host', Url.parse(locationURL).host)\n\n            // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n            const requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout,\n            }\n\n            // HTTP-redirect fetch step 11\n            if (res.statusCode === 303 || (\n                (res.statusCode === 301 || res.statusCode === 302) &&\n                request.method === 'POST'\n            )) {\n              requestOpts.method = 'GET'\n              requestOpts.body = undefined\n              requestOpts.headers.delete('content-length')\n            }\n\n            // HTTP-redirect fetch step 15\n            resolve(fetch(new Request(locationURL, requestOpts)))\n            finalize()\n            return\n        }\n      } // end if(isRedirect)\n\n\n      // prepare response\n      res.once('end', () =>\n        signal && signal.removeEventListener('abort', abortAndFinalize))\n\n      const body = new Minipass()\n      // exceedingly rare that the stream would have an error,\n      // but just in case we proxy it to the stream in use.\n      res.on('error', /* istanbul ignore next */ er => body.emit('error', er))\n      res.on('data', (chunk) => body.write(chunk))\n      res.on('end', () => body.end())\n\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout,\n        counter: request.counter,\n        trailer: new Promise(resolve =>\n          res.on('end', () => resolve(createHeadersLenient(res.trailers))))\n      }\n\n      // HTTP-network fetch step 12.1.1.3\n      const codings = headers.get('Content-Encoding')\n\n      // HTTP-network fetch step 12.1.1.4: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress ||\n          request.method === 'HEAD' ||\n          codings === null ||\n          res.statusCode === 204 ||\n          res.statusCode === 304) {\n        response = new Response(body, responseOptions)\n        resolve(response)\n        return\n      }\n\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib.constants.Z_SYNC_FLUSH,\n        finishFlush: zlib.constants.Z_SYNC_FLUSH,\n      }\n\n      // for gzip\n      if (codings == 'gzip' || codings == 'x-gzip') {\n        const unzip = new zlib.Gunzip(zlibOptions)\n        response = new Response(\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => unzip.emit('error', er)).pipe(unzip),\n          responseOptions\n        )\n        resolve(response)\n        return\n      }\n\n      // for deflate\n      if (codings == 'deflate' || codings == 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new Minipass())\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          const decoder = (chunk[0] & 0x0F) === 0x08\n            ? new zlib.Inflate()\n            : new zlib.InflateRaw()\n          // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n          response = new Response(decoder, responseOptions)\n          resolve(response)\n        })\n        return\n      }\n\n\n      // for br\n      if (codings == 'br') {\n        // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n        // istanbul ignore next\n        try {\n          var decoder = new zlib.BrotliDecompress()\n        } catch (err) {\n          reject(err)\n          finalize()\n          return\n        }\n        // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n        body.on('error', /* istanbul ignore next */ er => decoder.emit('error', er)).pipe(decoder)\n        response = new Response(decoder, responseOptions)\n        resolve(response)\n        return\n      }\n\n      // otherwise, use response as-is\n      response = new Response(body, responseOptions)\n      resolve(response)\n    })\n\n    writeToStream(req, request)\n  })\n}\n\nmodule.exports = fetch\n\nfetch.isRedirect = code =>\n  code === 301 ||\n  code === 302 ||\n  code === 303 ||\n  code === 307 ||\n  code === 308\n\nfetch.Headers = Headers\nfetch.Request = Request\nfetch.Response = Response\nfetch.FetchError = FetchError\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}