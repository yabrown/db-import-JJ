{"ast":null,"code":"import _toConsumableArray from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\nvar CollectionFormatToDelimiterMap = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\"\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n  var urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n  var isAbsolutePath = false;\n  var requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    var path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n  var _calculateQueryParame = calculateQueryParameters(operationSpec, operationArguments, fallbackObject),\n    queryParams = _calculateQueryParame.queryParams,\n    sequenceParams = _calculateQueryParame.sequenceParams;\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n  return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n  var result = input;\n  var _iterator = _createForOfIteratorHelper(replacements),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        searchValue = _step$value[0],\n        replaceValue = _step$value[1];\n      result = result.split(searchValue).join(replaceValue);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  var result = new Map();\n  if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    var _iterator2 = _createForOfIteratorHelper(operationSpec.urlParameters),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var urlParameter = _step2.value;\n        var urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n        var parameterPathString = getPathStringFromParameter(urlParameter);\n        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n        if (!urlParameter.skipEncoding) {\n          urlParameterValue = encodeURIComponent(urlParameterValue);\n        }\n        result.set(\"{\".concat(urlParameter.mapper.serializedName || parameterPathString, \"}\"), urlParameterValue);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return result;\n}\nfunction isAbsoluteUrl(url) {\n  return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n  if (!pathToAppend) {\n    return url;\n  }\n  var parsedUrl = new URL(url);\n  var newPath = parsedUrl.pathname;\n  if (!newPath.endsWith(\"/\")) {\n    newPath = \"\".concat(newPath, \"/\");\n  }\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n  var searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    var path = pathToAppend.substring(0, searchStart);\n    var search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? \"\".concat(parsedUrl.search, \"&\").concat(search) : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n  parsedUrl.pathname = newPath;\n  return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n  var _a;\n  var result = new Map();\n  var sequenceParams = new Set();\n  if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n    var _iterator3 = _createForOfIteratorHelper(operationSpec.queryParameters),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var queryParameter = _step3.value;\n        if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n          sequenceParams.add(queryParameter.mapper.serializedName);\n        }\n        var queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n        if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {\n          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n          var delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : \"\";\n          if (Array.isArray(queryParameterValue)) {\n            // replace null and undefined\n            queryParameterValue = queryParameterValue.map(function (item) {\n              if (item === null || item === undefined) {\n                return \"\";\n              }\n              return item;\n            });\n          }\n          if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n            continue;\n          } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n            queryParameterValue = queryParameterValue.join(delimiter);\n          }\n          if (!queryParameter.skipEncoding) {\n            if (Array.isArray(queryParameterValue)) {\n              queryParameterValue = queryParameterValue.map(function (item) {\n                return encodeURIComponent(item);\n              });\n            } else {\n              queryParameterValue = encodeURIComponent(queryParameterValue);\n            }\n          }\n          // Join pipes and CSV *after* encoding, or the server will be upset.\n          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n            queryParameterValue = queryParameterValue.join(delimiter);\n          }\n          result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  return {\n    queryParams: result,\n    sequenceParams: sequenceParams\n  };\n}\nfunction simpleParseQueryParams(queryString) {\n  var result = new Map();\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  }\n  // remove the leading ?\n  queryString = queryString.slice(1);\n  var pairs = queryString.split(\"&\");\n  var _iterator4 = _createForOfIteratorHelper(pairs),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var pair = _step4.value;\n      var _pair$split = pair.split(\"=\", 2),\n        _pair$split2 = _slicedToArray(_pair$split, 2),\n        name = _pair$split2[0],\n        value = _pair$split2[1];\n      var existingValue = result.get(name);\n      if (existingValue) {\n        if (Array.isArray(existingValue)) {\n          existingValue.push(value);\n        } else {\n          result.set(name, [existingValue, value]);\n        }\n      } else {\n        result.set(name, value);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams) {\n  var noOverwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (queryParams.size === 0) {\n    return url;\n  }\n  var parsedUrl = new URL(url);\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  var combinedParams = simpleParseQueryParams(parsedUrl.search);\n  var _iterator5 = _createForOfIteratorHelper(queryParams),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _step5$value = _slicedToArray(_step5.value, 2),\n        name = _step5$value[0],\n        value = _step5$value[1];\n      var existingValue = combinedParams.get(name);\n      if (Array.isArray(existingValue)) {\n        if (Array.isArray(value)) {\n          existingValue.push.apply(existingValue, _toConsumableArray(value));\n          var valueSet = new Set(existingValue);\n          combinedParams.set(name, Array.from(valueSet));\n        } else {\n          existingValue.push(value);\n        }\n      } else if (existingValue) {\n        if (Array.isArray(value)) {\n          value.unshift(existingValue);\n        } else if (sequenceParams.has(name)) {\n          combinedParams.set(name, [existingValue, value]);\n        }\n        if (!noOverwrite) {\n          combinedParams.set(name, value);\n        }\n      } else {\n        combinedParams.set(name, value);\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  var searchPieces = [];\n  var _iterator6 = _createForOfIteratorHelper(combinedParams),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _step6$value = _slicedToArray(_step6.value, 2),\n        _name = _step6$value[0],\n        _value = _step6$value[1];\n      if (typeof _value === \"string\") {\n        searchPieces.push(\"\".concat(_name, \"=\").concat(_value));\n      } else if (Array.isArray(_value)) {\n        // QUIRK: If we get an array of values, include multiple key/value pairs\n        var _iterator7 = _createForOfIteratorHelper(_value),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var subValue = _step7.value;\n            searchPieces.push(\"\".concat(_name, \"=\").concat(subValue));\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      } else {\n        searchPieces.push(\"\".concat(_name, \"=\").concat(_value));\n      }\n    }\n    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  parsedUrl.search = searchPieces.length ? \"?\".concat(searchPieces.join(\"&\")) : \"\";\n  return parsedUrl.toString();\n}","map":{"version":3,"names":["getOperationArgumentValueFromParameter","getPathStringFromParameter","CollectionFormatToDelimiterMap","CSV","SSV","Multi","TSV","Pipes","getRequestUrl","baseUri","operationSpec","operationArguments","fallbackObject","urlReplacements","calculateUrlReplacements","isAbsolutePath","requestUrl","replaceAll","path","startsWith","substring","isAbsoluteUrl","appendPath","_calculateQueryParame","calculateQueryParameters","queryParams","sequenceParams","appendQueryParams","input","replacements","result","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","value","searchValue","replaceValue","split","join","err","e","f","Map","_a","urlParameters","length","_iterator2","_step2","urlParameter","urlParameterValue","parameterPathString","serializer","serialize","mapper","skipEncoding","encodeURIComponent","set","concat","serializedName","url","includes","pathToAppend","parsedUrl","URL","newPath","pathname","endsWith","searchStart","indexOf","search","toString","Set","queryParameters","_iterator3","_step3","queryParameter","type","name","add","queryParameterValue","undefined","required","delimiter","collectionFormat","Array","isArray","map","item","simpleParseQueryParams","queryString","slice","pairs","_iterator4","_step4","pair","_pair$split","_pair$split2","existingValue","get","push","noOverwrite","arguments","size","combinedParams","_iterator5","_step5","_step5$value","apply","_toConsumableArray","valueSet","from","unshift","has","searchPieces","_iterator6","_step6","_step6$value","_iterator7","_step7","subValue"],"sources":["../../src/urlHelpers.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationArguments, OperationSpec, QueryCollectionFormat } from \"./interfaces\";\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n\nconst CollectionFormatToDelimiterMap: { [key in QueryCollectionFormat]: string } = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\",\n};\n\nexport function getRequestUrl(\n  baseUri: string,\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): string {\n  const urlReplacements = calculateUrlReplacements(\n    operationSpec,\n    operationArguments,\n    fallbackObject\n  );\n\n  let isAbsolutePath = false;\n\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    let path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n\n  const { queryParams, sequenceParams } = calculateQueryParameters(\n    operationSpec,\n    operationArguments,\n    fallbackObject\n  );\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n\n  return requestUrl;\n}\n\nfunction replaceAll(input: string, replacements: Map<string, string>): string {\n  let result = input;\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n  return result;\n}\n\nfunction calculateUrlReplacements(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): Map<string, string> {\n  const result = new Map<string, string>();\n  if (operationSpec.urlParameters?.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue: string = getOperationArgumentValueFromParameter(\n        operationArguments,\n        urlParameter,\n        fallbackObject\n      );\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(\n        urlParameter.mapper,\n        urlParameterValue,\n        parameterPathString\n      );\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n      result.set(\n        `{${urlParameter.mapper.serializedName || parameterPathString}}`,\n        urlParameterValue\n      );\n    }\n  }\n  return result;\n}\n\nfunction isAbsoluteUrl(url: string): boolean {\n  return url.includes(\"://\");\n}\n\nfunction appendPath(url: string, pathToAppend?: string): string {\n  if (!pathToAppend) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n\n  const searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n\n  parsedUrl.pathname = newPath;\n\n  return parsedUrl.toString();\n}\n\nfunction calculateQueryParameters(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any }\n): {\n  queryParams: Map<string, string | string[]>;\n  sequenceParams: Set<string>;\n} {\n  const result = new Map<string, string | string[]>();\n  const sequenceParams: Set<string> = new Set<string>();\n\n  if (operationSpec.queryParameters?.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n        sequenceParams.add(queryParameter.mapper.serializedName);\n      }\n      let queryParameterValue: string | string[] = getOperationArgumentValueFromParameter(\n        operationArguments,\n        queryParameter,\n        fallbackObject\n      );\n      if (\n        (queryParameterValue !== undefined && queryParameterValue !== null) ||\n        queryParameter.mapper.required\n      ) {\n        queryParameterValue = operationSpec.serializer.serialize(\n          queryParameter.mapper,\n          queryParameterValue,\n          getPathStringFromParameter(queryParameter)\n        );\n\n        const delimiter = queryParameter.collectionFormat\n          ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n          : \"\";\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map((item) => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n\n            return item;\n          });\n        }\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map((item: string) => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        }\n\n        // Join pipes and CSV *after* encoding, or the server will be upset.\n        if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n\n        result.set(\n          queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n          queryParameterValue\n        );\n      }\n    }\n  }\n  return {\n    queryParams: result,\n    sequenceParams,\n  };\n}\n\nfunction simpleParseQueryParams(queryString: string): Map<string, string | string[] | undefined> {\n  const result: Map<string, string | string[] | undefined> = new Map<\n    string,\n    string | string[] | undefined\n  >();\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  }\n\n  // remove the leading ?\n  queryString = queryString.slice(1);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const [name, value] = pair.split(\"=\", 2);\n    const existingValue = result.get(name);\n    if (existingValue) {\n      if (Array.isArray(existingValue)) {\n        existingValue.push(value);\n      } else {\n        result.set(name, [existingValue, value]);\n      }\n    } else {\n      result.set(name, value);\n    }\n  }\n\n  return result;\n}\n\n/** @internal */\nexport function appendQueryParams(\n  url: string,\n  queryParams: Map<string, string | string[]>,\n  sequenceParams: Set<string>,\n  noOverwrite: boolean = false\n): string {\n  if (queryParams.size === 0) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  const combinedParams = simpleParseQueryParams(parsedUrl.search);\n\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n    if (Array.isArray(existingValue)) {\n      if (Array.isArray(value)) {\n        existingValue.push(...value);\n        const valueSet = new Set(existingValue);\n        combinedParams.set(name, Array.from(valueSet));\n      } else {\n        existingValue.push(value);\n      }\n    } else if (existingValue) {\n      if (Array.isArray(value)) {\n        value.unshift(existingValue);\n      } else if (sequenceParams.has(name)) {\n        combinedParams.set(name, [existingValue, value]);\n      }\n      if (!noOverwrite) {\n        combinedParams.set(name, value);\n      }\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n\n  const searchPieces: string[] = [];\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else if (Array.isArray(value)) {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    } else {\n      searchPieces.push(`${name}=${value}`);\n    }\n  }\n\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}