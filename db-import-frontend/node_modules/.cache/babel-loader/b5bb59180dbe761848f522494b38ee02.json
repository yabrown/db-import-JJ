{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport var redirectPolicyName = \"redirectPolicy\";\n/**\n * Methods that are allowed to follow redirects 301 and 302\n */\nvar allowedRedirect = [\"GET\", \"HEAD\"];\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * In the browser, this policy is not used.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$maxRetries = options.maxRetries,\n    maxRetries = _options$maxRetries === void 0 ? 20 : _options$maxRetries;\n  return {\n    name: redirectPolicyName,\n    sendRequest: function sendRequest(request, next) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return next(request);\n            case 2:\n              response = _context.sent;\n              return _context.abrupt(\"return\", handleRedirect(next, response, maxRetries));\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    }\n  };\n}\nfunction handleRedirect(_x, _x2, _x3) {\n  return _handleRedirect.apply(this, arguments);\n}\nfunction _handleRedirect() {\n  _handleRedirect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(next, response, maxRetries) {\n    var currentRetries,\n      request,\n      status,\n      headers,\n      locationHeader,\n      url,\n      res,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          currentRetries = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 0;\n          request = response.request, status = response.status, headers = response.headers;\n          locationHeader = headers.get(\"location\");\n          if (!(locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === \"POST\" || status === 307) && currentRetries < maxRetries)) {\n            _context2.next = 12;\n            break;\n          }\n          url = new URL(locationHeader, request.url);\n          request.url = url.toString();\n          // POST request with Status code 303 should be converted into a\n          // redirected GET request if the redirect url is present in the location header\n          if (status === 303) {\n            request.method = \"GET\";\n            request.headers.delete(\"Content-Length\");\n            delete request.body;\n          }\n          request.headers.delete(\"Authorization\");\n          _context2.next = 10;\n          return next(request);\n        case 10:\n          res = _context2.sent;\n          return _context2.abrupt(\"return\", handleRedirect(next, res, maxRetries, currentRetries + 1));\n        case 12:\n          return _context2.abrupt(\"return\", response);\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _handleRedirect.apply(this, arguments);\n}","map":{"version":3,"names":["redirectPolicyName","allowedRedirect","redirectPolicy","options","arguments","length","undefined","_options$maxRetries","maxRetries","name","sendRequest","request","next","_asyncToGenerator","_regeneratorRuntime","mark","_callee","response","wrap","_callee$","_context","prev","sent","abrupt","handleRedirect","stop","_x","_x2","_x3","_handleRedirect","apply","_callee2","currentRetries","status","headers","locationHeader","url","res","_args2","_callee2$","_context2","get","includes","method","URL","toString","delete","body"],"sources":["../../../src/policies/redirectPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport const redirectPolicyName = \"redirectPolicy\";\n\n/**\n * Methods that are allowed to follow redirects 301 and 302\n */\nconst allowedRedirect = [\"GET\", \"HEAD\"];\n\n/**\n * Options for how redirect responses are handled.\n */\nexport interface RedirectPolicyOptions {\n  /**\n   * The maximum number of times the redirect URL will be tried before\n   * failing.  Defaults to 20.\n   */\n  maxRetries?: number;\n}\n\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * In the browser, this policy is not used.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy(options: RedirectPolicyOptions = {}): PipelinePolicy {\n  const { maxRetries = 20 } = options;\n  return {\n    name: redirectPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return handleRedirect(next, response, maxRetries);\n    },\n  };\n}\n\nasync function handleRedirect(\n  next: SendRequest,\n  response: PipelineResponse,\n  maxRetries: number,\n  currentRetries: number = 0\n): Promise<PipelineResponse> {\n  const { request, status, headers } = response;\n  const locationHeader = headers.get(\"location\");\n  if (\n    locationHeader &&\n    (status === 300 ||\n      (status === 301 && allowedRedirect.includes(request.method)) ||\n      (status === 302 && allowedRedirect.includes(request.method)) ||\n      (status === 303 && request.method === \"POST\") ||\n      status === 307) &&\n    currentRetries < maxRetries\n  ) {\n    const url = new URL(locationHeader, request.url);\n    request.url = url.toString();\n\n    // POST request with Status code 303 should be converted into a\n    // redirected GET request if the redirect url is present in the location header\n    if (status === 303) {\n      request.method = \"GET\";\n      request.headers.delete(\"Content-Length\");\n      delete request.body;\n    }\n\n    request.headers.delete(\"Authorization\");\n\n    const res = await next(request);\n    return handleRedirect(next, res, maxRetries, currentRetries + 1);\n  }\n\n  return response;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}