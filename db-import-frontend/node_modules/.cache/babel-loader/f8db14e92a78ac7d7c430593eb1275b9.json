{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar util = require('util');\nvar pMap = require('p-map');\nvar contentPath = require('./content/path');\nvar fixOwner = require('./util/fix-owner');\nvar fs = require('fs');\nvar fsm = require('fs-minipass');\nvar glob = util.promisify(require('glob'));\nvar index = require('./entry-index');\nvar path = require('path');\nvar rimraf = util.promisify(require('rimraf'));\nvar ssri = require('ssri');\nvar hasOwnProperty = function hasOwnProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\nvar stat = util.promisify(fs.stat);\nvar truncate = util.promisify(fs.truncate);\nvar writeFile = util.promisify(fs.writeFile);\nvar readFile = util.promisify(fs.readFile);\nvar verifyOpts = function verifyOpts(opts) {\n  return _objectSpread({\n    concurrency: 20,\n    log: {\n      silly: function silly() {}\n    }\n  }, opts);\n};\nmodule.exports = verify;\nfunction verify(cache, opts) {\n  opts = verifyOpts(opts);\n  opts.log.silly('verify', 'verifying cache at', cache);\n  var steps = [markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime];\n  return steps.reduce(function (promise, step, i) {\n    var label = step.name;\n    var start = new Date();\n    return promise.then(function (stats) {\n      return step(cache, opts).then(function (s) {\n        s && Object.keys(s).forEach(function (k) {\n          stats[k] = s[k];\n        });\n        var end = new Date();\n        if (!stats.runTime) stats.runTime = {};\n        stats.runTime[label] = end - start;\n        return Promise.resolve(stats);\n      });\n    });\n  }, Promise.resolve({})).then(function (stats) {\n    stats.runTime.total = stats.endTime - stats.startTime;\n    opts.log.silly('verify', 'verification finished for', cache, 'in', \"\".concat(stats.runTime.total, \"ms\"));\n    return stats;\n  });\n}\nfunction markStartTime(cache, opts) {\n  return Promise.resolve({\n    startTime: new Date()\n  });\n}\nfunction markEndTime(cache, opts) {\n  return Promise.resolve({\n    endTime: new Date()\n  });\n}\nfunction fixPerms(cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions');\n  return fixOwner.mkdirfix(cache, cache).then(function () {\n    // TODO - fix file permissions too\n    return fixOwner.chownr(cache, cache);\n  }).then(function () {\n    return null;\n  });\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect(cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content');\n  var indexStream = index.lsStream(cache);\n  var liveContent = new Set();\n  indexStream.on('data', function (entry) {\n    if (opts.filter && !opts.filter(entry)) return;\n    liveContent.add(entry.integrity.toString());\n  });\n  return new Promise(function (resolve, reject) {\n    indexStream.on('end', resolve).on('error', reject);\n  }).then(function () {\n    var contentDir = contentPath.contentDir(cache);\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then(function (files) {\n      return Promise.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).then(function (stats) {\n        return pMap(files, function (f) {\n          var split = f.split(/[/\\\\]/);\n          var digest = split.slice(split.length - 3).join('');\n          var algo = split[split.length - 4];\n          var integrity = ssri.fromHex(digest, algo);\n          if (liveContent.has(integrity.toString())) {\n            return verifyContent(f, integrity).then(function (info) {\n              if (!info.valid) {\n                stats.reclaimedCount++;\n                stats.badContentCount++;\n                stats.reclaimedSize += info.size;\n              } else {\n                stats.verifiedContent++;\n                stats.keptSize += info.size;\n              }\n              return stats;\n            });\n          } else {\n            // No entries refer to this content. We can delete.\n            stats.reclaimedCount++;\n            return stat(f).then(function (s) {\n              return rimraf(f).then(function () {\n                stats.reclaimedSize += s.size;\n                return stats;\n              });\n            });\n          }\n        }, {\n          concurrency: opts.concurrency\n        }).then(function () {\n          return stats;\n        });\n      });\n    });\n  });\n}\nfunction verifyContent(filepath, sri) {\n  return stat(filepath).then(function (s) {\n    var contentInfo = {\n      size: s.size,\n      valid: true\n    };\n    return ssri.checkStream(new fsm.ReadStream(filepath), sri).catch(function (err) {\n      if (err.code !== 'EINTEGRITY') throw err;\n      return rimraf(filepath).then(function () {\n        contentInfo.valid = false;\n      });\n    }).then(function () {\n      return contentInfo;\n    });\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') return {\n      size: 0,\n      valid: false\n    };\n    throw err;\n  });\n}\nfunction rebuildIndex(cache, opts) {\n  opts.log.silly('verify', 'rebuilding index');\n  return index.ls(cache).then(function (entries) {\n    var stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    };\n    var buckets = {};\n    for (var k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        var hashed = index.hashKey(k);\n        var entry = entries[k];\n        var excluded = opts.filter && !opts.filter(entry);\n        excluded && stats.rejectedEntries++;\n        if (buckets[hashed] && !excluded) buckets[hashed].push(entry);else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = [];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        } else {\n          buckets[hashed] = [entry];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        }\n      }\n    }\n    return pMap(Object.keys(buckets), function (key) {\n      return rebuildBucket(cache, buckets[key], stats, opts);\n    }, {\n      concurrency: opts.concurrency\n    }).then(function () {\n      return stats;\n    });\n  });\n}\nfunction rebuildBucket(cache, bucket, stats, opts) {\n  return truncate(bucket._path).then(function () {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return bucket.reduce(function (promise, entry) {\n      return promise.then(function () {\n        var content = contentPath(cache, entry.integrity);\n        return stat(content).then(function () {\n          return index.insert(cache, entry.key, entry.integrity, {\n            metadata: entry.metadata,\n            size: entry.size\n          }).then(function () {\n            stats.totalEntries++;\n          });\n        }).catch(function (err) {\n          if (err.code === 'ENOENT') {\n            stats.rejectedEntries++;\n            stats.missingContent++;\n            return;\n          }\n          throw err;\n        });\n      });\n    }, Promise.resolve());\n  });\n}\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rimraf(path.join(cache, 'tmp'));\n}\nfunction writeVerifile(cache, opts) {\n  var verifile = path.join(cache, '_lastverified');\n  opts.log.silly('verify', 'writing verifile to ' + verifile);\n  try {\n    return writeFile(verifile, '' + +new Date());\n  } finally {\n    fixOwner.chownr.sync(cache, verifile);\n  }\n}\nmodule.exports.lastRun = lastRun;\nfunction lastRun(cache) {\n  return readFile(path.join(cache, '_lastverified'), 'utf8').then(function (data) {\n    return new Date(+data);\n  });\n}","map":{"version":3,"names":["_objectSpread","require","default","util","pMap","contentPath","fixOwner","fs","fsm","glob","promisify","index","path","rimraf","ssri","hasOwnProperty","obj","key","Object","prototype","call","stat","truncate","writeFile","readFile","verifyOpts","opts","concurrency","log","silly","module","exports","verify","cache","steps","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","reduce","promise","step","i","label","name","start","Date","then","stats","s","keys","forEach","k","end","runTime","Promise","resolve","total","endTime","startTime","concat","mkdirfix","chownr","indexStream","lsStream","liveContent","Set","on","entry","filter","add","integrity","toString","reject","contentDir","join","follow","nodir","nosort","files","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","f","split","digest","slice","length","algo","fromHex","has","verifyContent","info","valid","size","filepath","sri","contentInfo","checkStream","ReadStream","catch","err","code","ls","entries","missingContent","rejectedEntries","totalEntries","buckets","hashed","hashKey","excluded","push","_path","bucketPath","rebuildBucket","bucket","content","insert","metadata","verifile","sync","lastRun","data"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/cacache/lib/verify.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst pMap = require('p-map')\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst glob = util.promisify(require('glob'))\nconst index = require('./entry-index')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\n\nconst hasOwnProperty = (obj, key) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nconst stat = util.promisify(fs.stat)\nconst truncate = util.promisify(fs.truncate)\nconst writeFile = util.promisify(fs.writeFile)\nconst readFile = util.promisify(fs.readFile)\n\nconst verifyOpts = (opts) => ({\n  concurrency: 20,\n  log: { silly () {} },\n  ...opts,\n})\n\nmodule.exports = verify\n\nfunction verify (cache, opts) {\n  opts = verifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n\n  const steps = [\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime,\n  ]\n\n  return steps\n    .reduce((promise, step, i) => {\n      const label = step.name\n      const start = new Date()\n      return promise.then((stats) => {\n        return step(cache, opts).then((s) => {\n          s &&\n            Object.keys(s).forEach((k) => {\n              stats[k] = s[k]\n            })\n          const end = new Date()\n          if (!stats.runTime)\n            stats.runTime = {}\n\n          stats.runTime[label] = end - start\n          return Promise.resolve(stats)\n        })\n      })\n    }, Promise.resolve({}))\n    .then((stats) => {\n      stats.runTime.total = stats.endTime - stats.startTime\n      opts.log.silly(\n        'verify',\n        'verification finished for',\n        cache,\n        'in',\n        `${stats.runTime.total}ms`\n      )\n      return stats\n    })\n}\n\nfunction markStartTime (cache, opts) {\n  return Promise.resolve({ startTime: new Date() })\n}\n\nfunction markEndTime (cache, opts) {\n  return Promise.resolve({ endTime: new Date() })\n}\n\nfunction fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  return fixOwner\n    .mkdirfix(cache, cache)\n    .then(() => {\n      // TODO - fix file permissions too\n      return fixOwner.chownr(cache, cache)\n    })\n    .then(() => null)\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', (entry) => {\n    if (opts.filter && !opts.filter(entry))\n      return\n\n    liveContent.add(entry.integrity.toString())\n  })\n  return new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject)\n  }).then(() => {\n    const contentDir = contentPath.contentDir(cache)\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true,\n    }).then((files) => {\n      return Promise.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0,\n      }).then((stats) =>\n        pMap(\n          files,\n          (f) => {\n            const split = f.split(/[/\\\\]/)\n            const digest = split.slice(split.length - 3).join('')\n            const algo = split[split.length - 4]\n            const integrity = ssri.fromHex(digest, algo)\n            if (liveContent.has(integrity.toString())) {\n              return verifyContent(f, integrity).then((info) => {\n                if (!info.valid) {\n                  stats.reclaimedCount++\n                  stats.badContentCount++\n                  stats.reclaimedSize += info.size\n                } else {\n                  stats.verifiedContent++\n                  stats.keptSize += info.size\n                }\n                return stats\n              })\n            } else {\n              // No entries refer to this content. We can delete.\n              stats.reclaimedCount++\n              return stat(f).then((s) => {\n                return rimraf(f).then(() => {\n                  stats.reclaimedSize += s.size\n                  return stats\n                })\n              })\n            }\n          },\n          { concurrency: opts.concurrency }\n        ).then(() => stats)\n      )\n    })\n  })\n}\n\nfunction verifyContent (filepath, sri) {\n  return stat(filepath)\n    .then((s) => {\n      const contentInfo = {\n        size: s.size,\n        valid: true,\n      }\n      return ssri\n        .checkStream(new fsm.ReadStream(filepath), sri)\n        .catch((err) => {\n          if (err.code !== 'EINTEGRITY')\n            throw err\n\n          return rimraf(filepath).then(() => {\n            contentInfo.valid = false\n          })\n        })\n        .then(() => contentInfo)\n    })\n    .catch((err) => {\n      if (err.code === 'ENOENT')\n        return { size: 0, valid: false }\n\n      throw err\n    })\n}\n\nfunction rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  return index.ls(cache).then((entries) => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0,\n    }\n    const buckets = {}\n    for (const k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        const hashed = index.hashKey(k)\n        const entry = entries[k]\n        const excluded = opts.filter && !opts.filter(entry)\n        excluded && stats.rejectedEntries++\n        if (buckets[hashed] && !excluded)\n          buckets[hashed].push(entry)\n        else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = []\n          buckets[hashed]._path = index.bucketPath(cache, k)\n        } else {\n          buckets[hashed] = [entry]\n          buckets[hashed]._path = index.bucketPath(cache, k)\n        }\n      }\n    }\n    return pMap(\n      Object.keys(buckets),\n      (key) => {\n        return rebuildBucket(cache, buckets[key], stats, opts)\n      },\n      { concurrency: opts.concurrency }\n    ).then(() => stats)\n  })\n}\n\nfunction rebuildBucket (cache, bucket, stats, opts) {\n  return truncate(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return bucket.reduce((promise, entry) => {\n      return promise.then(() => {\n        const content = contentPath(cache, entry.integrity)\n        return stat(content)\n          .then(() => {\n            return index\n              .insert(cache, entry.key, entry.integrity, {\n                metadata: entry.metadata,\n                size: entry.size,\n              })\n              .then(() => {\n                stats.totalEntries++\n              })\n          })\n          .catch((err) => {\n            if (err.code === 'ENOENT') {\n              stats.rejectedEntries++\n              stats.missingContent++\n              return\n            }\n            throw err\n          })\n      })\n    }, Promise.resolve())\n  })\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rimraf(path.join(cache, 'tmp'))\n}\n\nfunction writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  try {\n    return writeFile(verifile, '' + +new Date())\n  } finally {\n    fixOwner.chownr.sync(cache, verifile)\n  }\n}\n\nmodule.exports.lastRun = lastRun\n\nfunction lastRun (cache) {\n  return readFile(path.join(cache, '_lastverified'), 'utf8').then(\n    (data) => new Date(+data)\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}