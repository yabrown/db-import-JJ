{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\nvar fs = require('fs');\nvar path = require('path');\nvar log = require('npmlog');\nvar existsAsync = fs.exists || path.exists;\nvar versioning = require('./util/versioning.js');\nvar napi = require('./util/napi.js');\nvar makeDir = require('make-dir');\n// for fetching binaries\nvar fetch = require('node-fetch');\nvar tar = require('tar');\nvar npgVersion = 'unknown';\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  var ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {\n  // do nothing\n}\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri);\n\n  // Try getting version info from the currently running npm.\n  var envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  var sanitized = uri.replace('+', '%2B');\n  var requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n  var proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n  var agent;\n  if (proxyUrl) {\n    var ProxyAgent = require('https-proxy-agent');\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n  fetch(sanitized, {\n    agent: agent\n  }).then(function (res) {\n    if (!res.ok) {\n      throw new Error(\"response status \".concat(res.status, \" \").concat(res.statusText, \" on \").concat(sanitized));\n    }\n    var dataStream = res.body;\n    return new Promise(function (resolve, reject) {\n      var extractions = 0;\n      var countExtractions = function countExtractions(entry) {\n        extractions += 1;\n        log.info('install', 'unpacking %s', entry.path);\n      };\n      dataStream.pipe(extract(targetDir, countExtractions)).on('error', function (e) {\n        reject(e);\n      });\n      dataStream.on('end', function () {\n        resolve(\"extracted file count: \".concat(extractions));\n      });\n      dataStream.on('error', function (e) {\n        reject(e);\n      });\n    });\n  }).then(function (text) {\n    log.info(text);\n    callback();\n  }).catch(function (e) {\n    log.error(\"install \".concat(e.message));\n    callback(e);\n  });\n}\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry: onentry\n  });\n}\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n  log.info('Found local file to extract from ' + from);\n\n  // extract helpers\n  var extractCount = 0;\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n  function afterExtract(err) {\n    if (err) return callback(err);\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions)).on('close', afterExtract).on('error', afterExtract);\n}\nfunction do_build(gyp, argv, callback) {\n  var args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\nfunction print_fallback_error(err, opts, package_json) {\n  var fallback_message = ' (falling back to source compile with node-gyp)';\n  var full_message = '';\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n}\n\n//\n// install\n//\nfunction install(gyp, argv, callback) {\n  var package_json = gyp.package_json;\n  var napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  var source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  var update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  var should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    var fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    var should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true';\n    // but allow override from npm\n    if (process.env.npm_config_argv) {\n      var cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      var match = cooked.indexOf('--fallback-to-build');\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n    var opts;\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    var from = opts.hosted_tarball;\n    var to = opts.module_path;\n    var binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, function (found) {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n      makeDir(to).then(function () {\n        var fileName = from.startsWith('file://') && from.slice('file://'.length);\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch(function (err) {\n        after_place(err);\n      });\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["module","exports","install","usage","fs","require","path","log","existsAsync","exists","versioning","napi","makeDir","fetch","tar","npgVersion","ownPackageJSON","readFileSync","join","__dirname","JSON","parse","version","e","place_binary","uri","targetDir","opts","callback","http","envVersionInfo","process","env","npm_config_user_agent","sanitized","replace","requestOpts","headers","follow_max","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","agent","ProxyAgent","then","res","ok","Error","concat","status","statusText","dataStream","body","Promise","resolve","reject","extractions","countExtractions","entry","info","pipe","extract","on","text","catch","error","message","to","onentry","cwd","strip","extract_from_local","from","existsSync","extractCount","afterExtract","err","createReadStream","do_build","gyp","argv","args","todo","push","name","nextTick","print_fallback_error","package_json","fallback_message","full_message","statusCode","undefined","runtime","target","versions","node","node_abi","libc","warn","hosted_tarball","napi_build_version","get_napi_build_version_from_command_args","source_build","build_from_source","update_binary","should_do_source_build","fallback_to_build","should_do_fallback_build","npm_config_argv","cooked","match","indexOf","length","evaluate","module_path","binary_module","module_name","found","console","fileName","startsWith","slice","after_place"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/@mapbox/node-pre-gyp/lib/install.js"],"sourcesContent":["'use strict';\n\nmodule.exports = exports = install;\n\nexports.usage = 'Attempts to install pre-built binary for module';\n\nconst fs = require('fs');\nconst path = require('path');\nconst log = require('npmlog');\nconst existsAsync = fs.exists || path.exists;\nconst versioning = require('./util/versioning.js');\nconst napi = require('./util/napi.js');\nconst makeDir = require('make-dir');\n// for fetching binaries\nconst fetch = require('node-fetch');\nconst tar = require('tar');\n\nlet npgVersion = 'unknown';\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {\n  // do nothing\n}\n\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri);\n\n  // Try getting version info from the currently running npm.\n  const envVersionInfo = process.env.npm_config_user_agent ||\n        'node ' + process.version;\n\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n\n  const proxyUrl = opts.proxy ||\n                    process.env.http_proxy ||\n                    process.env.HTTP_PROXY ||\n                    process.env.npm_config_proxy;\n  let agent;\n  if (proxyUrl) {\n    const ProxyAgent = require('https-proxy-agent');\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n\n  fetch(sanitized, { agent })\n    .then((res) => {\n      if (!res.ok) {\n        throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n      }\n      const dataStream = res.body;\n\n      return new Promise((resolve, reject) => {\n        let extractions = 0;\n        const countExtractions = (entry) => {\n          extractions += 1;\n          log.info('install', 'unpacking %s', entry.path);\n        };\n\n        dataStream.pipe(extract(targetDir, countExtractions))\n          .on('error', (e) => {\n            reject(e);\n          });\n        dataStream.on('end', () => {\n          resolve(`extracted file count: ${extractions}`);\n        });\n        dataStream.on('error', (e) => {\n          reject(e);\n        });\n      });\n    })\n    .then((text) => {\n      log.info(text);\n      callback();\n    })\n    .catch((e) => {\n      log.error(`install ${e.message}`);\n      callback(e);\n    });\n}\n\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\n\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n  log.info('Found local file to extract from ' + from);\n\n  // extract helpers\n  let extractCount = 0;\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n  function afterExtract(err) {\n    if (err) return callback(err);\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions))\n    .on('close', afterExtract)\n    .on('error', afterExtract);\n}\n\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({ name: 'build', args: args });\n  process.nextTick(callback);\n}\n\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n}\n\n//\n// install\n//\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');\n    // but allow override from npm\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n    let opts;\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, (found) => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch((err) => {\n        after_place(err);\n      });\n\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAGA,OAAO,GAAGC,OAAO;AAElCD,OAAO,CAACE,KAAK,GAAG,iDAAiD;AAEjE,IAAMC,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACxB,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,IAAME,GAAG,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAC7B,IAAMG,WAAW,GAAGJ,EAAE,CAACK,MAAM,IAAIH,IAAI,CAACG,MAAM;AAC5C,IAAMC,UAAU,GAAGL,OAAO,CAAC,sBAAsB,CAAC;AAClD,IAAMM,IAAI,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AACtC,IAAMO,OAAO,GAAGP,OAAO,CAAC,UAAU,CAAC;AACnC;AACA,IAAMQ,KAAK,GAAGR,OAAO,CAAC,YAAY,CAAC;AACnC,IAAMS,GAAG,GAAGT,OAAO,CAAC,KAAK,CAAC;AAE1B,IAAIU,UAAU,GAAG,SAAS;AAC1B,IAAI;EACF;EACA,IAAMC,cAAc,GAAGZ,EAAE,CAACa,YAAY,CAACX,IAAI,CAACY,IAAI,CAACC,SAAS,EAAE,IAAI,EAAE,cAAc,CAAC,EAAE,MAAM,CAAC;EAC1FJ,UAAU,GAAGK,IAAI,CAACC,KAAK,CAACL,cAAc,CAAC,CAACM,OAAO;AACjD,CAAC,CAAC,OAAOC,CAAC,EAAE;EACV;AAAA;AAGF,SAASC,YAAYA,CAACC,GAAG,EAAEC,SAAS,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EACpDrB,GAAG,CAACsB,IAAI,CAAC,KAAK,EAAEJ,GAAG,CAAC;;EAEpB;EACA,IAAMK,cAAc,GAAGC,OAAO,CAACC,GAAG,CAACC,qBAAqB,IAClD,OAAO,GAAGF,OAAO,CAACT,OAAO;EAE/B,IAAMY,SAAS,GAAGT,GAAG,CAACU,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC;EACzC,IAAMC,WAAW,GAAG;IAClBX,GAAG,EAAES,SAAS;IACdG,OAAO,EAAE;MACP,YAAY,EAAE,iBAAiB,GAAGtB,UAAU,GAAG,IAAI,GAAGe,cAAc,GAAG;IACzE,CAAC;IACDQ,UAAU,EAAE;EACd,CAAC;EAED,IAAIX,IAAI,CAACY,MAAM,EAAE;IACf,IAAI;MACFH,WAAW,CAACI,EAAE,GAAGpC,EAAE,CAACa,YAAY,CAACU,IAAI,CAACY,MAAM,CAAC;IAC/C,CAAC,CAAC,OAAOhB,CAAC,EAAE;MACV,OAAOK,QAAQ,CAACL,CAAC,CAAC;IACpB;EACF,CAAC,MAAM,IAAII,IAAI,CAACa,EAAE,EAAE;IAClBJ,WAAW,CAACI,EAAE,GAAGb,IAAI,CAACa,EAAE;EAC1B;EAEA,IAAMC,QAAQ,GAAGd,IAAI,CAACe,KAAK,IACTX,OAAO,CAACC,GAAG,CAACW,UAAU,IACtBZ,OAAO,CAACC,GAAG,CAACY,UAAU,IACtBb,OAAO,CAACC,GAAG,CAACa,gBAAgB;EAC9C,IAAIC,KAAK;EACT,IAAIL,QAAQ,EAAE;IACZ,IAAMM,UAAU,GAAG1C,OAAO,CAAC,mBAAmB,CAAC;IAC/CyC,KAAK,GAAG,IAAIC,UAAU,CAACN,QAAQ,CAAC;IAChClC,GAAG,CAACsB,IAAI,CAAC,UAAU,EAAE,oCAAoC,EAAEY,QAAQ,CAAC;EACtE;EAEA5B,KAAK,CAACqB,SAAS,EAAE;IAAEY,KAAK,EAALA;EAAM,CAAC,CAAC,CACxBE,IAAI,CAAC,UAACC,GAAG,EAAK;IACb,IAAI,CAACA,GAAG,CAACC,EAAE,EAAE;MACX,MAAM,IAAIC,KAAK,oBAAAC,MAAA,CAAoBH,GAAG,CAACI,MAAM,OAAAD,MAAA,CAAIH,GAAG,CAACK,UAAU,UAAAF,MAAA,CAAOlB,SAAS,CAAE,CAAC;IACpF;IACA,IAAMqB,UAAU,GAAGN,GAAG,CAACO,IAAI;IAE3B,OAAO,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;MACtC,IAAIC,WAAW,GAAG,CAAC;MACnB,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIC,KAAK,EAAK;QAClCF,WAAW,IAAI,CAAC;QAChBrD,GAAG,CAACwD,IAAI,CAAC,SAAS,EAAE,cAAc,EAAED,KAAK,CAACxD,IAAI,CAAC;MACjD,CAAC;MAEDiD,UAAU,CAACS,IAAI,CAACC,OAAO,CAACvC,SAAS,EAAEmC,gBAAgB,CAAC,CAAC,CAClDK,EAAE,CAAC,OAAO,EAAE,UAAC3C,CAAC,EAAK;QAClBoC,MAAM,CAACpC,CAAC,CAAC;MACX,CAAC,CAAC;MACJgC,UAAU,CAACW,EAAE,CAAC,KAAK,EAAE,YAAM;QACzBR,OAAO,0BAAAN,MAAA,CAA0BQ,WAAW,CAAE,CAAC;MACjD,CAAC,CAAC;MACFL,UAAU,CAACW,EAAE,CAAC,OAAO,EAAE,UAAC3C,CAAC,EAAK;QAC5BoC,MAAM,CAACpC,CAAC,CAAC;MACX,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC,CACDyB,IAAI,CAAC,UAACmB,IAAI,EAAK;IACd5D,GAAG,CAACwD,IAAI,CAACI,IAAI,CAAC;IACdvC,QAAQ,CAAC,CAAC;EACZ,CAAC,CAAC,CACDwC,KAAK,CAAC,UAAC7C,CAAC,EAAK;IACZhB,GAAG,CAAC8D,KAAK,YAAAjB,MAAA,CAAY7B,CAAC,CAAC+C,OAAO,CAAE,CAAC;IACjC1C,QAAQ,CAACL,CAAC,CAAC;EACb,CAAC,CAAC;AACN;AAEA,SAAS0C,OAAOA,CAACM,EAAE,EAAEC,OAAO,EAAE;EAC5B,OAAO1D,GAAG,CAACmD,OAAO,CAAC;IACjBQ,GAAG,EAAEF,EAAE;IACPG,KAAK,EAAE,CAAC;IACRF,OAAO,EAAPA;EACF,CAAC,CAAC;AACJ;AAEA,SAASG,kBAAkBA,CAACC,IAAI,EAAElD,SAAS,EAAEE,QAAQ,EAAE;EACrD,IAAI,CAACxB,EAAE,CAACyE,UAAU,CAACD,IAAI,CAAC,EAAE;IACxB,OAAOhD,QAAQ,CAAC,IAAIuB,KAAK,CAAC,mBAAmB,GAAGyB,IAAI,CAAC,CAAC;EACxD;EACArE,GAAG,CAACwD,IAAI,CAAC,mCAAmC,GAAGa,IAAI,CAAC;;EAEpD;EACA,IAAIE,YAAY,GAAG,CAAC;EACpB,SAASjB,gBAAgBA,CAACC,KAAK,EAAE;IAC/BgB,YAAY,IAAI,CAAC;IACjBvE,GAAG,CAACwD,IAAI,CAAC,SAAS,EAAE,YAAY,GAAGD,KAAK,CAACxD,IAAI,CAAC;EAChD;EACA,SAASyE,YAAYA,CAACC,GAAG,EAAE;IACzB,IAAIA,GAAG,EAAE,OAAOpD,QAAQ,CAACoD,GAAG,CAAC;IAC7B,IAAIF,YAAY,KAAK,CAAC,EAAE;MACtB,OAAOlD,QAAQ,CAAC,IAAIuB,KAAK,CAAC,wDAAwD,CAAC,CAAC;IACtF;IACA5C,GAAG,CAACwD,IAAI,CAAC,SAAS,EAAE,sBAAsB,CAAC;IAC3CnC,QAAQ,CAAC,CAAC;EACZ;EAEAxB,EAAE,CAAC6E,gBAAgB,CAACL,IAAI,CAAC,CAACZ,IAAI,CAACC,OAAO,CAACvC,SAAS,EAAEmC,gBAAgB,CAAC,CAAC,CACjEK,EAAE,CAAC,OAAO,EAAEa,YAAY,CAAC,CACzBb,EAAE,CAAC,OAAO,EAAEa,YAAY,CAAC;AAC9B;AAEA,SAASG,QAAQA,CAACC,GAAG,EAAEC,IAAI,EAAExD,QAAQ,EAAE;EACrC,IAAMyD,IAAI,GAAG,CAAC,SAAS,CAAC,CAACjC,MAAM,CAACgC,IAAI,CAAC;EACrCD,GAAG,CAACG,IAAI,CAACC,IAAI,CAAC;IAAEC,IAAI,EAAE,OAAO;IAAEH,IAAI,EAAEA;EAAK,CAAC,CAAC;EAC5CtD,OAAO,CAAC0D,QAAQ,CAAC7D,QAAQ,CAAC;AAC5B;AAEA,SAAS8D,oBAAoBA,CAACV,GAAG,EAAErD,IAAI,EAAEgE,YAAY,EAAE;EACrD,IAAMC,gBAAgB,GAAG,iDAAiD;EAC1E,IAAIC,YAAY,GAAG,EAAE;EACrB,IAAIb,GAAG,CAACc,UAAU,KAAKC,SAAS,EAAE;IAChC;IACA;IACA;IACAF,YAAY,GAAG,mCAAmC,GAAGF,YAAY,CAACH,IAAI,GAAG,GAAG,GAAGG,YAAY,CAACrE,OAAO;IACnGuE,YAAY,IAAI,OAAO,GAAGlE,IAAI,CAACqE,OAAO,GAAG,GAAG,IAAIrE,IAAI,CAACsE,MAAM,IAAIlE,OAAO,CAACmE,QAAQ,CAACC,IAAI,CAAC,GAAG,IAAI,GAAGxE,IAAI,CAACyE,QAAQ,GAAG,QAAQ,GAAGzE,IAAI,CAAC0E,IAAI,GAAG,GAAG;IACzIR,YAAY,IAAID,gBAAgB;IAChCrF,GAAG,CAAC+F,IAAI,CAAC,oBAAoB,GAAGtB,GAAG,CAACc,UAAU,GAAG,KAAK,GAAGnE,IAAI,CAAC4E,cAAc,CAAC;IAC7EhG,GAAG,CAAC+F,IAAI,CAACT,YAAY,CAAC;IACtBtF,GAAG,CAACsB,IAAI,CAACmD,GAAG,CAACV,OAAO,CAAC;EACvB,CAAC,MAAM;IACL;IACA;IACAuB,YAAY,GAAG,yCAAyC,GAAGF,YAAY,CAACH,IAAI,GAAG,GAAG,GAAGG,YAAY,CAACrE,OAAO;IACzGuE,YAAY,IAAI,OAAO,GAAGlE,IAAI,CAACqE,OAAO,GAAG,GAAG,IAAIrE,IAAI,CAACsE,MAAM,IAAIlE,OAAO,CAACmE,QAAQ,CAACC,IAAI,CAAC,GAAG,IAAI,GAAGxE,IAAI,CAACyE,QAAQ,GAAG,QAAQ,GAAGzE,IAAI,CAAC0E,IAAI,GAAG,GAAG;IACzIR,YAAY,IAAID,gBAAgB;IAChCrF,GAAG,CAAC+F,IAAI,CAACT,YAAY,CAAC;IACtBtF,GAAG,CAAC+F,IAAI,CAAC,YAAY,GAAGtB,GAAG,CAACV,OAAO,CAAC;EACtC;AACF;;AAEA;AACA;AACA;AACA,SAASpE,OAAOA,CAACiF,GAAG,EAAEC,IAAI,EAAExD,QAAQ,EAAE;EACpC,IAAM+D,YAAY,GAAGR,GAAG,CAACQ,YAAY;EACrC,IAAMa,kBAAkB,GAAG7F,IAAI,CAAC8F,wCAAwC,CAACrB,IAAI,CAAC;EAC9E,IAAMsB,YAAY,GAAGvB,GAAG,CAACxD,IAAI,CAAC,mBAAmB,CAAC,IAAIwD,GAAG,CAACxD,IAAI,CAACgF,iBAAiB;EAChF,IAAMC,aAAa,GAAGzB,GAAG,CAACxD,IAAI,CAAC,eAAe,CAAC,IAAIwD,GAAG,CAACxD,IAAI,CAACiF,aAAa;EACzE,IAAMC,sBAAsB,GAAGH,YAAY,KAAKf,YAAY,CAACH,IAAI,IAAKkB,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,MAAO;EACvH,IAAIG,sBAAsB,EAAE;IAC1BtG,GAAG,CAACwD,IAAI,CAAC,OAAO,EAAE,2BAA2B,CAAC;IAC9C,OAAOmB,QAAQ,CAACC,GAAG,EAAEC,IAAI,EAAExD,QAAQ,CAAC;EACtC,CAAC,MAAM;IACL,IAAMkF,iBAAiB,GAAG3B,GAAG,CAACxD,IAAI,CAAC,mBAAmB,CAAC,IAAIwD,GAAG,CAACxD,IAAI,CAACmF,iBAAiB;IACrF,IAAIC,wBAAwB,GAAGD,iBAAiB,KAAKnB,YAAY,CAACH,IAAI,IAAKsB,iBAAiB,KAAK,IAAI,IAAIA,iBAAiB,KAAK,MAAO;IACtI;IACA,IAAI/E,OAAO,CAACC,GAAG,CAACgF,eAAe,EAAE;MAC/B,IAAMC,MAAM,GAAG7F,IAAI,CAACC,KAAK,CAACU,OAAO,CAACC,GAAG,CAACgF,eAAe,CAAC,CAACC,MAAM;MAC7D,IAAMC,KAAK,GAAGD,MAAM,CAACE,OAAO,CAAC,qBAAqB,CAAC;MACnD,IAAID,KAAK,GAAG,CAAC,CAAC,IAAID,MAAM,CAACG,MAAM,GAAGF,KAAK,IAAID,MAAM,CAACC,KAAK,GAAG,CAAC,CAAC,KAAK,OAAO,EAAE;QACxEH,wBAAwB,GAAG,KAAK;QAChCxG,GAAG,CAACwD,IAAI,CAAC,SAAS,EAAE,iEAAiE,CAAC;MACxF;IACF;IACA,IAAIpC,IAAI;IACR,IAAI;MACFA,IAAI,GAAGjB,UAAU,CAAC2G,QAAQ,CAAC1B,YAAY,EAAER,GAAG,CAACxD,IAAI,EAAE6E,kBAAkB,CAAC;IACxE,CAAC,CAAC,OAAOxB,GAAG,EAAE;MACZ,OAAOpD,QAAQ,CAACoD,GAAG,CAAC;IACtB;IAEArD,IAAI,CAACa,EAAE,GAAG2C,GAAG,CAACxD,IAAI,CAACa,EAAE;IACrBb,IAAI,CAACY,MAAM,GAAG4C,GAAG,CAACxD,IAAI,CAACY,MAAM;IAE7B,IAAMqC,IAAI,GAAGjD,IAAI,CAAC4E,cAAc;IAChC,IAAMhC,EAAE,GAAG5C,IAAI,CAAC2F,WAAW;IAC3B,IAAMC,aAAa,GAAGjH,IAAI,CAACY,IAAI,CAACqD,EAAE,EAAE5C,IAAI,CAAC6F,WAAW,GAAG,OAAO,CAAC;IAC/DhH,WAAW,CAAC+G,aAAa,EAAE,UAACE,KAAK,EAAK;MACpC,IAAI,CAACb,aAAa,EAAE;QAClB,IAAIa,KAAK,EAAE;UACTC,OAAO,CAACnH,GAAG,CAAC,GAAG,GAAGoF,YAAY,CAACH,IAAI,GAAG,cAAc,GAAG+B,aAAa,GAAG,qBAAqB,CAAC;UAC7FG,OAAO,CAACnH,GAAG,CAAC,uEAAuE,CAAC;UACpF,OAAOqB,QAAQ,CAAC,CAAC;QACnB;QACArB,GAAG,CAACwD,IAAI,CAAC,OAAO,EAAE,eAAe,GAAGwD,aAAa,GAAG,eAAe,CAAC;MACtE;MAEA3G,OAAO,CAAC2D,EAAE,CAAC,CAACvB,IAAI,CAAC,YAAM;QACrB,IAAM2E,QAAQ,GAAG/C,IAAI,CAACgD,UAAU,CAAC,SAAS,CAAC,IAAIhD,IAAI,CAACiD,KAAK,CAAC,SAAS,CAACT,MAAM,CAAC;QAC3E,IAAIO,QAAQ,EAAE;UACZhD,kBAAkB,CAACgD,QAAQ,EAAEpD,EAAE,EAAEuD,WAAW,CAAC;QAC/C,CAAC,MAAM;UACLtG,YAAY,CAACoD,IAAI,EAAEL,EAAE,EAAE5C,IAAI,EAAEmG,WAAW,CAAC;QAC3C;MACF,CAAC,CAAC,CAAC1D,KAAK,CAAC,UAACY,GAAG,EAAK;QAChB8C,WAAW,CAAC9C,GAAG,CAAC;MAClB,CAAC,CAAC;MAEF,SAAS8C,WAAWA,CAAC9C,GAAG,EAAE;QACxB,IAAIA,GAAG,IAAI+B,wBAAwB,EAAE;UACnCrB,oBAAoB,CAACV,GAAG,EAAErD,IAAI,EAAEgE,YAAY,CAAC;UAC7C,OAAOT,QAAQ,CAACC,GAAG,EAAEC,IAAI,EAAExD,QAAQ,CAAC;QACtC,CAAC,MAAM,IAAIoD,GAAG,EAAE;UACd,OAAOpD,QAAQ,CAACoD,GAAG,CAAC;QACtB,CAAC,MAAM;UACL0C,OAAO,CAACnH,GAAG,CAAC,GAAG,GAAGoF,YAAY,CAACH,IAAI,GAAG,cAAc,GAAG+B,aAAa,GAAG,2BAA2B,CAAC;UACnG,OAAO3F,QAAQ,CAAC,CAAC;QACnB;MACF;IACF,CAAC,CAAC;EACJ;AACF"},"metadata":{},"sourceType":"script"}