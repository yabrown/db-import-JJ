{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar debug = require('debug')('nock.recorder');\nvar querystring = require('querystring');\nvar _require = require('util'),\n  inspect = _require.inspect;\nvar common = require('./common');\nvar _require2 = require('./intercept'),\n  restoreOverriddenClientRequest = _require2.restoreOverriddenClientRequest;\nvar SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n';\nvar recordingInProgress = false;\nvar _outputs = [];\nfunction getScope(options) {\n  var _common$normalizeRequ = common.normalizeRequestOptions(options),\n    proto = _common$normalizeRequ.proto,\n    host = _common$normalizeRequ.host,\n    port = _common$normalizeRequ.port;\n  return common.normalizeOrigin(proto, host, port);\n}\nfunction getMethod(options) {\n  return options.method || 'GET';\n}\nfunction getBodyFromChunks(chunks, headers) {\n  // If we have headers and there is content-encoding it means that the body\n  // shouldn't be merged but instead persisted as an array of hex strings so\n  // that the response chunks can be mocked one by one.\n  if (headers && common.isContentEncoded(headers)) {\n    return {\n      body: chunks.map(function (chunk) {\n        return chunk.toString('hex');\n      })\n    };\n  }\n  var mergedBuffer = Buffer.concat(chunks);\n\n  // The merged buffer can be one of three things:\n  // 1. A UTF-8-representable string buffer which represents a JSON object.\n  // 2. A UTF-8-representable buffer which doesn't represent a JSON object.\n  // 3. A non-UTF-8-representable buffer which then has to be recorded as a hex string.\n  var isUtf8Representable = common.isUtf8Representable(mergedBuffer);\n  if (isUtf8Representable) {\n    var maybeStringifiedJson = mergedBuffer.toString('utf8');\n    try {\n      return {\n        isUtf8Representable: isUtf8Representable,\n        body: JSON.parse(maybeStringifiedJson)\n      };\n    } catch (err) {\n      return {\n        isUtf8Representable: isUtf8Representable,\n        body: maybeStringifiedJson\n      };\n    }\n  } else {\n    return {\n      isUtf8Representable: isUtf8Representable,\n      body: mergedBuffer.toString('hex')\n    };\n  }\n}\nfunction generateRequestAndResponseObject(_ref) {\n  var req = _ref.req,\n    bodyChunks = _ref.bodyChunks,\n    options = _ref.options,\n    res = _ref.res,\n    dataChunks = _ref.dataChunks,\n    reqheaders = _ref.reqheaders;\n  var _getBodyFromChunks = getBodyFromChunks(dataChunks, res.headers),\n    body = _getBodyFromChunks.body,\n    isUtf8Representable = _getBodyFromChunks.isUtf8Representable;\n  options.path = req.path;\n  return {\n    scope: getScope(options),\n    method: getMethod(options),\n    path: options.path,\n    // Is it deliberate that `getBodyFromChunks()` is called a second time?\n    body: getBodyFromChunks(bodyChunks).body,\n    status: res.statusCode,\n    response: body,\n    rawHeaders: res.rawHeaders,\n    reqheaders: reqheaders || undefined,\n    // When content-encoding is enabled, isUtf8Representable is `undefined`,\n    // so we explicitly check for `false`.\n    responseIsBinary: isUtf8Representable === false\n  };\n}\nfunction generateRequestAndResponse(_ref2) {\n  var req = _ref2.req,\n    bodyChunks = _ref2.bodyChunks,\n    options = _ref2.options,\n    res = _ref2.res,\n    dataChunks = _ref2.dataChunks,\n    reqheaders = _ref2.reqheaders;\n  var requestBody = getBodyFromChunks(bodyChunks).body;\n  var responseBody = getBodyFromChunks(dataChunks, res.headers).body;\n\n  // Remove any query params from options.path so they can be added in the query() function\n  var path = options.path;\n  var queryIndex = req.path.indexOf('?');\n  var queryObj = {};\n  if (queryIndex !== -1) {\n    // Remove the query from the path\n    path = path.substring(0, queryIndex);\n    var queryStr = req.path.slice(queryIndex + 1);\n    queryObj = querystring.parse(queryStr);\n  }\n\n  // Escape any single quotes in the path as the output uses them\n  path = path.replace(/'/g, \"\\\\'\");\n\n  // Always encode the query parameters when recording.\n  var encodedQueryObj = {};\n  for (var key in queryObj) {\n    var formattedPair = common.formatQueryValue(key, queryObj[key], common.percentEncode);\n    encodedQueryObj[formattedPair[0]] = formattedPair[1];\n  }\n  var lines = [];\n\n  // We want a leading newline.\n  lines.push('');\n  var scope = getScope(options);\n  lines.push(\"nock('\".concat(scope, \"', {\\\"encodedQueryParams\\\":true})\"));\n  var methodName = getMethod(options).toLowerCase();\n  if (requestBody) {\n    lines.push(\"  .\".concat(methodName, \"('\").concat(path, \"', \").concat(JSON.stringify(requestBody), \")\"));\n  } else {\n    lines.push(\"  .\".concat(methodName, \"('\").concat(path, \"')\"));\n  }\n  Object.entries(reqheaders || {}).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      fieldName = _ref4[0],\n      fieldValue = _ref4[1];\n    var safeName = JSON.stringify(fieldName);\n    var safeValue = JSON.stringify(fieldValue);\n    lines.push(\"  .matchHeader(\".concat(safeName, \", \").concat(safeValue, \")\"));\n  });\n  if (queryIndex !== -1) {\n    lines.push(\"  .query(\".concat(JSON.stringify(encodedQueryObj), \")\"));\n  }\n  var statusCode = res.statusCode.toString();\n  var stringifiedResponseBody = JSON.stringify(responseBody);\n  var headers = inspect(res.rawHeaders);\n  lines.push(\"  .reply(\".concat(statusCode, \", \").concat(stringifiedResponseBody, \", \").concat(headers, \");\"));\n  return lines.join('\\n');\n}\n\n//  This module variable is used to identify a unique recording ID in order to skip\n//  spurious requests that sometimes happen. This problem has been, so far,\n//  exclusively detected in nock's unit testing where 'checks if callback is specified'\n//  interferes with other tests as its t.end() is invoked without waiting for request\n//  to finish (which is the point of the test).\nvar currentRecordingId = 0;\nvar defaultRecordOptions = {\n  dont_print: false,\n  enable_reqheaders_recording: false,\n  logging: console.log,\n  // eslint-disable-line no-console\n  output_objects: false,\n  use_separator: true\n};\nfunction record(recOptions) {\n  //  Trying to start recording with recording already in progress implies an error\n  //  in the recording configuration (double recording makes no sense and used to lead\n  //  to duplicates in output)\n  if (recordingInProgress) {\n    throw new Error('Nock recording already in progress');\n  }\n  recordingInProgress = true;\n\n  // Set the new current recording ID and capture its value in this instance of record().\n  currentRecordingId = currentRecordingId + 1;\n  var thisRecordingId = currentRecordingId;\n\n  // Originally the parameter was a dont_print boolean flag.\n  // To keep the existing code compatible we take that case into account.\n  if (typeof recOptions === 'boolean') {\n    recOptions = {\n      dont_print: recOptions\n    };\n  }\n  recOptions = _objectSpread(_objectSpread({}, defaultRecordOptions), recOptions);\n  debug('start recording', thisRecordingId, recOptions);\n  var _recOptions = recOptions,\n    dontPrint = _recOptions.dont_print,\n    enableReqHeadersRecording = _recOptions.enable_reqheaders_recording,\n    logging = _recOptions.logging,\n    outputObjects = _recOptions.output_objects,\n    useSeparator = _recOptions.use_separator;\n  debug(thisRecordingId, 'restoring overridden requests before new overrides');\n  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)\n  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)\n  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct\n  //    behavior in the face of other modules also overriding ClientRequest.\n  common.restoreOverriddenRequests();\n  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)\n  restoreOverriddenClientRequest();\n\n  //  We override the requests so that we can save information on them before executing.\n  common.overrideRequests(function (proto, overriddenRequest, rawArgs) {\n    var _common$normalizeClie = common.normalizeClientRequestArgs.apply(common, _toConsumableArray(rawArgs)),\n      options = _common$normalizeClie.options,\n      callback = _common$normalizeClie.callback;\n    var bodyChunks = [];\n\n    // Node 0.11 https.request calls http.request -- don't want to record things\n    // twice.\n    /* istanbul ignore if */\n    if (options._recording) {\n      return overriddenRequest(options, callback);\n    }\n    options._recording = true;\n    var req = overriddenRequest(options, function (res) {\n      debug(thisRecordingId, 'intercepting', proto, 'request to record');\n\n      //  We put our 'end' listener to the front of the listener array.\n      res.once('end', function () {\n        debug(thisRecordingId, proto, 'intercepted request ended');\n        var reqheaders;\n        // Ignore request headers completely unless it was explicitly enabled by the user (see README)\n        if (enableReqHeadersRecording) {\n          // We never record user-agent headers as they are worse than useless -\n          // they actually make testing more difficult without providing any benefit (see README)\n          reqheaders = req.getHeaders();\n          common.deleteHeadersField(reqheaders, 'user-agent');\n        }\n        var generateFn = outputObjects ? generateRequestAndResponseObject : generateRequestAndResponse;\n        var out = generateFn({\n          req: req,\n          bodyChunks: bodyChunks,\n          options: options,\n          res: res,\n          dataChunks: dataChunks,\n          reqheaders: reqheaders\n        });\n        debug('out:', out);\n\n        //  Check that the request was made during the current recording.\n        //  If it hasn't then skip it. There is no other simple way to handle\n        //  this as it depends on the timing of requests and responses. Throwing\n        //  will make some recordings/unit tests fail randomly depending on how\n        //  fast/slow the response arrived.\n        //  If you are seeing this error then you need to make sure that all\n        //  the requests made during a single recording session finish before\n        //  ending the same recording session.\n        if (thisRecordingId !== currentRecordingId) {\n          debug('skipping recording of an out-of-order request', out);\n          return;\n        }\n        _outputs.push(out);\n        if (!dontPrint) {\n          if (useSeparator) {\n            if (typeof out !== 'string') {\n              out = JSON.stringify(out, null, 2);\n            }\n            logging(SEPARATOR + out + SEPARATOR);\n          } else {\n            logging(out);\n          }\n        }\n      });\n      var encoding;\n      // We need to be aware of changes to the stream's encoding so that we\n      // don't accidentally mangle the data.\n      var setEncoding = res.setEncoding;\n      res.setEncoding = function (newEncoding) {\n        encoding = newEncoding;\n        return setEncoding.apply(this, arguments);\n      };\n      var dataChunks = [];\n      // Replace res.push with our own implementation that stores chunks\n      var origResPush = res.push;\n      res.push = function (data) {\n        if (data) {\n          if (encoding) {\n            data = Buffer.from(data, encoding);\n          }\n          dataChunks.push(data);\n        }\n        return origResPush.call(res, data);\n      };\n      if (callback) {\n        callback(res, options, callback);\n      }\n      debug('finished setting up intercepting');\n\n      // We override both the http and the https modules; when we are\n      // serializing the request, we need to know which was called.\n      // By stuffing the state, we can make sure that nock records\n      // the intended protocol.\n      if (proto === 'https') {\n        options.proto = 'https';\n      }\n    });\n    var recordChunk = function recordChunk(chunk, encoding) {\n      debug(thisRecordingId, 'new', proto, 'body chunk');\n      if (!Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk, encoding);\n      }\n      bodyChunks.push(chunk);\n    };\n    var oldWrite = req.write;\n    req.write = function (chunk, encoding) {\n      if (typeof chunk !== 'undefined') {\n        recordChunk(chunk, encoding);\n        oldWrite.apply(req, arguments);\n      } else {\n        throw new Error('Data was undefined.');\n      }\n    };\n\n    // Starting in Node 8, `OutgoingMessage.end()` directly calls an internal\n    // `write_` function instead of proxying to the public\n    // `OutgoingMessage.write()` method, so we have to wrap `end` too.\n    var oldEnd = req.end;\n    req.end = function (chunk, encoding, callback) {\n      debug('req.end');\n      if (typeof chunk === 'function') {\n        callback = chunk;\n        chunk = null;\n      } else if (typeof encoding === 'function') {\n        callback = encoding;\n        encoding = null;\n      }\n      if (chunk) {\n        recordChunk(chunk, encoding);\n      }\n      oldEnd.call(req, chunk, encoding, callback);\n    };\n    return req;\n  });\n}\n\n// Restore *all* the overridden http/https modules' properties.\nfunction restore() {\n  debug(currentRecordingId, 'restoring all the overridden http/https properties');\n  common.restoreOverriddenRequests();\n  restoreOverriddenClientRequest();\n  recordingInProgress = false;\n}\nfunction clear() {\n  _outputs = [];\n}\nmodule.exports = {\n  record: record,\n  outputs: function outputs() {\n    return _outputs;\n  },\n  restore: restore,\n  clear: clear\n};","map":{"version":3,"names":["_toConsumableArray","require","default","_objectSpread","_slicedToArray","debug","querystring","_require","inspect","common","_require2","restoreOverriddenClientRequest","SEPARATOR","recordingInProgress","outputs","getScope","options","_common$normalizeRequ","normalizeRequestOptions","proto","host","port","normalizeOrigin","getMethod","method","getBodyFromChunks","chunks","headers","isContentEncoded","body","map","chunk","toString","mergedBuffer","Buffer","concat","isUtf8Representable","maybeStringifiedJson","JSON","parse","err","generateRequestAndResponseObject","_ref","req","bodyChunks","res","dataChunks","reqheaders","_getBodyFromChunks","path","scope","status","statusCode","response","rawHeaders","undefined","responseIsBinary","generateRequestAndResponse","_ref2","requestBody","responseBody","queryIndex","indexOf","queryObj","substring","queryStr","slice","replace","encodedQueryObj","key","formattedPair","formatQueryValue","percentEncode","lines","push","methodName","toLowerCase","stringify","Object","entries","forEach","_ref3","_ref4","fieldName","fieldValue","safeName","safeValue","stringifiedResponseBody","join","currentRecordingId","defaultRecordOptions","dont_print","enable_reqheaders_recording","logging","console","log","output_objects","use_separator","record","recOptions","Error","thisRecordingId","_recOptions","dontPrint","enableReqHeadersRecording","outputObjects","useSeparator","restoreOverriddenRequests","overrideRequests","overriddenRequest","rawArgs","_common$normalizeClie","normalizeClientRequestArgs","apply","callback","_recording","once","getHeaders","deleteHeadersField","generateFn","out","encoding","setEncoding","newEncoding","arguments","origResPush","data","from","call","recordChunk","isBuffer","oldWrite","write","oldEnd","end","restore","clear","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/nock/lib/recorder.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')('nock.recorder')\nconst querystring = require('querystring')\nconst { inspect } = require('util')\n\nconst common = require('./common')\nconst { restoreOverriddenClientRequest } = require('./intercept')\n\nconst SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n'\nlet recordingInProgress = false\nlet outputs = []\n\nfunction getScope(options) {\n  const { proto, host, port } = common.normalizeRequestOptions(options)\n  return common.normalizeOrigin(proto, host, port)\n}\n\nfunction getMethod(options) {\n  return options.method || 'GET'\n}\n\nfunction getBodyFromChunks(chunks, headers) {\n  // If we have headers and there is content-encoding it means that the body\n  // shouldn't be merged but instead persisted as an array of hex strings so\n  // that the response chunks can be mocked one by one.\n  if (headers && common.isContentEncoded(headers)) {\n    return {\n      body: chunks.map(chunk => chunk.toString('hex')),\n    }\n  }\n\n  const mergedBuffer = Buffer.concat(chunks)\n\n  // The merged buffer can be one of three things:\n  // 1. A UTF-8-representable string buffer which represents a JSON object.\n  // 2. A UTF-8-representable buffer which doesn't represent a JSON object.\n  // 3. A non-UTF-8-representable buffer which then has to be recorded as a hex string.\n  const isUtf8Representable = common.isUtf8Representable(mergedBuffer)\n  if (isUtf8Representable) {\n    const maybeStringifiedJson = mergedBuffer.toString('utf8')\n    try {\n      return {\n        isUtf8Representable,\n        body: JSON.parse(maybeStringifiedJson),\n      }\n    } catch (err) {\n      return {\n        isUtf8Representable,\n        body: maybeStringifiedJson,\n      }\n    }\n  } else {\n    return {\n      isUtf8Representable,\n      body: mergedBuffer.toString('hex'),\n    }\n  }\n}\n\nfunction generateRequestAndResponseObject({\n  req,\n  bodyChunks,\n  options,\n  res,\n  dataChunks,\n  reqheaders,\n}) {\n  const { body, isUtf8Representable } = getBodyFromChunks(\n    dataChunks,\n    res.headers\n  )\n  options.path = req.path\n\n  return {\n    scope: getScope(options),\n    method: getMethod(options),\n    path: options.path,\n    // Is it deliberate that `getBodyFromChunks()` is called a second time?\n    body: getBodyFromChunks(bodyChunks).body,\n    status: res.statusCode,\n    response: body,\n    rawHeaders: res.rawHeaders,\n    reqheaders: reqheaders || undefined,\n    // When content-encoding is enabled, isUtf8Representable is `undefined`,\n    // so we explicitly check for `false`.\n    responseIsBinary: isUtf8Representable === false,\n  }\n}\n\nfunction generateRequestAndResponse({\n  req,\n  bodyChunks,\n  options,\n  res,\n  dataChunks,\n  reqheaders,\n}) {\n  const requestBody = getBodyFromChunks(bodyChunks).body\n  const responseBody = getBodyFromChunks(dataChunks, res.headers).body\n\n  // Remove any query params from options.path so they can be added in the query() function\n  let { path } = options\n  const queryIndex = req.path.indexOf('?')\n  let queryObj = {}\n  if (queryIndex !== -1) {\n    // Remove the query from the path\n    path = path.substring(0, queryIndex)\n\n    const queryStr = req.path.slice(queryIndex + 1)\n    queryObj = querystring.parse(queryStr)\n  }\n\n  // Escape any single quotes in the path as the output uses them\n  path = path.replace(/'/g, `\\\\'`)\n\n  // Always encode the query parameters when recording.\n  const encodedQueryObj = {}\n  for (const key in queryObj) {\n    const formattedPair = common.formatQueryValue(\n      key,\n      queryObj[key],\n      common.percentEncode\n    )\n    encodedQueryObj[formattedPair[0]] = formattedPair[1]\n  }\n\n  const lines = []\n\n  // We want a leading newline.\n  lines.push('')\n\n  const scope = getScope(options)\n  lines.push(`nock('${scope}', {\"encodedQueryParams\":true})`)\n\n  const methodName = getMethod(options).toLowerCase()\n  if (requestBody) {\n    lines.push(`  .${methodName}('${path}', ${JSON.stringify(requestBody)})`)\n  } else {\n    lines.push(`  .${methodName}('${path}')`)\n  }\n\n  Object.entries(reqheaders || {}).forEach(([fieldName, fieldValue]) => {\n    const safeName = JSON.stringify(fieldName)\n    const safeValue = JSON.stringify(fieldValue)\n    lines.push(`  .matchHeader(${safeName}, ${safeValue})`)\n  })\n\n  if (queryIndex !== -1) {\n    lines.push(`  .query(${JSON.stringify(encodedQueryObj)})`)\n  }\n\n  const statusCode = res.statusCode.toString()\n  const stringifiedResponseBody = JSON.stringify(responseBody)\n  const headers = inspect(res.rawHeaders)\n  lines.push(`  .reply(${statusCode}, ${stringifiedResponseBody}, ${headers});`)\n\n  return lines.join('\\n')\n}\n\n//  This module variable is used to identify a unique recording ID in order to skip\n//  spurious requests that sometimes happen. This problem has been, so far,\n//  exclusively detected in nock's unit testing where 'checks if callback is specified'\n//  interferes with other tests as its t.end() is invoked without waiting for request\n//  to finish (which is the point of the test).\nlet currentRecordingId = 0\n\nconst defaultRecordOptions = {\n  dont_print: false,\n  enable_reqheaders_recording: false,\n  logging: console.log, // eslint-disable-line no-console\n  output_objects: false,\n  use_separator: true,\n}\n\nfunction record(recOptions) {\n  //  Trying to start recording with recording already in progress implies an error\n  //  in the recording configuration (double recording makes no sense and used to lead\n  //  to duplicates in output)\n  if (recordingInProgress) {\n    throw new Error('Nock recording already in progress')\n  }\n\n  recordingInProgress = true\n\n  // Set the new current recording ID and capture its value in this instance of record().\n  currentRecordingId = currentRecordingId + 1\n  const thisRecordingId = currentRecordingId\n\n  // Originally the parameter was a dont_print boolean flag.\n  // To keep the existing code compatible we take that case into account.\n  if (typeof recOptions === 'boolean') {\n    recOptions = { dont_print: recOptions }\n  }\n\n  recOptions = { ...defaultRecordOptions, ...recOptions }\n\n  debug('start recording', thisRecordingId, recOptions)\n\n  const {\n    dont_print: dontPrint,\n    enable_reqheaders_recording: enableReqHeadersRecording,\n    logging,\n    output_objects: outputObjects,\n    use_separator: useSeparator,\n  } = recOptions\n\n  debug(thisRecordingId, 'restoring overridden requests before new overrides')\n  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)\n  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)\n  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct\n  //    behavior in the face of other modules also overriding ClientRequest.\n  common.restoreOverriddenRequests()\n  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)\n  restoreOverriddenClientRequest()\n\n  //  We override the requests so that we can save information on them before executing.\n  common.overrideRequests(function (proto, overriddenRequest, rawArgs) {\n    const { options, callback } = common.normalizeClientRequestArgs(...rawArgs)\n    const bodyChunks = []\n\n    // Node 0.11 https.request calls http.request -- don't want to record things\n    // twice.\n    /* istanbul ignore if */\n    if (options._recording) {\n      return overriddenRequest(options, callback)\n    }\n    options._recording = true\n\n    const req = overriddenRequest(options, function (res) {\n      debug(thisRecordingId, 'intercepting', proto, 'request to record')\n\n      //  We put our 'end' listener to the front of the listener array.\n      res.once('end', function () {\n        debug(thisRecordingId, proto, 'intercepted request ended')\n\n        let reqheaders\n        // Ignore request headers completely unless it was explicitly enabled by the user (see README)\n        if (enableReqHeadersRecording) {\n          // We never record user-agent headers as they are worse than useless -\n          // they actually make testing more difficult without providing any benefit (see README)\n          reqheaders = req.getHeaders()\n          common.deleteHeadersField(reqheaders, 'user-agent')\n        }\n\n        const generateFn = outputObjects\n          ? generateRequestAndResponseObject\n          : generateRequestAndResponse\n        let out = generateFn({\n          req,\n          bodyChunks,\n          options,\n          res,\n          dataChunks,\n          reqheaders,\n        })\n\n        debug('out:', out)\n\n        //  Check that the request was made during the current recording.\n        //  If it hasn't then skip it. There is no other simple way to handle\n        //  this as it depends on the timing of requests and responses. Throwing\n        //  will make some recordings/unit tests fail randomly depending on how\n        //  fast/slow the response arrived.\n        //  If you are seeing this error then you need to make sure that all\n        //  the requests made during a single recording session finish before\n        //  ending the same recording session.\n        if (thisRecordingId !== currentRecordingId) {\n          debug('skipping recording of an out-of-order request', out)\n          return\n        }\n\n        outputs.push(out)\n\n        if (!dontPrint) {\n          if (useSeparator) {\n            if (typeof out !== 'string') {\n              out = JSON.stringify(out, null, 2)\n            }\n            logging(SEPARATOR + out + SEPARATOR)\n          } else {\n            logging(out)\n          }\n        }\n      })\n\n      let encoding\n      // We need to be aware of changes to the stream's encoding so that we\n      // don't accidentally mangle the data.\n      const { setEncoding } = res\n      res.setEncoding = function (newEncoding) {\n        encoding = newEncoding\n        return setEncoding.apply(this, arguments)\n      }\n\n      const dataChunks = []\n      // Replace res.push with our own implementation that stores chunks\n      const origResPush = res.push\n      res.push = function (data) {\n        if (data) {\n          if (encoding) {\n            data = Buffer.from(data, encoding)\n          }\n          dataChunks.push(data)\n        }\n\n        return origResPush.call(res, data)\n      }\n\n      if (callback) {\n        callback(res, options, callback)\n      }\n\n      debug('finished setting up intercepting')\n\n      // We override both the http and the https modules; when we are\n      // serializing the request, we need to know which was called.\n      // By stuffing the state, we can make sure that nock records\n      // the intended protocol.\n      if (proto === 'https') {\n        options.proto = 'https'\n      }\n    })\n\n    const recordChunk = (chunk, encoding) => {\n      debug(thisRecordingId, 'new', proto, 'body chunk')\n      if (!Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk, encoding)\n      }\n      bodyChunks.push(chunk)\n    }\n\n    const oldWrite = req.write\n    req.write = function (chunk, encoding) {\n      if (typeof chunk !== 'undefined') {\n        recordChunk(chunk, encoding)\n        oldWrite.apply(req, arguments)\n      } else {\n        throw new Error('Data was undefined.')\n      }\n    }\n\n    // Starting in Node 8, `OutgoingMessage.end()` directly calls an internal\n    // `write_` function instead of proxying to the public\n    // `OutgoingMessage.write()` method, so we have to wrap `end` too.\n    const oldEnd = req.end\n    req.end = function (chunk, encoding, callback) {\n      debug('req.end')\n      if (typeof chunk === 'function') {\n        callback = chunk\n        chunk = null\n      } else if (typeof encoding === 'function') {\n        callback = encoding\n        encoding = null\n      }\n\n      if (chunk) {\n        recordChunk(chunk, encoding)\n      }\n      oldEnd.call(req, chunk, encoding, callback)\n    }\n\n    return req\n  })\n}\n\n// Restore *all* the overridden http/https modules' properties.\nfunction restore() {\n  debug(\n    currentRecordingId,\n    'restoring all the overridden http/https properties'\n  )\n\n  common.restoreOverriddenRequests()\n  restoreOverriddenClientRequest()\n  recordingInProgress = false\n}\n\nfunction clear() {\n  outputs = []\n}\n\nmodule.exports = {\n  record,\n  outputs: () => outputs,\n  restore,\n  clear,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}