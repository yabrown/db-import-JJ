{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar Minipass = require('minipass');\nvar MinipassPipeline = require('minipass-pipeline');\nvar fetch = require('minipass-fetch');\nvar promiseRetry = require('promise-retry');\nvar ssri = require('ssri');\nvar getAgent = require('./agent.js');\nvar pkg = require('../package.json');\nvar USER_AGENT = \"\".concat(pkg.name, \"/\").concat(pkg.version, \" (+https://npm.im/\").concat(pkg.name, \")\");\nvar RETRY_ERRORS = ['ECONNRESET',\n// remote socket closed on us\n'ECONNREFUSED',\n// remote host refused to open connection\n'EADDRINUSE',\n// failed to bind to a local port (proxy?)\n'ETIMEDOUT',\n// someone in the transaction is WAY TOO SLOW\n'ERR_SOCKET_TIMEOUT' // same as above, but this one comes from agentkeepalive\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\n\nvar RETRY_TYPES = ['request-timeout'];\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nvar remoteFetch = function remoteFetch(request, options) {\n  var agent = getAgent(request.url, options);\n  if (!request.headers.has('connection')) request.headers.set('connection', agent ? 'keep-alive' : 'close');\n  if (!request.headers.has('user-agent')) request.headers.set('user-agent', USER_AGENT);\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  var _opts = _objectSpread(_objectSpread({}, options), {}, {\n    agent: agent,\n    redirect: 'manual'\n  });\n  return promiseRetry( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(retryHandler, attemptNum) {\n      var req, res, integrityStream, isStream, isRetriable, code, isRetryError;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            req = new fetch.Request(request, _opts);\n            _context.prev = 1;\n            _context.next = 4;\n            return fetch(req, _opts);\n          case 4:\n            res = _context.sent;\n            if (_opts.integrity && res.status === 200) {\n              // we got a 200 response and the user has specified an expected\n              // integrity value, so wrap the response in an ssri stream to verify it\n              integrityStream = ssri.integrityStream({\n                integrity: _opts.integrity\n              });\n              res = new fetch.Response(new MinipassPipeline(res.body, integrityStream), res);\n            }\n            res.headers.set('x-fetch-attempts', attemptNum);\n\n            // do not retry POST requests, or requests with a streaming body\n            // do retry requests with a 408, 420, 429 or 500+ status in the response\n            isStream = Minipass.isStream(req.body);\n            isRetriable = req.method !== 'POST' && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);\n            if (!isRetriable) {\n              _context.next = 12;\n              break;\n            }\n            if (typeof options.onRetry === 'function') options.onRetry(res);\n            return _context.abrupt(\"return\", retryHandler(res));\n          case 12:\n            return _context.abrupt(\"return\", res);\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](1);\n            code = _context.t0.code === 'EPROMISERETRY' ? _context.t0.retried.code : _context.t0.code; // err.retried will be the thing that was thrown from above\n            // if it's a response, we just got a bad status code and we\n            // can re-throw to allow the retry\n            isRetryError = _context.t0.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(_context.t0.type);\n            if (!(req.method === 'POST' || isRetryError)) {\n              _context.next = 21;\n              break;\n            }\n            throw _context.t0;\n          case 21:\n            if (typeof options.onRetry === 'function') options.onRetry(_context.t0);\n            return _context.abrupt(\"return\", retryHandler(_context.t0));\n          case 23:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 15]]);\n    }));\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }(), options.retry).catch(function (err) {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') return err;\n    throw err;\n  });\n};\nmodule.exports = remoteFetch;","map":{"version":3,"names":["Minipass","require","MinipassPipeline","fetch","promiseRetry","ssri","getAgent","pkg","USER_AGENT","concat","name","version","RETRY_ERRORS","RETRY_TYPES","remoteFetch","request","options","agent","url","headers","has","set","_opts","_objectSpread","redirect","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","retryHandler","attemptNum","req","res","integrityStream","isStream","isRetriable","code","isRetryError","wrap","_callee$","_context","prev","next","Request","sent","integrity","status","Response","body","method","includes","onRetry","abrupt","t0","retried","type","stop","_x","_x2","apply","arguments","retry","catch","err","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/make-fetch-happen/lib/remote.js"],"sourcesContent":["const Minipass = require('minipass')\nconst MinipassPipeline = require('minipass-pipeline')\nconst fetch = require('minipass-fetch')\nconst promiseRetry = require('promise-retry')\nconst ssri = require('ssri')\n\nconst getAgent = require('./agent.js')\nconst pkg = require('../package.json')\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n  'ERR_SOCKET_TIMEOUT', // same as above, but this one comes from agentkeepalive\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout',\n]\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options)\n  if (!request.headers.has('connection'))\n    request.headers.set('connection', agent ? 'keep-alive' : 'close')\n\n  if (!request.headers.has('user-agent'))\n    request.headers.set('user-agent', USER_AGENT)\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual',\n  }\n\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts)\n    try {\n      let res = await fetch(req, _opts)\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({ integrity: _opts.integrity })\n        res = new fetch.Response(new MinipassPipeline(res.body, integrityStream), res)\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum)\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body)\n      const isRetriable = req.method !== 'POST' &&\n          !isStream &&\n          ([408, 420, 429].includes(res.status) || res.status >= 500)\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function')\n          options.onRetry(res)\n\n        return retryHandler(res)\n      }\n\n      return res\n    } catch (err) {\n      const code = (err.code === 'EPROMISERETRY')\n        ? err.retried.code\n        : err.code\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response ||\n        (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type))\n\n      if (req.method === 'POST' || isRetryError)\n        throw err\n\n      if (typeof options.onRetry === 'function')\n        options.onRetry(err)\n\n      return retryHandler(err)\n    }\n  }, options.retry).catch((err) => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system')\n      return err\n\n    throw err\n  })\n}\n\nmodule.exports = remoteFetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}