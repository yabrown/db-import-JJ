{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __extends } from '../../_virtual/_tslib.js';\nimport { CredentialEntity } from './CredentialEntity.js';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.js';\nimport { TimeUtils } from '../../utils/TimeUtils.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { AuthToken } from '../../account/AuthToken.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * ACCESS_TOKEN Credential Type\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\nvar AccessTokenEntity = /** @class */function (_super) {\n  __extends(AccessTokenEntity, _super);\n  function AccessTokenEntity() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Create AccessTokenEntity\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param accessToken\r\n   * @param clientId\r\n   * @param tenantId\r\n   * @param scopes\r\n   * @param expiresOn\r\n   * @param extExpiresOn\r\n   */\n  AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n    var _a, _b;\n    var atEntity = new AccessTokenEntity();\n    atEntity.homeAccountId = homeAccountId;\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n    atEntity.secret = accessToken;\n    var currentTime = TimeUtils.nowSeconds();\n    atEntity.cachedAt = currentTime.toString();\n    /*\r\n     * Token expiry time.\r\n     * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n     */\n    atEntity.expiresOn = expiresOn.toString();\n    atEntity.extendedExpiresOn = extExpiresOn.toString();\n    if (refreshOn) {\n      atEntity.refreshOn = refreshOn.toString();\n    }\n    atEntity.environment = environment;\n    atEntity.clientId = clientId;\n    atEntity.realm = tenantId;\n    atEntity.target = scopes;\n    atEntity.userAssertionHash = userAssertionHash;\n    atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\n    if (requestedClaims) {\n      atEntity.requestedClaims = requestedClaims;\n      atEntity.requestedClaimsHash = requestedClaimsHash;\n    }\n    /*\r\n     * Create Access Token With Auth Scheme instead of regular access token\r\n     * Cast to lower to handle \"bearer\" from ADFS\r\n     */\n    if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {\n      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n      switch (atEntity.tokenType) {\n        case AuthenticationScheme.POP:\n          // Make sure keyId is present and add it to credential\n          var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\n          if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {\n            throw ClientAuthError.createTokenClaimsRequiredError();\n          }\n          atEntity.keyId = tokenClaims.cnf.kid;\n          break;\n        case AuthenticationScheme.SSH:\n          atEntity.keyId = keyId;\n      }\n    }\n    return atEntity;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n  AccessTokenEntity.isAccessTokenEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n  };\n  return AccessTokenEntity;\n}(CredentialEntity);\nexport { AccessTokenEntity };","map":{"version":3,"names":["AccessTokenEntity","_super","__extends","createAccessTokenEntity","homeAccountId","environment","accessToken","clientId","tenantId","scopes","expiresOn","extExpiresOn","cryptoUtils","refreshOn","tokenType","userAssertionHash","keyId","requestedClaims","requestedClaimsHash","atEntity","credentialType","CredentialType","ACCESS_TOKEN","secret","currentTime","TimeUtils","nowSeconds","cachedAt","toString","extendedExpiresOn","realm","target","StringUtils","isEmpty","AuthenticationScheme","BEARER","_a","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","POP","tokenClaims","AuthToken","extractTokenClaims","_b","cnf","kid","ClientAuthError","createTokenClaimsRequiredError","SSH","isAccessTokenEntity","entity","hasOwnProperty","CredentialEntity"],"sources":["../../../src/cache/entities/AccessTokenEntity.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CredentialEntity } from \"./CredentialEntity\";\nimport { CredentialType, AuthenticationScheme } from \"../../utils/Constants\";\nimport { TimeUtils } from \"../../utils/TimeUtils\";\nimport { StringUtils } from \"../../utils/StringUtils\";\nimport { ICrypto } from \"../../crypto/ICrypto\";\nimport { TokenClaims } from \"../../account/TokenClaims\";\nimport { AuthToken } from \"../../account/AuthToken\";\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\n\n/**\n * ACCESS_TOKEN Credential Type\n *\n * Key:Value Schema:\n *\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      cachedAt: Absolute device time when entry was created in the cache.\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\n *      keyId: used for POP and SSH tokenTypes\n *      tokenType: Type of the token issued. Usually \"Bearer\"\n * }\n */\nexport class AccessTokenEntity extends CredentialEntity {\n    realm: string;\n    target: string;\n    cachedAt: string;\n    expiresOn: string;\n    extendedExpiresOn?: string;\n    refreshOn?: string;\n    keyId?: string; // for POP and SSH tokenTypes\n    tokenType?: AuthenticationScheme;\n    requestedClaims?: string;\n    requestedClaimsHash?: string;\n\n    /**\n     * Create AccessTokenEntity\n     * @param homeAccountId\n     * @param environment\n     * @param accessToken\n     * @param clientId\n     * @param tenantId\n     * @param scopes\n     * @param expiresOn\n     * @param extExpiresOn\n     */\n    static createAccessTokenEntity(\n        homeAccountId: string,\n        environment: string,\n        accessToken: string,\n        clientId: string,\n        tenantId: string,\n        scopes: string,\n        expiresOn: number,\n        extExpiresOn: number,\n        cryptoUtils: ICrypto,\n        refreshOn?: number,\n        tokenType?: AuthenticationScheme,\n        userAssertionHash?:string,\n        keyId?: string,\n        requestedClaims?: string,\n        requestedClaimsHash?: string\n    ): AccessTokenEntity {\n        const atEntity: AccessTokenEntity = new AccessTokenEntity();\n\n        atEntity.homeAccountId = homeAccountId;\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n        atEntity.secret = accessToken;\n\n        const currentTime = TimeUtils.nowSeconds();\n        atEntity.cachedAt = currentTime.toString();\n\n        /*\n         * Token expiry time.\n         * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\n         */\n        atEntity.expiresOn = expiresOn.toString();\n        atEntity.extendedExpiresOn = extExpiresOn.toString();\n        if (refreshOn) {\n            atEntity.refreshOn = refreshOn.toString();\n        }\n\n        atEntity.environment = environment;\n        atEntity.clientId = clientId;\n        atEntity.realm = tenantId;\n        atEntity.target = scopes;\n        atEntity.userAssertionHash = userAssertionHash;\n\n        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\n\n        if (requestedClaims) {\n            atEntity.requestedClaims = requestedClaims;\n            atEntity.requestedClaimsHash = requestedClaimsHash;\n        }\n\n        /*\n         * Create Access Token With Auth Scheme instead of regular access token\n         * Cast to lower to handle \"bearer\" from ADFS\n         */\n        if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {\n            atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n            switch (atEntity.tokenType) {\n                case AuthenticationScheme.POP:\n                    // Make sure keyId is present and add it to credential\n                    const tokenClaims: TokenClaims | null = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\n                    if (!tokenClaims?.cnf?.kid) {\n                        throw ClientAuthError.createTokenClaimsRequiredError();\n                    }\n                    atEntity.keyId = tokenClaims.cnf.kid;\n                    break;\n                case AuthenticationScheme.SSH:\n                    atEntity.keyId = keyId;\n            }\n        }\n\n        return atEntity;\n    }\n\n    /**\n     * Validates an entity: checks for all expected params\n     * @param entity\n     */\n    static isAccessTokenEntity(entity: object): boolean {\n\n        if (!entity) {\n            return false;\n        }\n\n        return (\n            entity.hasOwnProperty(\"homeAccountId\") &&\n            entity.hasOwnProperty(\"environment\") &&\n            entity.hasOwnProperty(\"credentialType\") &&\n            entity.hasOwnProperty(\"realm\") &&\n            entity.hasOwnProperty(\"clientId\") &&\n            entity.hasOwnProperty(\"secret\") &&\n            entity.hasOwnProperty(\"target\") &&\n            (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME)\n        );\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}