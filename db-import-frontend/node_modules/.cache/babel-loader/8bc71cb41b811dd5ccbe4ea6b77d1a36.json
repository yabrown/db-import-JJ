{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { AuthorityType } from './AuthorityType.js';\nimport { isOpenIdConfigResponse } from './OpenIdConfigResponse.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { Constants, AuthorityMetadataSource, RegionDiscoveryOutcomes } from '../utils/Constants.js';\nimport { EndpointMetadata, InstanceDiscoveryMetadata } from './AuthorityMetadata.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ProtocolMode } from './ProtocolMode.js';\nimport { AuthorityMetadataEntity } from '../cache/entities/AuthorityMetadataEntity.js';\nimport { AzureCloudInstance } from './AuthorityOptions.js';\nimport { isCloudInstanceDiscoveryResponse } from './CloudInstanceDiscoveryResponse.js';\nimport { RegionDiscovery } from './RegionDiscovery.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\r\n * endpoint. It will store the pertinent config data in this object for use during token calls.\r\n */\nvar Authority = /** @class */function () {\n  function Authority(authority, networkInterface, cacheManager, authorityOptions, proxyUrl) {\n    this.canonicalAuthority = authority;\n    this._canonicalAuthority.validateAsUri();\n    this.networkInterface = networkInterface;\n    this.cacheManager = cacheManager;\n    this.authorityOptions = authorityOptions;\n    this.regionDiscovery = new RegionDiscovery(networkInterface);\n    this.regionDiscoveryMetadata = {\n      region_used: undefined,\n      region_source: undefined,\n      region_outcome: undefined\n    };\n    this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;\n  }\n  Object.defineProperty(Authority.prototype, \"authorityType\", {\n    // See above for AuthorityType\n    get: function get() {\n      var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n      if (pathSegments.length) {\n        switch (pathSegments[0].toLowerCase()) {\n          case Constants.ADFS:\n            return AuthorityType.Adfs;\n          case Constants.DSTS:\n            return AuthorityType.Dsts;\n        }\n      }\n      return AuthorityType.Default;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"protocolMode\", {\n    /**\r\n     * ProtocolMode enum representing the way endpoints are constructed.\r\n     */\n    get: function get() {\n      return this.authorityOptions.protocolMode;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"options\", {\n    /**\r\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\r\n     */\n    get: function get() {\n      return this.authorityOptions;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthority\", {\n    /**\r\n     * A URL that is the authority set by the developer\r\n     */\n    get: function get() {\n      return this._canonicalAuthority.urlString;\n    },\n    /**\r\n     * Sets canonical authority.\r\n     */\n    set: function set(url) {\n      this._canonicalAuthority = new UrlString(url);\n      this._canonicalAuthority.validateAsUri();\n      this._canonicalAuthorityUrlComponents = null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"canonicalAuthorityUrlComponents\", {\n    /**\r\n     * Get authority components.\r\n     */\n    get: function get() {\n      if (!this._canonicalAuthorityUrlComponents) {\n        this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n      }\n      return this._canonicalAuthorityUrlComponents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"hostnameAndPort\", {\n    /**\r\n     * Get hostname and port i.e. login.microsoftonline.com\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tenant\", {\n    /**\r\n     * Get tenant for authority.\r\n     */\n    get: function get() {\n      return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"authorizationEndpoint\", {\n    /**\r\n     * OAuth /authorize endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.authorization_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"tokenEndpoint\", {\n    /**\r\n     * OAuth /token endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"deviceCodeEndpoint\", {\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"endSessionEndpoint\", {\n    /**\r\n     * OAuth logout endpoint for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        // ROPC policies may not have end_session_endpoint set\n        if (!this.metadata.end_session_endpoint) {\n          throw ClientAuthError.createLogoutNotSupportedError();\n        }\n        var endpoint = this.replacePath(this.metadata.end_session_endpoint);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"selfSignedJwtAudience\", {\n    /**\r\n     * OAuth issuer for requests\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.issuer);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Authority.prototype, \"jwksUri\", {\n    /**\r\n     * Jwks_uri for token signing keys\r\n     */\n    get: function get() {\n      if (this.discoveryComplete()) {\n        var endpoint = this.replacePath(this.metadata.jwks_uri);\n        return this.replaceTenant(endpoint);\n      } else {\n        throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Replaces tenant in url path with current tenant. Defaults to common.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replaceTenant = function (urlString) {\n    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n  };\n  /**\r\n   * Replaces path such as tenant or policy with the current tenant or policy.\r\n   * @param urlString\r\n   */\n  Authority.prototype.replacePath = function (urlString) {\n    var endpoint = urlString;\n    var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n    var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n    currentAuthorityParts.forEach(function (currentPart, index) {\n      var cachedPart = cachedAuthorityParts[index];\n      if (currentPart !== cachedPart) {\n        endpoint = endpoint.replace(\"/\" + cachedPart + \"/\", \"/\" + currentPart + \"/\");\n      }\n    });\n    return endpoint;\n  };\n  Object.defineProperty(Authority.prototype, \"defaultOpenIdConfigurationEndpoint\", {\n    /**\r\n     * The default open id configuration endpoint for any canonical authority.\r\n     */\n    get: function get() {\n      if (this.authorityType === AuthorityType.Adfs || this.authorityType === AuthorityType.Dsts || this.protocolMode === ProtocolMode.OIDC) {\n        return this.canonicalAuthority + \".well-known/openid-configuration\";\n      }\n      return this.canonicalAuthority + \"v2.0/.well-known/openid-configuration\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Boolean that returns whethr or not tenant discovery has been completed.\r\n   */\n  Authority.prototype.discoveryComplete = function () {\n    return !!this.metadata;\n  };\n  /**\r\n   * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\r\n   * and the /authorize, /token and logout endpoints.\r\n   */\n  Authority.prototype.resolveEndpointsAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n            if (!metadataEntity) {\n              metadataEntity = new AuthorityMetadataEntity();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            return [4 /*yield*/, this.updateCloudDiscoveryMetadata(metadataEntity)];\n          case 1:\n            cloudDiscoverySource = _a.sent();\n            this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n            return [4 /*yield*/, this.updateEndpointMetadata(metadataEntity)];\n          case 2:\n            endpointSource = _a.sent();\n            if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n              // Reset the expiration time unless both values came from a successful cache lookup\n              metadataEntity.resetExpiresAt();\n              metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n            }\n            cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n            this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n            this.metadata = metadataEntity;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Update AuthorityMetadataEntity with new endpoints and return where the information came from\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.updateEndpointMetadata = function (metadataEntity) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, harcodedMetadata;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            metadata = this.getEndpointMetadataFromConfig();\n            if (metadata) {\n              metadataEntity.updateEndpointMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            }\n            harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();\n            return [4 /*yield*/, this.getEndpointMetadataFromNetwork()];\n          case 1:\n            metadata = _c.sent();\n            if (!metadata) return [3 /*break*/, 4];\n            if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion)) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.updateMetadataWithRegionalInformation(metadata)];\n          case 2:\n            metadata = _c.sent();\n            _c.label = 3;\n          case 3:\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n          case 4:\n            if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache)) return [3 /*break*/, 7];\n            if (!((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion)) return [3 /*break*/, 6];\n            return [4 /*yield*/, this.updateMetadataWithRegionalInformation(harcodedMetadata)];\n          case 5:\n            harcodedMetadata = _c.sent();\n            _c.label = 6;\n          case 6:\n            metadataEntity.updateEndpointMetadata(harcodedMetadata, false);\n            return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];\n          case 7:\n            throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);\n        }\n      });\n    });\n  };\n  /**\r\n   * Compares the number of url components after the domain to determine if the cached\r\n   * authority metadata can be used for the requested authority. Protects against same domain different\r\n   * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\r\n   * @param metadataEntity\r\n   */\n  Authority.prototype.isAuthoritySameType = function (metadataEntity) {\n    var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n    var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n  };\n  /**\r\n   * Parse authorityMetadata config option\r\n   */\n  Authority.prototype.getEndpointMetadataFromConfig = function () {\n    if (this.authorityOptions.authorityMetadata) {\n      try {\n        return JSON.parse(this.authorityOptions.authorityMetadata);\n      } catch (e) {\n        throw ClientConfigurationError.createInvalidAuthorityMetadataError();\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Gets OAuth endpoints from the given OpenID configuration endpoint.\r\n   *\r\n   * @param hasHardcodedMetadata boolean\r\n   */\n  Authority.prototype.getEndpointMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var options, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            options = {};\n            if (this.proxyUrl) {\n              options.proxyUrl = this.proxyUrl;\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];\n          case 2:\n            response = _a.sent();\n            return [2 /*return*/, isOpenIdConfigResponse(response.body) ? response.body : null];\n          case 3:\n            _a.sent();\n            return [2 /*return*/, null];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get OAuth endpoints for common authorities.\r\n   */\n  Authority.prototype.getEndpointMetadataFromHardcodedValues = function () {\n    if (this.canonicalAuthority in EndpointMetadata) {\n      return EndpointMetadata[this.canonicalAuthority];\n    }\n    return null;\n  };\n  /**\r\n   * Update the retrieved metadata with regional information.\r\n   */\n  Authority.prototype.updateMetadataWithRegionalInformation = function (metadata) {\n    var _a, _b, _c, _d, _e;\n    return __awaiter(this, void 0, void 0, function () {\n      var autodetectedRegionName, azureRegion;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4 /*yield*/, this.regionDiscovery.detectRegion((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];\n          case 1:\n            autodetectedRegionName = _f.sent();\n            azureRegion = ((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : (_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion;\n            if (((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\n              this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n            } else {\n              if (autodetectedRegionName) {\n                this.regionDiscoveryMetadata.region_outcome = ((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion) === autodetectedRegionName ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;\n              } else {\n                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n              }\n            }\n            if (azureRegion) {\n              this.regionDiscoveryMetadata.region_used = azureRegion;\n              return [2 /*return*/, Authority.replaceWithRegionalInformation(metadata, azureRegion)];\n            }\n            return [2 /*return*/, metadata];\n        }\n      });\n    });\n  };\n  /**\r\n   * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\r\n   * and returns where the information was retrieved from\r\n   * @param cachedMetadata\r\n   * @param newMetadata\r\n   */\n  Authority.prototype.updateCloudDiscoveryMetadata = function (metadataEntity) {\n    return __awaiter(this, void 0, void 0, function () {\n      var metadata, harcodedMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            metadata = this.getCloudDiscoveryMetadataFromConfig();\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.CONFIG];\n            }\n            // If The cached metadata came from config but that config was not passed to this instance, we must go to the network\n            if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {\n              // No need to update\n              return [2 /*return*/, AuthorityMetadataSource.CACHE];\n            }\n            harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();\n            return [4 /*yield*/, this.getCloudDiscoveryMetadataFromNetwork()];\n          case 1:\n            metadata = _a.sent();\n            if (metadata) {\n              metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n              return [2 /*return*/, AuthorityMetadataSource.NETWORK];\n            }\n            if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {\n              metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);\n              return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];\n            } else {\n              // Metadata could not be obtained from config, cache or network\n              throw ClientConfigurationError.createUntrustedAuthorityError();\n            }\n        }\n      });\n    });\n  };\n  /**\r\n   * Parse cloudDiscoveryMetadata config or check knownAuthorities\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromConfig = function () {\n    // Check if network response was provided in config\n    if (this.authorityOptions.cloudDiscoveryMetadata) {\n      try {\n        var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);\n        var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\n        if (metadata) {\n          return metadata;\n        }\n      } catch (e) {\n        throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\n      }\n    }\n    // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n    if (this.isInKnownAuthorities()) {\n      return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n    return null;\n  };\n  /**\r\n   * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\r\n   *\r\n   * @param hasHardcodedMetadata boolean\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var instanceDiscoveryEndpoint, options, match, response, metadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            instanceDiscoveryEndpoint = \"\" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + \"oauth2/v2.0/authorize\";\n            options = {};\n            if (this.proxyUrl) {\n              options.proxyUrl = this.proxyUrl;\n            }\n            match = null;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];\n          case 2:\n            response = _a.sent();\n            metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];\n            if (metadata.length === 0) {\n              // If no metadata is returned, authority is untrusted\n              return [2 /*return*/, null];\n            }\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\n            return [3 /*break*/, 4];\n          case 3:\n            _a.sent();\n            return [2 /*return*/, null];\n          case 4:\n            if (!match) {\n              // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\n              match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n            }\n            return [2 /*return*/, match];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get cloud discovery metadata for common authorities\r\n   */\n  Authority.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function () {\n    if (this.canonicalAuthority in InstanceDiscoveryMetadata) {\n      return InstanceDiscoveryMetadata[this.canonicalAuthority];\n    }\n    return null;\n  };\n  /**\r\n   * Helper function to determine if this host is included in the knownAuthorities config option\r\n   */\n  Authority.prototype.isInKnownAuthorities = function () {\n    var _this = this;\n    var matches = this.authorityOptions.knownAuthorities.filter(function (authority) {\n      return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;\n    });\n    return matches.length > 0;\n  };\n  /**\r\n   * helper function to populate the authority based on azureCloudOptions\r\n   * @param authorityString\r\n   * @param azureCloudOptions\r\n   */\n  Authority.generateAuthority = function (authorityString, azureCloudOptions) {\n    var authorityAzureCloudInstance;\n    if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {\n      var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;\n      authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + \"/\" + tenant + \"/\";\n    }\n    return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;\n  };\n  /**\r\n   * Creates cloud discovery metadata object from a given host\r\n   * @param host\r\n   */\n  Authority.createCloudDiscoveryMetadataFromHost = function (host) {\n    return {\n      preferred_network: host,\n      preferred_cache: host,\n      aliases: [host]\n    };\n  };\n  /**\r\n   * Searches instance discovery network response for the entry that contains the host in the aliases list\r\n   * @param response\r\n   * @param authority\r\n   */\n  Authority.getCloudDiscoveryMetadataFromNetworkResponse = function (response, authority) {\n    for (var i = 0; i < response.length; i++) {\n      var metadata = response[i];\n      if (metadata.aliases.indexOf(authority) > -1) {\n        return metadata;\n      }\n    }\n    return null;\n  };\n  /**\r\n   * helper function to generate environment from authority object\r\n   */\n  Authority.prototype.getPreferredCache = function () {\n    if (this.discoveryComplete()) {\n      return this.metadata.preferred_cache;\n    } else {\n      throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n    }\n  };\n  /**\r\n   * Returns whether or not the provided host is an alias of this authority instance\r\n   * @param host\r\n   */\n  Authority.prototype.isAlias = function (host) {\n    return this.metadata.aliases.indexOf(host) > -1;\n  };\n  /**\r\n   * Checks whether the provided host is that of a public cloud authority\r\n   *\r\n   * @param authority string\r\n   * @returns bool\r\n   */\n  Authority.isPublicCloudAuthority = function (host) {\n    return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n  };\n  /**\r\n   * Rebuild the authority string with the region\r\n   *\r\n   * @param host string\r\n   * @param region string\r\n   */\n  Authority.buildRegionalAuthorityString = function (host, region, queryString) {\n    // Create and validate a Url string object with the initial authority string\n    var authorityUrlInstance = new UrlString(host);\n    authorityUrlInstance.validateAsUri();\n    var authorityUrlParts = authorityUrlInstance.getUrlComponents();\n    var hostNameAndPort = region + \".\" + authorityUrlParts.HostNameAndPort;\n    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n      hostNameAndPort = region + \".\" + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;\n    }\n    // Include the query string portion of the url\n    var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), {\n      HostNameAndPort: hostNameAndPort\n    })).urlString;\n    // Add the query string if a query string was provided\n    if (queryString) return url + \"?\" + queryString;\n    return url;\n  };\n  /**\r\n   * Replace the endpoints in the metadata object with their regional equivalents.\r\n   *\r\n   * @param metadata OpenIdConfigResponse\r\n   * @param azureRegion string\r\n   */\n  Authority.replaceWithRegionalInformation = function (metadata, azureRegion) {\n    metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\n    // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n    metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING);\n    if (metadata.end_session_endpoint) {\n      metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n    }\n    return metadata;\n  };\n  return Authority;\n}();\nexport { Authority };","map":{"version":3,"names":["Authority","authority","networkInterface","cacheManager","authorityOptions","proxyUrl","canonicalAuthority","_canonicalAuthority","validateAsUri","regionDiscovery","RegionDiscovery","regionDiscoveryMetadata","region_used","undefined","region_source","region_outcome","Constants","EMPTY_STRING","Object","defineProperty","prototype","get","pathSegments","canonicalAuthorityUrlComponents","PathSegments","length","toLowerCase","ADFS","AuthorityType","Adfs","DSTS","Dsts","Default","protocolMode","urlString","set","url","UrlString","_canonicalAuthorityUrlComponents","getUrlComponents","HostNameAndPort","discoveryComplete","endpoint","replacePath","metadata","authorization_endpoint","replaceTenant","ClientAuthError","createEndpointDiscoveryIncompleteError","token_endpoint","replace","end_session_endpoint","createLogoutNotSupportedError","issuer","jwks_uri","tenant","cachedAuthorityUrl","canonical_authority","cachedAuthorityParts","currentAuthorityParts","forEach","currentPart","index","cachedPart","authorityType","ProtocolMode","OIDC","resolveEndpointsAsync","metadataEntity","getAuthorityMetadataByAlias","hostnameAndPort","AuthorityMetadataEntity","updateCanonicalAuthority","updateCloudDiscoveryMetadata","cloudDiscoverySource","_a","sent","preferred_network","updateEndpointMetadata","endpointSource","AuthorityMetadataSource","CACHE","resetExpiresAt","cacheKey","generateAuthorityMetadataCacheKey","preferred_cache","setAuthorityMetadata","getEndpointMetadataFromConfig","CONFIG","isAuthoritySameType","endpointsFromNetwork","isExpired","harcodedMetadata","getEndpointMetadataFromHardcodedValues","getEndpointMetadataFromNetwork","_c","azureRegionConfiguration","azureRegion","updateMetadataWithRegionalInformation","NETWORK","skipAuthorityMetadataCache","_b","HARDCODED_VALUES","createUnableToGetOpenidConfigError","defaultOpenIdConfigurationEndpoint","cachedParts","authorityMetadata","JSON","parse","e","ClientConfigurationError","createInvalidAuthorityMetadataError","options","sendGetRequestAsync","response","isOpenIdConfigResponse","body","EndpointMetadata","detectRegion","environmentRegion","autodetectedRegionName","_f","AZURE_REGION_AUTO_DISCOVER_FLAG","_d","RegionDiscoveryOutcomes","AUTO_DETECTION_REQUESTED_SUCCESSFUL","AUTO_DETECTION_REQUESTED_FAILED","_e","CONFIGURED_MATCHES_DETECTED","CONFIGURED_NOT_DETECTED","CONFIGURED_NO_AUTO_DETECTION","replaceWithRegionalInformation","getCloudDiscoveryMetadataFromConfig","aliasesFromNetwork","getCloudDiscoveryMetadataFromHarcodedValues","getCloudDiscoveryMetadataFromNetwork","createUntrustedAuthorityError","cloudDiscoveryMetadata","parsedResponse","getCloudDiscoveryMetadataFromNetworkResponse","createInvalidCloudDiscoveryMetadataError","isInKnownAuthorities","createCloudDiscoveryMetadataFromHost","instanceDiscoveryEndpoint","AAD_INSTANCE_DISCOVERY_ENDPT","match","isCloudInstanceDiscoveryResponse","InstanceDiscoveryMetadata","_this","matches","knownAuthorities","filter","getDomainFromUrl","generateAuthority","authorityString","azureCloudOptions","authorityAzureCloudInstance","azureCloudInstance","AzureCloudInstance","None","DEFAULT_COMMON_TENANT","host","aliases","i","indexOf","getPreferredCache","isAlias","isPublicCloudAuthority","KNOWN_PUBLIC_CLOUDS","buildRegionalAuthorityString","region","queryString","authorityUrlInstance","authorityUrlParts","hostNameAndPort","REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX","constructAuthorityUriFromObject","__assign","REGIONAL_AUTH_NON_MSI_QUERY_STRING"],"sources":["../../src/authority/Authority.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthorityType } from \"./AuthorityType\";\nimport { isOpenIdConfigResponse, OpenIdConfigResponse } from \"./OpenIdConfigResponse\";\nimport { UrlString } from \"../url/UrlString\";\nimport { IUri } from \"../url/IUri\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { INetworkModule } from \"../network/INetworkModule\";\nimport { AuthorityMetadataSource, Constants, RegionDiscoveryOutcomes } from \"../utils/Constants\";\nimport { EndpointMetadata, InstanceDiscoveryMetadata } from \"./AuthorityMetadata\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ProtocolMode } from \"./ProtocolMode\";\nimport { ICacheManager } from \"../cache/interface/ICacheManager\";\nimport { AuthorityMetadataEntity } from \"../cache/entities/AuthorityMetadataEntity\";\nimport { AuthorityOptions , AzureCloudInstance } from \"./AuthorityOptions\";\nimport { CloudInstanceDiscoveryResponse, isCloudInstanceDiscoveryResponse } from \"./CloudInstanceDiscoveryResponse\";\nimport { CloudDiscoveryMetadata } from \"./CloudDiscoveryMetadata\";\nimport { RegionDiscovery } from \"./RegionDiscovery\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\nimport { ImdsOptions } from \"./ImdsOptions\";\nimport { AzureCloudOptions } from \"../config/ClientConfiguration\";\n\n/**\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\n * endpoint. It will store the pertinent config data in this object for use during token calls.\n */\nexport class Authority {\n\n    // Canonical authority url string\n    private _canonicalAuthority: UrlString;\n    // Canonicaly authority url components\n    private _canonicalAuthorityUrlComponents: IUri | null;\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Cache Manager to cache network responses\n    protected cacheManager: ICacheManager;\n    // Protocol mode to construct endpoints\n    private authorityOptions: AuthorityOptions;\n    // Authority metadata\n    private metadata: AuthorityMetadataEntity;\n    // Region discovery service\n    private regionDiscovery: RegionDiscovery;\n    // Region discovery metadata\n    public regionDiscoveryMetadata: RegionDiscoveryMetadata;\n    // Proxy url string\n    private proxyUrl: string;\n\n    constructor(\n        authority: string,\n        networkInterface: INetworkModule,\n        cacheManager: ICacheManager,\n        authorityOptions: AuthorityOptions,\n        proxyUrl?: string) {\n        this.canonicalAuthority = authority;\n        this._canonicalAuthority.validateAsUri();\n        this.networkInterface = networkInterface;\n        this.cacheManager = cacheManager;\n        this.authorityOptions = authorityOptions;\n        this.regionDiscovery = new RegionDiscovery(networkInterface);\n        this.regionDiscoveryMetadata = { region_used: undefined, region_source: undefined, region_outcome: undefined };\n        this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;\n    }\n\n    // See above for AuthorityType\n    public get authorityType(): AuthorityType {\n        const pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;\n        if (pathSegments.length) {\n            switch(pathSegments[0].toLowerCase()) {\n                case Constants.ADFS:\n                    return AuthorityType.Adfs;\n                case Constants.DSTS:\n                    return AuthorityType.Dsts;\n                default:\n                    break;\n            }\n        }\n        return AuthorityType.Default;\n    }\n\n    /**\n     * ProtocolMode enum representing the way endpoints are constructed.\n     */\n    public get protocolMode(): ProtocolMode {\n        return this.authorityOptions.protocolMode;\n    }\n\n    /**\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\n     */\n    public get options(): AuthorityOptions {\n        return this.authorityOptions;\n    }\n\n    /**\n     * A URL that is the authority set by the developer\n     */\n    public get canonicalAuthority(): string {\n        return this._canonicalAuthority.urlString;\n    }\n\n    /**\n     * Sets canonical authority.\n     */\n    public set canonicalAuthority(url: string) {\n        this._canonicalAuthority = new UrlString(url);\n        this._canonicalAuthority.validateAsUri();\n        this._canonicalAuthorityUrlComponents = null;\n    }\n\n    /**\n     * Get authority components.\n     */\n    public get canonicalAuthorityUrlComponents(): IUri {\n        if (!this._canonicalAuthorityUrlComponents) {\n            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n        }\n\n        return this._canonicalAuthorityUrlComponents;\n    }\n\n    /**\n     * Get hostname and port i.e. login.microsoftonline.com\n     */\n    public get hostnameAndPort(): string {\n        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    }\n\n    /**\n     * Get tenant for authority.\n     */\n    public get tenant(): string {\n        return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    }\n\n    /**\n     * OAuth /authorize endpoint for requests\n     */\n    public get authorizationEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.authorization_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth /token endpoint for requests\n     */\n    public get tokenEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.token_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    public get deviceCodeEndpoint(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth logout endpoint for requests\n     */\n    public get endSessionEndpoint(): string {\n        if(this.discoveryComplete()) {\n            // ROPC policies may not have end_session_endpoint set\n            if (!this.metadata.end_session_endpoint) {\n                throw ClientAuthError.createLogoutNotSupportedError();\n            }\n            const endpoint = this.replacePath(this.metadata.end_session_endpoint);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * OAuth issuer for requests\n     */\n    public get selfSignedJwtAudience(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.issuer);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Jwks_uri for token signing keys\n     */\n    public get jwksUri(): string {\n        if(this.discoveryComplete()) {\n            const endpoint = this.replacePath(this.metadata.jwks_uri);\n            return this.replaceTenant(endpoint);\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Replaces tenant in url path with current tenant. Defaults to common.\n     * @param urlString\n     */\n    private replaceTenant(urlString: string): string {\n        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n    }\n\n    /**\n     * Replaces path such as tenant or policy with the current tenant or policy.\n     * @param urlString\n     */\n    private replacePath(urlString: string): string {\n        let endpoint = urlString;\n        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n        const cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n\n        currentAuthorityParts.forEach((currentPart, index) => {\n            const cachedPart = cachedAuthorityParts[index];\n            if (currentPart !== cachedPart) {\n                endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);\n            }\n        });\n\n        return endpoint;\n    }\n\n    /**\n     * The default open id configuration endpoint for any canonical authority.\n     */\n    protected get defaultOpenIdConfigurationEndpoint(): string {\n        if (\n            this.authorityType === AuthorityType.Adfs ||\n            this.authorityType === AuthorityType.Dsts ||\n            this.protocolMode === ProtocolMode.OIDC\n        ) {\n            return `${this.canonicalAuthority}.well-known/openid-configuration`;\n        }\n        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\n    }\n\n    /**\n     * Boolean that returns whethr or not tenant discovery has been completed.\n     */\n    discoveryComplete(): boolean {\n        return !!this.metadata;\n    }\n\n    /**\n     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\n     * and the /authorize, /token and logout endpoints.\n     */\n    public async resolveEndpointsAsync(): Promise<void> {\n        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n        if (!metadataEntity) {\n            metadataEntity = new AuthorityMetadataEntity();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        }\n\n        const cloudDiscoverySource = await this.updateCloudDiscoveryMetadata(metadataEntity);\n        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n        const endpointSource = await this.updateEndpointMetadata(metadataEntity);\n\n        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {\n            // Reset the expiration time unless both values came from a successful cache lookup\n            metadataEntity.resetExpiresAt();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        }\n\n        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n        this.metadata = metadataEntity;\n    }\n\n    /**\n     * Update AuthorityMetadataEntity with new endpoints and return where the information came from\n     * @param metadataEntity\n     */\n    private async updateEndpointMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\n        let metadata = this.getEndpointMetadataFromConfig();\n        if (metadata) {\n            metadataEntity.updateEndpointMetadata(metadata, false);\n            return AuthorityMetadataSource.CONFIG;\n        }\n\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {\n            // No need to update\n            return AuthorityMetadataSource.CACHE;\n        }\n\n        let harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();\n        metadata = await this.getEndpointMetadataFromNetwork();\n        if (metadata) {\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n                metadata = await this.updateMetadataWithRegionalInformation(metadata);\n            }\n\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        }    \n\n        if (harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache) {\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n                harcodedMetadata = await this.updateMetadataWithRegionalInformation(\n                    harcodedMetadata\n                );\n            }\n\n            metadataEntity.updateEndpointMetadata(harcodedMetadata, false);\n            return AuthorityMetadataSource.HARDCODED_VALUES;\n        } else {\n            throw ClientAuthError.createUnableToGetOpenidConfigError(\n                this.defaultOpenIdConfigurationEndpoint\n            );\n        }\n    }\n\n    /**\n     * Compares the number of url components after the domain to determine if the cached \n     * authority metadata can be used for the requested authority. Protects against same domain different \n     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\n     * @param metadataEntity\n     */\n    private isAuthoritySameType(metadataEntity: AuthorityMetadataEntity): boolean {\n        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n\n        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n    }\n\n    /**\n     * Parse authorityMetadata config option\n     */\n    private getEndpointMetadataFromConfig(): OpenIdConfigResponse | null {\n        if (this.authorityOptions.authorityMetadata) {\n            try {\n                return JSON.parse(this.authorityOptions.authorityMetadata) as OpenIdConfigResponse;\n            } catch (e) {\n                throw ClientConfigurationError.createInvalidAuthorityMetadataError();\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets OAuth endpoints from the given OpenID configuration endpoint.\n     * \n     * @param hasHardcodedMetadata boolean\n     */\n    private async getEndpointMetadataFromNetwork(): Promise<OpenIdConfigResponse | null> {\n        const options: ImdsOptions = {};\n        if (this.proxyUrl) {\n            options.proxyUrl = this.proxyUrl;\n        }\n\n        /*\n         * TODO: Add a timeout if the authority exists in our library's \n         * hardcoded list of metadata\n         */\n\n        try {\n            const response = await this.networkInterface.\n                sendGetRequestAsync<OpenIdConfigResponse>(this.defaultOpenIdConfigurationEndpoint, options);\n            return isOpenIdConfigResponse(response.body) ? response.body : null;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     * Get OAuth endpoints for common authorities.\n     */\n    private getEndpointMetadataFromHardcodedValues(): OpenIdConfigResponse | null {\n        if (this.canonicalAuthority in EndpointMetadata) {\n            return EndpointMetadata[this.canonicalAuthority];\n        }\n\n        return null;\n    }\n\n    /**\n     * Update the retrieved metadata with regional information.\n     */\n    private async updateMetadataWithRegionalInformation(metadata: OpenIdConfigResponse): Promise<OpenIdConfigResponse> {\n        const autodetectedRegionName = await this.regionDiscovery.detectRegion(\n            this.authorityOptions.azureRegionConfiguration?.environmentRegion,\n            this.regionDiscoveryMetadata,\n            this.proxyUrl\n        );\n\n        const azureRegion = \n            this.authorityOptions.azureRegionConfiguration?.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG\n                ? autodetectedRegionName\n                : this.authorityOptions.azureRegionConfiguration?.azureRegion;\n\n        if (this.authorityOptions.azureRegionConfiguration?.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\n            this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ?\n                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL :\n                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n        } else {\n            if (autodetectedRegionName) {\n                this.regionDiscoveryMetadata.region_outcome = (\n                    this.authorityOptions.azureRegionConfiguration?.azureRegion === autodetectedRegionName\n                ) ?\n                    RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED :\n                    RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;\n            } else {\n                this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n            }\n        }\n\n        if (azureRegion) {\n            this.regionDiscoveryMetadata.region_used = azureRegion;\n            return Authority.replaceWithRegionalInformation(metadata, azureRegion);\n        }\n\n        return metadata;\n    }\n\n    /**\n     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\n     * and returns where the information was retrieved from\n     * @param cachedMetadata\n     * @param newMetadata\n     */\n    private async updateCloudDiscoveryMetadata(metadataEntity: AuthorityMetadataEntity): Promise<AuthorityMetadataSource> {\n        let metadata = this.getCloudDiscoveryMetadataFromConfig();\n        if (metadata) {\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n            return AuthorityMetadataSource.CONFIG;\n        }\n\n        // If The cached metadata came from config but that config was not passed to this instance, we must go to the network\n        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {\n            // No need to update\n            return AuthorityMetadataSource.CACHE;\n        }\n\n        const harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();\n\n        metadata = await this.getCloudDiscoveryMetadataFromNetwork();\n        if (metadata) {\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        }\n        \n        if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {\n            metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);\n            return AuthorityMetadataSource.HARDCODED_VALUES;\n        } else {\n            // Metadata could not be obtained from config, cache or network\n            throw ClientConfigurationError.createUntrustedAuthorityError();\n        }\n    }\n\n    /**\n     * Parse cloudDiscoveryMetadata config or check knownAuthorities\n     */\n    private getCloudDiscoveryMetadataFromConfig(): CloudDiscoveryMetadata | null {\n        // Check if network response was provided in config\n        if (this.authorityOptions.cloudDiscoveryMetadata) {\n            try {\n                const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata) as CloudInstanceDiscoveryResponse;\n                const metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(\n                    parsedResponse.metadata,\n                    this.hostnameAndPort\n                );\n                if (metadata) {\n                    return metadata;\n                }\n            } catch (e) {\n                throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();\n            }\n        }\n        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n        if (this.isInKnownAuthorities()) {\n            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n        }\n\n        return null;\n    }\n\n    /**\n     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\n     * \n     * @param hasHardcodedMetadata boolean\n     */\n    private async getCloudDiscoveryMetadataFromNetwork(): Promise<CloudDiscoveryMetadata | null> {\n        const instanceDiscoveryEndpoint =\n            `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\n        const options: ImdsOptions = {};\n        if (this.proxyUrl) {\n            options.proxyUrl = this.proxyUrl;\n        }\n\n        /*\n         * TODO: Add a timeout if the authority exists in our library's\n         * hardcoded list of metadata\n         */\n\n        let match = null;\n        try {\n            const response =\n                await this.networkInterface.sendGetRequestAsync<CloudInstanceDiscoveryResponse>(\n                    instanceDiscoveryEndpoint,\n                    options\n                );\n            const metadata = isCloudInstanceDiscoveryResponse(response.body)\n                ? response.body.metadata\n                : [];\n            if (metadata.length === 0) {\n                // If no metadata is returned, authority is untrusted\n                return null;\n            }\n            match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(\n                metadata,\n                this.hostnameAndPort\n            );\n        } catch (e) {\n            return null;\n        }\n\n        if (!match) {\n            // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\n            match = Authority.createCloudDiscoveryMetadataFromHost(\n                this.hostnameAndPort\n            );\n        }\n        return match;\n    }\n\n    /**\n     * Get cloud discovery metadata for common authorities \n     */\n    private getCloudDiscoveryMetadataFromHarcodedValues(): CloudDiscoveryMetadata | null {\n        if (this.canonicalAuthority in InstanceDiscoveryMetadata) {\n            return InstanceDiscoveryMetadata[this.canonicalAuthority];\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper function to determine if this host is included in the knownAuthorities config option\n     */\n    private isInKnownAuthorities(): boolean {\n        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {\n            return UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;\n        });\n\n        return matches.length > 0;\n    }\n\n    /**\n     * helper function to populate the authority based on azureCloudOptions\n     * @param authorityString\n     * @param azureCloudOptions\n     */\n    static generateAuthority(authorityString: string, azureCloudOptions?: AzureCloudOptions): string {\n        let authorityAzureCloudInstance;\n\n        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {\n            const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;\n            authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;\n        }\n\n        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;\n    }\n\n    /**\n     * Creates cloud discovery metadata object from a given host\n     * @param host\n     */\n    static createCloudDiscoveryMetadataFromHost(host: string): CloudDiscoveryMetadata {\n        return {\n            preferred_network: host,\n            preferred_cache: host,\n            aliases: [host]\n        };\n    }\n\n    /**\n     * Searches instance discovery network response for the entry that contains the host in the aliases list\n     * @param response\n     * @param authority\n     */\n    static getCloudDiscoveryMetadataFromNetworkResponse(\n        response: CloudDiscoveryMetadata[],\n        authority: string\n    ): CloudDiscoveryMetadata | null {\n        for (let i = 0; i < response.length; i++) {\n            const metadata = response[i];\n            if (metadata.aliases.indexOf(authority) > -1) {\n                return metadata;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * helper function to generate environment from authority object\n     */\n    getPreferredCache(): string {\n        if(this.discoveryComplete()) {\n            return this.metadata.preferred_cache;\n        } else {\n            throw ClientAuthError.createEndpointDiscoveryIncompleteError(\"Discovery incomplete.\");\n        }\n    }\n\n    /**\n     * Returns whether or not the provided host is an alias of this authority instance\n     * @param host\n     */\n    isAlias(host: string): boolean {\n        return this.metadata.aliases.indexOf(host) > -1;\n    }\n\n    /**\n     * Checks whether the provided host is that of a public cloud authority\n     *\n     * @param authority string\n     * @returns bool\n     */\n    static isPublicCloudAuthority(host: string): boolean {\n        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n    }\n\n    /**\n     * Rebuild the authority string with the region\n     *\n     * @param host string\n     * @param region string\n     */\n    static buildRegionalAuthorityString(host: string, region: string, queryString?: string): string {\n        // Create and validate a Url string object with the initial authority string\n        const authorityUrlInstance = new UrlString(host);\n        authorityUrlInstance.validateAsUri();\n\n        const authorityUrlParts = authorityUrlInstance.getUrlComponents();\n\n        let hostNameAndPort= `${region}.${authorityUrlParts.HostNameAndPort}`;\n\n        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n            hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;\n        }\n\n        // Include the query string portion of the url\n        const url = UrlString.constructAuthorityUriFromObject({\n            ...authorityUrlInstance.getUrlComponents(),\n            HostNameAndPort: hostNameAndPort\n        }).urlString;\n\n        // Add the query string if a query string was provided\n        if (queryString) return `${url}?${queryString}`;\n\n        return url;\n    }\n\n    /**\n     * Replace the endpoints in the metadata object with their regional equivalents.\n     *\n     * @param metadata OpenIdConfigResponse\n     * @param azureRegion string\n     */\n    static replaceWithRegionalInformation(metadata: OpenIdConfigResponse, azureRegion: string): OpenIdConfigResponse {\n        metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);\n        // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature\n        metadata.token_endpoint = Authority.buildRegionalAuthorityString(\n            metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING\n        );\n\n        if (metadata.end_session_endpoint) {\n            metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);\n        }\n\n        return metadata;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}