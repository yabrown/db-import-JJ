{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_CHARKEY } from \"./interfaces\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nvar defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nvar defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport var deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _a, _b, _c, _d, _e, _f, _g;\n  var jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n  var xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n  var parseXML = options.parseXML;\n  var serializerOptions = options.serializerOptions;\n  var updatedOptions = {\n    xml: {\n      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY\n    }\n  };\n  return {\n    name: deserializationPolicyName,\n    sendRequest: function sendRequest(request, next) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return next(request);\n            case 2:\n              response = _context.sent;\n              return _context.abrupt(\"return\", deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML));\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    }\n  };\n}\nfunction getOperationResponseMap(parsedResponse) {\n  var result;\n  var request = parsedResponse.request;\n  var operationInfo = getOperationRequestInfo(request);\n  var operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n  if (operationSpec) {\n    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n  var request = parsedResponse.request;\n  var operationInfo = getOperationRequestInfo(request);\n  var shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n  var result;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\nfunction deserializeResponseBody(_x, _x2, _x3, _x4, _x5) {\n  return _deserializeResponseBody.apply(this, arguments);\n}\nfunction _deserializeResponseBody() {\n  _deserializeResponseBody = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    var parsedResponse, operationInfo, operationSpec, responseSpec, _handleErrorResponse, error, shouldReturnResponse, valueToDeserialize, restError;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n        case 2:\n          parsedResponse = _context2.sent;\n          if (shouldDeserializeResponse(parsedResponse)) {\n            _context2.next = 5;\n            break;\n          }\n          return _context2.abrupt(\"return\", parsedResponse);\n        case 5:\n          operationInfo = getOperationRequestInfo(parsedResponse.request);\n          operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n          if (!(!operationSpec || !operationSpec.responses)) {\n            _context2.next = 9;\n            break;\n          }\n          return _context2.abrupt(\"return\", parsedResponse);\n        case 9:\n          responseSpec = getOperationResponseMap(parsedResponse);\n          _handleErrorResponse = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options), error = _handleErrorResponse.error, shouldReturnResponse = _handleErrorResponse.shouldReturnResponse;\n          if (!error) {\n            _context2.next = 15;\n            break;\n          }\n          throw error;\n        case 15:\n          if (!shouldReturnResponse) {\n            _context2.next = 17;\n            break;\n          }\n          return _context2.abrupt(\"return\", parsedResponse);\n        case 17:\n          if (!responseSpec) {\n            _context2.next = 33;\n            break;\n          }\n          if (!responseSpec.bodyMapper) {\n            _context2.next = 31;\n            break;\n          }\n          valueToDeserialize = parsedResponse.parsedBody;\n          if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n            valueToDeserialize = typeof valueToDeserialize === \"object\" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];\n          }\n          _context2.prev = 21;\n          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n          _context2.next = 29;\n          break;\n        case 25:\n          _context2.prev = 25;\n          _context2.t0 = _context2[\"catch\"](21);\n          restError = new RestError(\"Error \".concat(_context2.t0, \" occurred in deserializing the responseBody - \").concat(parsedResponse.bodyAsText), {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse\n          });\n          throw restError;\n        case 29:\n          _context2.next = 32;\n          break;\n        case 31:\n          if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n          }\n        case 32:\n          if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", {\n              xml: {},\n              ignoreUnknownProperties: true\n            });\n          }\n        case 33:\n          return _context2.abrupt(\"return\", parsedResponse);\n        case 34:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[21, 25]]);\n  }));\n  return _deserializeResponseBody.apply(this, arguments);\n}\nfunction isOperationSpecEmpty(operationSpec) {\n  var expectedStatusCodes = Object.keys(operationSpec.responses);\n  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\";\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n  var _a;\n  var isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  var isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return {\n          error: null,\n          shouldReturnResponse: false\n        };\n      }\n    } else {\n      return {\n        error: null,\n        shouldReturnResponse: false\n      };\n    }\n  }\n  var errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n  var initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? \"Unexpected status code: \".concat(parsedResponse.status) : parsedResponse.bodyAsText;\n  var error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse\n  });\n  // If the item failed but there's no error spec or default spec to deserialize the error,\n  // we should fail so we just throw the parsed response\n  if (!errorResponseSpec) {\n    throw error;\n  }\n  var defaultBodyMapper = errorResponseSpec.bodyMapper;\n  var defaultHeadersMapper = errorResponseSpec.headersMapper;\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      var parsedBody = parsedResponse.parsedBody;\n      var deserializedError;\n      if (defaultBodyMapper) {\n        var valueToDeserialize = parsedBody;\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          var elementName = defaultBodyMapper.xmlElementName;\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n      }\n      var internalError = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n      if (defaultBodyMapper) {\n        error.response.parsedBody = deserializedError;\n      }\n    }\n    // If error response has headers, try to deserialize it using default header mapper\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n    }\n  } catch (defaultError) {\n    error.message = \"Error \\\"\".concat(defaultError.message, \"\\\" occurred in deserializing the responseBody - \\\"\").concat(parsedResponse.bodyAsText, \"\\\" for the default response.\");\n  }\n  return {\n    error: error,\n    shouldReturnResponse: false\n  };\n}\nfunction parse(_x6, _x7, _x8, _x9, _x10) {\n  return _parse.apply(this, arguments);\n}\nfunction _parse() {\n  _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a, text, contentType, contentComponents, body, msg, errCode, e;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!(!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText)) {\n            _context3.next = 26;\n            break;\n          }\n          text = operationResponse.bodyAsText;\n          contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n          contentComponents = !contentType ? [] : contentType.split(\";\").map(function (component) {\n            return component.toLowerCase();\n          });\n          _context3.prev = 4;\n          if (!(contentComponents.length === 0 || contentComponents.some(function (component) {\n            return jsonContentTypes.indexOf(component) !== -1;\n          }))) {\n            _context3.next = 10;\n            break;\n          }\n          operationResponse.parsedBody = JSON.parse(text);\n          return _context3.abrupt(\"return\", operationResponse);\n        case 10:\n          if (!contentComponents.some(function (component) {\n            return xmlContentTypes.indexOf(component) !== -1;\n          })) {\n            _context3.next = 18;\n            break;\n          }\n          if (parseXML) {\n            _context3.next = 13;\n            break;\n          }\n          throw new Error(\"Parsing XML not supported.\");\n        case 13:\n          _context3.next = 15;\n          return parseXML(text, opts.xml);\n        case 15:\n          body = _context3.sent;\n          operationResponse.parsedBody = body;\n          return _context3.abrupt(\"return\", operationResponse);\n        case 18:\n          _context3.next = 26;\n          break;\n        case 20:\n          _context3.prev = 20;\n          _context3.t0 = _context3[\"catch\"](4);\n          msg = \"Error \\\"\".concat(_context3.t0, \"\\\" occurred while parsing the response body - \").concat(operationResponse.bodyAsText, \".\");\n          errCode = _context3.t0.code || RestError.PARSE_ERROR;\n          e = new RestError(msg, {\n            code: errCode,\n            statusCode: operationResponse.status,\n            request: operationResponse.request,\n            response: operationResponse\n          });\n          throw e;\n        case 26:\n          return _context3.abrupt(\"return\", operationResponse);\n        case 27:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[4, 20]]);\n  }));\n  return _parse.apply(this, arguments);\n}","map":{"version":3,"names":["XML_CHARKEY","RestError","MapperTypeNames","getOperationRequestInfo","defaultJsonContentTypes","defaultXmlContentTypes","deserializationPolicyName","deserializationPolicy","options","arguments","length","undefined","jsonContentTypes","_b","_a","expectedContentTypes","json","xmlContentTypes","_d","_c","xml","parseXML","serializerOptions","updatedOptions","rootName","_e","includeRoot","_f","xmlCharKey","_g","name","sendRequest","request","next","_asyncToGenerator","_regeneratorRuntime","mark","_callee","response","wrap","_callee$","_context","prev","sent","abrupt","deserializeResponseBody","stop","getOperationResponseMap","parsedResponse","result","operationInfo","operationSpec","operationResponseGetter","responses","status","shouldDeserializeResponse","shouldDeserialize","_x","_x2","_x3","_x4","_x5","_deserializeResponseBody","apply","_callee2","responseSpec","_handleErrorResponse","error","shouldReturnResponse","valueToDeserialize","restError","_callee2$","_context2","parse","handleErrorResponse","bodyMapper","parsedBody","isXML","type","Sequence","xmlElementName","serializer","deserialize","t0","concat","bodyAsText","statusCode","httpMethod","headersMapper","parsedHeaders","headers","toJSON","ignoreUnknownProperties","isOperationSpecEmpty","expectedStatusCodes","Object","keys","isSuccessByStatus","isExpectedStatusCode","isError","errorResponseSpec","default","initialErrorMessage","streamResponseStatusCodes","has","defaultBodyMapper","defaultHeadersMapper","deserializedError","elementName","internalError","code","message","defaultError","_x6","_x7","_x8","_x9","_x10","_parse","_callee3","operationResponse","opts","text","contentType","contentComponents","body","msg","errCode","e","_callee3$","_context3","get","split","map","component","toLowerCase","some","indexOf","JSON","Error","PARSE_ERROR"],"sources":["../../src/deserializationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  FullOperationResponse,\n  OperationRequest,\n  OperationResponseMap,\n  OperationSpec,\n  RequiredSerializerOptions,\n  SerializerOptions,\n  XML_CHARKEY,\n  XmlOptions,\n} from \"./interfaces\";\nimport {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  RestError,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\n\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n\n/**\n * Options to configure API response deserialization.\n */\nexport interface DeserializationPolicyOptions {\n  /**\n   * Configures the expected content types for the deserialization of\n   * JSON and XML response bodies.\n   */\n  expectedContentTypes?: DeserializationContentTypes;\n\n  /**\n   * A function that is able to parse XML. Required for XML support.\n   */\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>;\n\n  /**\n   * Configures behavior of xml parser and builder.\n   */\n  serializerOptions?: SerializerOptions;\n}\n\n/**\n * The content-types that will indicate that an operation response should be deserialized in a\n * particular way.\n */\nexport interface DeserializationContentTypes {\n  /**\n   * The content-types that indicate that an operation response should be deserialized as JSON.\n   * Defaults to [ \"application/json\", \"text/json\" ].\n   */\n  json?: string[];\n\n  /**\n   * The content-types that indicate that an operation response should be deserialized as XML.\n   * Defaults to [ \"application/xml\", \"application/atom+xml\" ].\n   */\n  xml?: string[];\n}\n\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options: DeserializationPolicyOptions = {}): PipelinePolicy {\n  const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;\n  const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions: RequiredSerializerOptions = {\n    xml: {\n      rootName: serializerOptions?.xml.rootName ?? \"\",\n      includeRoot: serializerOptions?.xml.includeRoot ?? false,\n      xmlCharKey: serializerOptions?.xml.xmlCharKey ?? XML_CHARKEY,\n    },\n  };\n\n  return {\n    name: deserializationPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return deserializeResponseBody(\n        jsonContentTypes,\n        xmlContentTypes,\n        response,\n        updatedOptions,\n        parseXML\n      );\n    },\n  };\n}\n\nfunction getOperationResponseMap(\n  parsedResponse: PipelineResponse\n): undefined | OperationResponseMap {\n  let result: OperationResponseMap | undefined;\n  const request: OperationRequest = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo?.operationSpec;\n  if (operationSpec) {\n    if (!operationInfo?.operationResponseGetter) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse: PipelineResponse): boolean {\n  const request: OperationRequest = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo?.shouldDeserialize;\n  let result: boolean;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\n\nasync function deserializeResponseBody(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  response: PipelineResponse,\n  options: RequiredSerializerOptions,\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>\n): Promise<PipelineResponse> {\n  const parsedResponse = await parse(\n    jsonContentTypes,\n    xmlContentTypes,\n    response,\n    options,\n    parseXML\n  );\n  if (!shouldDeserializeResponse(parsedResponse)) {\n    return parsedResponse;\n  }\n\n  const operationInfo = getOperationRequestInfo(parsedResponse.request);\n  const operationSpec = operationInfo?.operationSpec;\n  if (!operationSpec || !operationSpec.responses) {\n    return parsedResponse;\n  }\n\n  const responseSpec = getOperationResponseMap(parsedResponse);\n  const { error, shouldReturnResponse } = handleErrorResponse(\n    parsedResponse,\n    operationSpec,\n    responseSpec,\n    options\n  );\n  if (error) {\n    throw error;\n  } else if (shouldReturnResponse) {\n    return parsedResponse;\n  }\n\n  // An operation response spec does exist for current status code, so\n  // use it to deserialize the response.\n  if (responseSpec) {\n    if (responseSpec.bodyMapper) {\n      let valueToDeserialize: any = parsedResponse.parsedBody;\n      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n        valueToDeserialize =\n          typeof valueToDeserialize === \"object\"\n            ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName!]\n            : [];\n      }\n      try {\n        parsedResponse.parsedBody = operationSpec.serializer.deserialize(\n          responseSpec.bodyMapper,\n          valueToDeserialize,\n          \"operationRes.parsedBody\",\n          options\n        );\n      } catch (deserializeError: any) {\n        const restError = new RestError(\n          `Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`,\n          {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse,\n          }\n        );\n        throw restError;\n      }\n    } else if (operationSpec.httpMethod === \"HEAD\") {\n      // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n    }\n\n    if (responseSpec.headersMapper) {\n      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(\n        responseSpec.headersMapper,\n        parsedResponse.headers.toJSON(),\n        \"operationRes.parsedHeaders\",\n        { xml: {}, ignoreUnknownProperties: true }\n      );\n    }\n  }\n\n  return parsedResponse;\n}\n\nfunction isOperationSpecEmpty(operationSpec: OperationSpec): boolean {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return (\n    expectedStatusCodes.length === 0 ||\n    (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\")\n  );\n}\n\nfunction handleErrorResponse(\n  parsedResponse: FullOperationResponse,\n  operationSpec: OperationSpec,\n  responseSpec: OperationResponseMap | undefined,\n  options: RequiredSerializerOptions\n): { error: RestError | null; shouldReturnResponse: boolean } {\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode: boolean = isOperationSpecEmpty(operationSpec)\n    ? isSuccessByStatus\n    : !!responseSpec;\n\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return { error: null, shouldReturnResponse: false };\n      }\n    } else {\n      return { error: null, shouldReturnResponse: false };\n    }\n  }\n\n  const errorResponseSpec = responseSpec ?? operationSpec.responses.default;\n\n  const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(\n    parsedResponse.status\n  )\n    ? `Unexpected status code: ${parsedResponse.status}`\n    : (parsedResponse.bodyAsText as string);\n\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse,\n  });\n\n  // If the item failed but there's no error spec or default spec to deserialize the error,\n  // we should fail so we just throw the parsed response\n  if (!errorResponseSpec) {\n    throw error;\n  }\n\n  const defaultBodyMapper = errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec.headersMapper;\n\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n\n      if (defaultBodyMapper) {\n        let valueToDeserialize: any = parsedBody;\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n        deserializedError = operationSpec.serializer.deserialize(\n          defaultBodyMapper,\n          valueToDeserialize,\n          \"error.response.parsedBody\",\n          options\n        );\n      }\n\n      const internalError: any = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n\n      if (defaultBodyMapper) {\n        (error.response! as FullOperationResponse).parsedBody = deserializedError;\n      }\n    }\n\n    // If error response has headers, try to deserialize it using default header mapper\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      (error.response! as FullOperationResponse).parsedHeaders =\n        operationSpec.serializer.deserialize(\n          defaultHeadersMapper,\n          parsedResponse.headers.toJSON(),\n          \"operationRes.parsedHeaders\"\n        );\n    }\n  } catch (defaultError: any) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n\n  return { error, shouldReturnResponse: false };\n}\n\nasync function parse(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  operationResponse: FullOperationResponse,\n  opts: RequiredSerializerOptions,\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>\n): Promise<FullOperationResponse> {\n  if (\n    !operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) &&\n    operationResponse.bodyAsText\n  ) {\n    const text = operationResponse.bodyAsText;\n    const contentType: string = operationResponse.headers.get(\"Content-Type\") || \"\";\n    const contentComponents: string[] = !contentType\n      ? []\n      : contentType.split(\";\").map((component) => component.toLowerCase());\n\n    try {\n      if (\n        contentComponents.length === 0 ||\n        contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)\n      ) {\n        operationResponse.parsedBody = JSON.parse(text);\n        return operationResponse;\n      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n        if (!parseXML) {\n          throw new Error(\"Parsing XML not supported.\");\n        }\n        const body = await parseXML(text, opts.xml);\n        operationResponse.parsedBody = body;\n        return operationResponse;\n      }\n    } catch (err: any) {\n      const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n      const errCode = err.code || RestError.PARSE_ERROR;\n      const e = new RestError(msg, {\n        code: errCode,\n        statusCode: operationResponse.status,\n        request: operationResponse.request,\n        response: operationResponse,\n      });\n      throw e;\n    }\n  }\n\n  return operationResponse;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}