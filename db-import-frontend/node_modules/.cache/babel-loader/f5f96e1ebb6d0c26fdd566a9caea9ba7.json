{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n  return mapperTypeName !== \"Composite\" && mapperTypeName !== \"Dictionary\" && (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);\n}\nvar validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\nvar validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n  return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n  var combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n    return responseObject.shouldWrapBody ? {\n      body: null\n    } : null;\n  } else {\n    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), {\n      body: responseObject.body\n    }) : combinedHeadersAndBody;\n  }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n  var _a, _b;\n  var parsedHeaders = fullResponse.parsedHeaders;\n  // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n  if (fullResponse.request.method === \"HEAD\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      body: fullResponse.parsedBody\n    });\n  }\n  var bodyMapper = responseSpec && responseSpec.bodyMapper;\n  var isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n  var expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n  /** If the body is asked for, we look at the expected body type to handle it */\n  if (expectedBodyTypeName === \"Stream\") {\n    return Object.assign(Object.assign({}, parsedHeaders), {\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody\n    });\n  }\n  var modelProperties = expectedBodyTypeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n  var isPageableResponse = Object.keys(modelProperties).some(function (k) {\n    return modelProperties[k].serializedName === \"\";\n  });\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    var arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n    for (var _i = 0, _Object$keys = Object.keys(modelProperties); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n      }\n    }\n    if (parsedHeaders) {\n      for (var _i2 = 0, _Object$keys2 = Object.keys(parsedHeaders); _i2 < _Object$keys2.length; _i2++) {\n        var _key = _Object$keys2[_i2];\n        arrayResponse[_key] = parsedHeaders[_key];\n      }\n    }\n    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;\n  }\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)\n  });\n}","map":{"version":3,"names":["isPrimitiveBody","value","mapperTypeName","match","undefined","validateISODuration","isDuration","test","validUuidRegex","isValidUuid","uuid","handleNullableResponseAndWrappableBody","responseObject","combinedHeadersAndBody","Object","assign","headers","body","hasNullableType","getOwnPropertyNames","length","shouldWrapBody","flattenResponse","fullResponse","responseSpec","parsedHeaders","request","method","parsedBody","bodyMapper","isNullable","Boolean","nullable","expectedBodyTypeName","type","name","blobBody","readableStreamBody","modelProperties","isPageableResponse","keys","some","k","serializedName","arrayResponse","_a","_i","_Object$keys","key","_b","_i2","_Object$keys2"],"sources":["../../src/utils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CompositeMapper, FullOperationResponse, OperationResponseMap } from \"./interfaces\";\n\n/**\n * The union of all possible types for a primitive response body.\n * @internal\n */\nexport type BodyPrimitive = number | string | boolean | Date | Uint8Array | undefined | null;\n\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value: unknown, mapperTypeName?: string): value is BodyPrimitive {\n  return (\n    mapperTypeName !== \"Composite\" &&\n    mapperTypeName !== \"Dictionary\" &&\n    (typeof value === \"string\" ||\n      typeof value === \"number\" ||\n      typeof value === \"boolean\" ||\n      mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !==\n        null ||\n      value === undefined ||\n      value === null)\n  );\n}\n\nconst validateISODuration =\n  /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value: string): boolean {\n  return validateISODuration.test(value);\n}\n\nconst validUuidRegex =\n  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid: string): boolean {\n  return validUuidRegex.test(uuid);\n}\n\n/**\n * Representation of parsed response headers and body coupled with information\n * about how to map them:\n * - whether the response body should be wrapped (typically if its type is primitive).\n * - whether the response is nullable so it can be null if the combination of\n *   the headers and the body is empty.\n */\ninterface ResponseObjectWithMetadata {\n  /** whether the mapper allows nullable body */\n  hasNullableType: boolean;\n  /** whether the response's body should be wrapped */\n  shouldWrapBody: boolean;\n  /** parsed headers of the response */\n  headers:\n    | {\n        [key: string]: unknown;\n      }\n    | undefined;\n  /** parsed body of the response */\n  body: any;\n}\n\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(\n  responseObject: ResponseObjectWithMetadata\n): unknown | null {\n  const combinedHeadersAndBody = {\n    ...responseObject.headers,\n    ...responseObject.body,\n  };\n  if (\n    responseObject.hasNullableType &&\n    Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0\n  ) {\n    return responseObject.shouldWrapBody ? { body: null } : null;\n  } else {\n    return responseObject.shouldWrapBody\n      ? {\n          ...responseObject.headers,\n          body: responseObject.body,\n        }\n      : combinedHeadersAndBody;\n  }\n}\n\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(\n  fullResponse: FullOperationResponse,\n  responseSpec: OperationResponseMap | undefined\n): unknown {\n  const parsedHeaders = fullResponse.parsedHeaders;\n\n  // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n  if (fullResponse.request.method === \"HEAD\") {\n    return {\n      ...parsedHeaders,\n      body: fullResponse.parsedBody,\n    };\n  }\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const isNullable = Boolean(bodyMapper?.nullable);\n  const expectedBodyTypeName = bodyMapper?.type.name;\n\n  /** If the body is asked for, we look at the expected body type to handle it */\n  if (expectedBodyTypeName === \"Stream\") {\n    return {\n      ...parsedHeaders,\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody,\n    };\n  }\n\n  const modelProperties =\n    (expectedBodyTypeName === \"Composite\" &&\n      (bodyMapper as CompositeMapper).type.modelProperties) ||\n    {};\n  const isPageableResponse = Object.keys(modelProperties).some(\n    (k) => modelProperties[k].serializedName === \"\"\n  );\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    const arrayResponse: { [key: string]: unknown } =\n      fullResponse.parsedBody ?? ([] as unknown as { [key: string]: unknown });\n\n    for (const key of Object.keys(modelProperties)) {\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = fullResponse.parsedBody?.[key];\n      }\n    }\n\n    if (parsedHeaders) {\n      for (const key of Object.keys(parsedHeaders)) {\n        arrayResponse[key] = parsedHeaders[key];\n      }\n    }\n    return isNullable &&\n      !fullResponse.parsedBody &&\n      !parsedHeaders &&\n      Object.getOwnPropertyNames(modelProperties).length === 0\n      ? null\n      : arrayResponse;\n  }\n\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}