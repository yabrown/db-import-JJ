{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { tracingClient } from \"../util/tracing\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\n/**\n * @internal\n */\nexport var logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport var ChainedTokenCredential = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  function ChainedTokenCredential() {\n    _classCallCheck(this, ChainedTokenCredential);\n    /**\n     * The message to use when the chained token fails to get a token\n     */\n    this.UnavailableMessage = \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n    this._sources = [];\n    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n      sources[_key] = arguments[_key];\n    }\n    this._sources = sources;\n  }\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  _createClass(ChainedTokenCredential, [{\n    key: \"getToken\",\n    value: function () {\n      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(scopes) {\n        var _this = this;\n        var options,\n          token,\n          successfulCredentialName,\n          errors,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n              token = null;\n              successfulCredentialName = \"\";\n              errors = [];\n              return _context2.abrupt(\"return\", tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(updatedOptions) {\n                  var i, err;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        i = 0;\n                      case 1:\n                        if (!(i < _this._sources.length && token === null)) {\n                          _context.next = 20;\n                          break;\n                        }\n                        _context.prev = 2;\n                        _context.next = 5;\n                        return _this._sources[i].getToken(scopes, updatedOptions);\n                      case 5:\n                        token = _context.sent;\n                        successfulCredentialName = _this._sources[i].constructor.name;\n                        _context.next = 17;\n                        break;\n                      case 9:\n                        _context.prev = 9;\n                        _context.t0 = _context[\"catch\"](2);\n                        if (!(_context.t0.name === \"CredentialUnavailableError\" || _context.t0.name === \"AuthenticationRequiredError\")) {\n                          _context.next = 15;\n                          break;\n                        }\n                        errors.push(_context.t0);\n                        _context.next = 17;\n                        break;\n                      case 15:\n                        logger.getToken.info(formatError(scopes, _context.t0));\n                        throw _context.t0;\n                      case 17:\n                        i++;\n                        _context.next = 1;\n                        break;\n                      case 20:\n                        if (!(!token && errors.length > 0)) {\n                          _context.next = 24;\n                          break;\n                        }\n                        err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n                        logger.getToken.info(formatError(scopes, err));\n                        throw err;\n                      case 24:\n                        logger.getToken.info(\"Result for \".concat(successfulCredentialName, \": \").concat(formatSuccess(scopes)));\n                        if (!(token === null)) {\n                          _context.next = 27;\n                          break;\n                        }\n                        throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n                      case 27:\n                        return _context.abrupt(\"return\", token);\n                      case 28:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee, null, [[2, 9]]);\n                }));\n                return function (_x2) {\n                  return _ref.apply(this, arguments);\n                };\n              }()));\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function getToken(_x) {\n        return _getToken.apply(this, arguments);\n      }\n      return getToken;\n    }()\n  }]);\n  return ChainedTokenCredential;\n}();","map":{"version":3,"names":["AggregateAuthenticationError","CredentialUnavailableError","tracingClient","credentialLogger","formatError","formatSuccess","logger","ChainedTokenCredential","_classCallCheck","UnavailableMessage","_sources","_len","arguments","length","sources","Array","_key","_createClass","key","value","_getToken","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","scopes","_this","options","token","successfulCredentialName","errors","_args2","wrap","_callee2$","_context2","prev","next","undefined","abrupt","withSpan","_ref","_callee","updatedOptions","i","err","_callee$","_context","getToken","sent","constructor","name","t0","push","info","concat","stop","_x2","apply","_x"],"sources":["../../../src/credentials/chainedTokenCredential.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\n\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { tracingClient } from \"../util/tracing\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\n\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential implements TokenCredential {\n  /**\n   * The message to use when the chained token fails to get a token\n   */\n  protected UnavailableMessage =\n    \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n\n  private _sources: TokenCredential[] = [];\n\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources: TokenCredential[]) {\n    this._sources = sources;\n  }\n\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  async getToken(scopes: string | string[], options: GetTokenOptions = {}): Promise<AccessToken> {\n    let token: AccessToken | null = null;\n    let successfulCredentialName = \"\";\n    const errors: Error[] = [];\n\n    return tracingClient.withSpan(\n      \"ChainedTokenCredential.getToken\",\n      options,\n      async (updatedOptions) => {\n        for (let i = 0; i < this._sources.length && token === null; i++) {\n          try {\n            token = await this._sources[i].getToken(scopes, updatedOptions);\n            successfulCredentialName = this._sources[i].constructor.name;\n          } catch (err: any) {\n            if (\n              err.name === \"CredentialUnavailableError\" ||\n              err.name === \"AuthenticationRequiredError\"\n            ) {\n              errors.push(err);\n            } else {\n              logger.getToken.info(formatError(scopes, err));\n              throw err;\n            }\n          }\n        }\n\n        if (!token && errors.length > 0) {\n          const err = new AggregateAuthenticationError(\n            errors,\n            \"ChainedTokenCredential authentication failed.\"\n          );\n          logger.getToken.info(formatError(scopes, err));\n          throw err;\n        }\n\n        logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n\n        if (token === null) {\n          throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n        }\n        return token;\n      }\n    );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}