{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _get = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nvar assert = require('assert');\nvar Buffer = require('buffer').Buffer;\nvar realZlib = require('zlib');\nvar constants = exports.constants = require('./constants.js');\nvar Minipass = require('minipass');\nvar OriginalBufferConcat = Buffer.concat;\nvar _superWrite = Symbol('_superWrite');\nvar ZlibError = /*#__PURE__*/function (_Error) {\n  _inherits(ZlibError, _Error);\n  var _super = _createSuper(ZlibError);\n  function ZlibError(err) {\n    var _this;\n    _classCallCheck(this, ZlibError);\n    _this = _super.call(this, 'zlib: ' + err.message);\n    _this.code = err.code;\n    _this.errno = err.errno;\n    /* istanbul ignore if */\n    if (!_this.code) _this.code = 'ZLIB_ERROR';\n    _this.message = 'zlib: ' + err.message;\n    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);\n    return _this;\n  }\n  _createClass(ZlibError, [{\n    key: \"name\",\n    get: function get() {\n      return 'ZlibError';\n    }\n  }]);\n  return ZlibError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nvar _opts = Symbol('opts');\nvar _flushFlag = Symbol('flushFlag');\nvar _finishFlushFlag = Symbol('finishFlushFlag');\nvar _fullFlushFlag = Symbol('fullFlushFlag');\nvar _handle = Symbol('handle');\nvar _onError = Symbol('onError');\nvar _sawError = Symbol('sawError');\nvar _level = Symbol('level');\nvar _strategy = Symbol('strategy');\nvar _ended = Symbol('ended');\nvar _defaultFullFlush = Symbol('_defaultFullFlush');\nvar ZlibBase = /*#__PURE__*/function (_Minipass) {\n  _inherits(ZlibBase, _Minipass);\n  var _super2 = _createSuper(ZlibBase);\n  function ZlibBase(opts, mode) {\n    var _this2;\n    _classCallCheck(this, ZlibBase);\n    if (!opts || typeof opts !== 'object') throw new TypeError('invalid options for ZlibBase constructor');\n    _this2 = _super2.call(this, opts);\n    _this2[_sawError] = false;\n    _this2[_ended] = false;\n    _this2[_opts] = opts;\n    _this2[_flushFlag] = opts.flush;\n    _this2[_finishFlushFlag] = opts.finishFlush;\n    // this will throw if any options are invalid for the class selected\n    try {\n      _this2[_handle] = new realZlib[mode](opts);\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er);\n    }\n    _this2[_onError] = function (err) {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (_this2[_sawError]) return;\n      _this2[_sawError] = true;\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      _this2.close();\n      _this2.emit('error', err);\n    };\n    _this2[_handle].on('error', function (er) {\n      return _this2[_onError](new ZlibError(er));\n    });\n    _this2.once('end', function () {\n      return _this2.close;\n    });\n    return _this2;\n  }\n  _createClass(ZlibBase, [{\n    key: \"close\",\n    value: function close() {\n      if (this[_handle]) {\n        this[_handle].close();\n        this[_handle] = null;\n        this.emit('close');\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this[_sawError]) {\n        assert(this[_handle], 'zlib binding closed');\n        return this[_handle].reset();\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(flushFlag) {\n      if (this.ended) return;\n      if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];\n      this.write(Object.assign(Buffer.alloc(0), _defineProperty({}, _flushFlag, flushFlag)));\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (chunk) this.write(chunk, encoding);\n      this.flush(this[_finishFlushFlag]);\n      this[_ended] = true;\n      return _get(_getPrototypeOf(ZlibBase.prototype), \"end\", this).call(this, null, null, cb);\n    }\n  }, {\n    key: \"ended\",\n    get: function get() {\n      return this[_ended];\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      var _this3 = this;\n      // process the chunk using the sync process\n      // then super.write() all the outputted chunks\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n      if (this[_sawError]) return;\n      assert(this[_handle], 'zlib binding closed');\n\n      // _processChunk tries to .close() the native handle after it's done, so we\n      // intercept that by temporarily making it a no-op.\n      var nativeHandle = this[_handle]._handle;\n      var originalNativeClose = nativeHandle.close;\n      nativeHandle.close = function () {};\n      var originalClose = this[_handle].close;\n      this[_handle].close = function () {};\n      // It also calls `Buffer.concat()` at the end, which may be convenient\n      // for some, but which we are not interested in as it slows us down.\n      Buffer.concat = function (args) {\n        return args;\n      };\n      var result;\n      try {\n        var flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];\n        result = this[_handle]._processChunk(chunk, flushFlag);\n        // if we don't throw, reset it back how it was\n        Buffer.concat = OriginalBufferConcat;\n      } catch (err) {\n        // or if we do, put Buffer.concat() back before we emit error\n        // Error events call into user code, which may call Buffer.concat()\n        Buffer.concat = OriginalBufferConcat;\n        this[_onError](new ZlibError(err));\n      } finally {\n        if (this[_handle]) {\n          // Core zlib resets `_handle` to null after attempting to close the\n          // native handle. Our no-op handler prevented actual closure, but we\n          // need to restore the `._handle` property.\n          this[_handle]._handle = nativeHandle;\n          nativeHandle.close = originalNativeClose;\n          this[_handle].close = originalClose;\n          // `_processChunk()` adds an 'error' listener. If we don't remove it\n          // after each call, these handlers start piling up.\n          this[_handle].removeAllListeners('error');\n          // make sure OUR error listener is still attached tho\n        }\n      }\n\n      if (this[_handle]) this[_handle].on('error', function (er) {\n        return _this3[_onError](new ZlibError(er));\n      });\n      var writeReturn;\n      if (result) {\n        if (Array.isArray(result) && result.length > 0) {\n          // The first buffer is always `handle._outBuffer`, which would be\n          // re-used for later invocations; so, we always have to copy that one.\n          writeReturn = this[_superWrite](Buffer.from(result[0]));\n          for (var i = 1; i < result.length; i++) {\n            writeReturn = this[_superWrite](result[i]);\n          }\n        } else {\n          writeReturn = this[_superWrite](Buffer.from(result));\n        }\n      }\n      if (cb) cb();\n      return writeReturn;\n    }\n  }, {\n    key: _superWrite,\n    value: function value(data) {\n      return _get(_getPrototypeOf(ZlibBase.prototype), \"write\", this).call(this, data);\n    }\n  }]);\n  return ZlibBase;\n}(Minipass);\nvar Zlib = /*#__PURE__*/function (_ZlibBase) {\n  _inherits(Zlib, _ZlibBase);\n  var _super3 = _createSuper(Zlib);\n  function Zlib(opts, mode) {\n    var _this4;\n    _classCallCheck(this, Zlib);\n    opts = opts || {};\n    opts.flush = opts.flush || constants.Z_NO_FLUSH;\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;\n    _this4 = _super3.call(this, opts, mode);\n    _this4[_fullFlushFlag] = constants.Z_FULL_FLUSH;\n    _this4[_level] = opts.level;\n    _this4[_strategy] = opts.strategy;\n    return _this4;\n  }\n  _createClass(Zlib, [{\n    key: \"params\",\n    value: function params(level, strategy) {\n      var _this5 = this;\n      if (this[_sawError]) return;\n      if (!this[_handle]) throw new Error('cannot switch params when binding is closed');\n\n      // no way to test this without also not supporting params at all\n      /* istanbul ignore if */\n      if (!this[_handle].params) throw new Error('not supported in this implementation');\n      if (this[_level] !== level || this[_strategy] !== strategy) {\n        this.flush(constants.Z_SYNC_FLUSH);\n        assert(this[_handle], 'zlib binding closed');\n        // .params() calls .flush(), but the latter is always async in the\n        // core zlib. We override .flush() temporarily to intercept that and\n        // flush synchronously.\n        var origFlush = this[_handle].flush;\n        this[_handle].flush = function (flushFlag, cb) {\n          _this5.flush(flushFlag);\n          cb();\n        };\n        try {\n          this[_handle].params(level, strategy);\n        } finally {\n          this[_handle].flush = origFlush;\n        }\n        /* istanbul ignore else */\n        if (this[_handle]) {\n          this[_level] = level;\n          this[_strategy] = strategy;\n        }\n      }\n    }\n  }]);\n  return Zlib;\n}(ZlibBase); // minimal 2-byte header\nvar Deflate = /*#__PURE__*/function (_Zlib) {\n  _inherits(Deflate, _Zlib);\n  var _super4 = _createSuper(Deflate);\n  function Deflate(opts) {\n    _classCallCheck(this, Deflate);\n    return _super4.call(this, opts, 'Deflate');\n  }\n  return _createClass(Deflate);\n}(Zlib);\nvar Inflate = /*#__PURE__*/function (_Zlib2) {\n  _inherits(Inflate, _Zlib2);\n  var _super5 = _createSuper(Inflate);\n  function Inflate(opts) {\n    _classCallCheck(this, Inflate);\n    return _super5.call(this, opts, 'Inflate');\n  }\n  return _createClass(Inflate);\n}(Zlib); // gzip - bigger header, same deflate compression\nvar _portable = Symbol('_portable');\nvar Gzip = /*#__PURE__*/function (_Zlib3) {\n  _inherits(Gzip, _Zlib3);\n  var _super6 = _createSuper(Gzip);\n  function Gzip(opts) {\n    var _this6;\n    _classCallCheck(this, Gzip);\n    _this6 = _super6.call(this, opts, 'Gzip');\n    _this6[_portable] = opts && !!opts.portable;\n    return _this6;\n  }\n  _createClass(Gzip, [{\n    key: _superWrite,\n    value: function value(data) {\n      if (!this[_portable]) return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data);\n\n      // we'll always get the header emitted in one first chunk\n      // overwrite the OS indicator byte with 0xFF\n      this[_portable] = false;\n      data[9] = 255;\n      return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data);\n    }\n  }]);\n  return Gzip;\n}(Zlib);\nvar Gunzip = /*#__PURE__*/function (_Zlib4) {\n  _inherits(Gunzip, _Zlib4);\n  var _super7 = _createSuper(Gunzip);\n  function Gunzip(opts) {\n    _classCallCheck(this, Gunzip);\n    return _super7.call(this, opts, 'Gunzip');\n  }\n  return _createClass(Gunzip);\n}(Zlib); // raw - no header\nvar DeflateRaw = /*#__PURE__*/function (_Zlib5) {\n  _inherits(DeflateRaw, _Zlib5);\n  var _super8 = _createSuper(DeflateRaw);\n  function DeflateRaw(opts) {\n    _classCallCheck(this, DeflateRaw);\n    return _super8.call(this, opts, 'DeflateRaw');\n  }\n  return _createClass(DeflateRaw);\n}(Zlib);\nvar InflateRaw = /*#__PURE__*/function (_Zlib6) {\n  _inherits(InflateRaw, _Zlib6);\n  var _super9 = _createSuper(InflateRaw);\n  function InflateRaw(opts) {\n    _classCallCheck(this, InflateRaw);\n    return _super9.call(this, opts, 'InflateRaw');\n  }\n  return _createClass(InflateRaw);\n}(Zlib); // auto-detect header.\nvar Unzip = /*#__PURE__*/function (_Zlib7) {\n  _inherits(Unzip, _Zlib7);\n  var _super10 = _createSuper(Unzip);\n  function Unzip(opts) {\n    _classCallCheck(this, Unzip);\n    return _super10.call(this, opts, 'Unzip');\n  }\n  return _createClass(Unzip);\n}(Zlib);\nvar Brotli = /*#__PURE__*/function (_ZlibBase2) {\n  _inherits(Brotli, _ZlibBase2);\n  var _super11 = _createSuper(Brotli);\n  function Brotli(opts, mode) {\n    var _this7;\n    _classCallCheck(this, Brotli);\n    opts = opts || {};\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;\n    _this7 = _super11.call(this, opts, mode);\n    _this7[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;\n    return _this7;\n  }\n  return _createClass(Brotli);\n}(ZlibBase);\nvar BrotliCompress = /*#__PURE__*/function (_Brotli) {\n  _inherits(BrotliCompress, _Brotli);\n  var _super12 = _createSuper(BrotliCompress);\n  function BrotliCompress(opts) {\n    _classCallCheck(this, BrotliCompress);\n    return _super12.call(this, opts, 'BrotliCompress');\n  }\n  return _createClass(BrotliCompress);\n}(Brotli);\nvar BrotliDecompress = /*#__PURE__*/function (_Brotli2) {\n  _inherits(BrotliDecompress, _Brotli2);\n  var _super13 = _createSuper(BrotliDecompress);\n  function BrotliDecompress(opts) {\n    _classCallCheck(this, BrotliDecompress);\n    return _super13.call(this, opts, 'BrotliDecompress');\n  }\n  return _createClass(BrotliDecompress);\n}(Brotli);\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress;\n  exports.BrotliDecompress = BrotliDecompress;\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n      throw new Error('Brotli is not supported in this version of Node.js');\n    }\n    return _createClass(_class);\n  }();\n}","map":{"version":3,"names":["_defineProperty","require","default","_get","_getPrototypeOf","_classCallCheck","_createClass","_assertThisInitialized","_inherits","_createSuper","_wrapNativeSuper","assert","Buffer","realZlib","constants","exports","Minipass","OriginalBufferConcat","concat","_superWrite","Symbol","ZlibError","_Error","_super","err","_this","call","message","code","errno","Error","captureStackTrace","constructor","key","get","_opts","_flushFlag","_finishFlushFlag","_fullFlushFlag","_handle","_onError","_sawError","_level","_strategy","_ended","_defaultFullFlush","ZlibBase","_Minipass","_super2","opts","mode","_this2","TypeError","flush","finishFlush","er","close","emit","on","once","value","reset","flushFlag","ended","write","Object","assign","alloc","end","chunk","encoding","cb","prototype","_this3","from","nativeHandle","originalNativeClose","originalClose","args","result","_processChunk","removeAllListeners","writeReturn","Array","isArray","length","i","data","Zlib","_ZlibBase","_super3","_this4","Z_NO_FLUSH","Z_FINISH","Z_FULL_FLUSH","level","strategy","params","_this5","Z_SYNC_FLUSH","origFlush","Deflate","_Zlib","_super4","Inflate","_Zlib2","_super5","_portable","Gzip","_Zlib3","_super6","_this6","portable","Gunzip","_Zlib4","_super7","DeflateRaw","_Zlib5","_super8","InflateRaw","_Zlib6","_super9","Unzip","_Zlib7","_super10","Brotli","_ZlibBase2","_super11","_this7","BROTLI_OPERATION_PROCESS","BROTLI_OPERATION_FINISH","BROTLI_OPERATION_FLUSH","BrotliCompress","_Brotli","_super12","BrotliDecompress","_Brotli2","_super13","_class"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/minizlib/index.js"],"sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst Minipass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}