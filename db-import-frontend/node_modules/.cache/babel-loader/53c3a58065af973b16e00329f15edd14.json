{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _toConsumableArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar stream = require('stream');\nvar util = require('util');\nvar zlib = require('zlib');\nvar debug = require('debug')('nock.playback_interceptor');\nvar common = require('./common');\nfunction parseJSONRequestBody(req, requestBody) {\n  if (!requestBody || !common.isJSONContent(req.headers)) {\n    return requestBody;\n  }\n  if (common.contentEncoding(req.headers, 'gzip')) {\n    requestBody = String(zlib.gunzipSync(Buffer.from(requestBody, 'hex')));\n  } else if (common.contentEncoding(req.headers, 'deflate')) {\n    requestBody = String(zlib.inflateSync(Buffer.from(requestBody, 'hex')));\n  }\n  return JSON.parse(requestBody);\n}\nfunction parseFullReplyResult(response, fullReplyResult) {\n  var _response$rawHeaders;\n  debug('full response from callback result: %j', fullReplyResult);\n  if (!Array.isArray(fullReplyResult)) {\n    throw Error('A single function provided to .reply MUST return an array');\n  }\n  if (fullReplyResult.length > 3) {\n    throw Error('The array returned from the .reply callback contains too many values');\n  }\n  var _fullReplyResult = _slicedToArray(fullReplyResult, 3),\n    status = _fullReplyResult[0],\n    _fullReplyResult$ = _fullReplyResult[1],\n    body = _fullReplyResult$ === void 0 ? '' : _fullReplyResult$,\n    headers = _fullReplyResult[2];\n  if (!Number.isInteger(status)) {\n    throw new Error(\"Invalid \".concat(typeof status, \" value for status code\"));\n  }\n  response.statusCode = status;\n  (_response$rawHeaders = response.rawHeaders).push.apply(_response$rawHeaders, _toConsumableArray(common.headersInputToRawArray(headers)));\n  debug('response.rawHeaders after reply: %j', response.rawHeaders);\n  return body;\n}\n\n/**\n * Determine which of the default headers should be added to the response.\n *\n * Don't include any defaults whose case-insensitive keys are already on the response.\n */\nfunction selectDefaultHeaders(existingHeaders, defaultHeaders) {\n  if (!defaultHeaders.length) {\n    return []; // return early if we don't need to bother\n  }\n\n  var definedHeaders = new Set();\n  var result = [];\n  common.forEachHeader(existingHeaders, function (_, fieldName) {\n    definedHeaders.add(fieldName.toLowerCase());\n  });\n  common.forEachHeader(defaultHeaders, function (value, fieldName) {\n    if (!definedHeaders.has(fieldName.toLowerCase())) {\n      result.push(fieldName, value);\n    }\n  });\n  return result;\n}\n\n// Presents a list of Buffers as a Readable\nvar ReadableBuffers = /*#__PURE__*/function (_stream$Readable) {\n  _inherits(ReadableBuffers, _stream$Readable);\n  var _super = _createSuper(ReadableBuffers);\n  function ReadableBuffers(buffers) {\n    var _this;\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, ReadableBuffers);\n    _this = _super.call(this, opts);\n    _this.buffers = buffers;\n    return _this;\n  }\n  _createClass(ReadableBuffers, [{\n    key: \"_read\",\n    value: function _read(_size) {\n      while (this.buffers.length) {\n        if (!this.push(this.buffers.shift())) {\n          return;\n        }\n      }\n      this.push(null);\n    }\n  }]);\n  return ReadableBuffers;\n}(stream.Readable);\nfunction convertBodyToStream(body) {\n  if (common.isStream(body)) {\n    return body;\n  }\n  if (body === undefined) {\n    return new ReadableBuffers([]);\n  }\n  if (Buffer.isBuffer(body)) {\n    return new ReadableBuffers([body]);\n  }\n  if (typeof body !== 'string') {\n    body = JSON.stringify(body);\n  }\n  return new ReadableBuffers([Buffer.from(body)]);\n}\n\n/**\n * Play back an interceptor using the given request and mock response.\n */\nfunction playbackInterceptor(_ref) {\n  var req = _ref.req,\n    socket = _ref.socket,\n    options = _ref.options,\n    requestBodyString = _ref.requestBodyString,\n    requestBodyIsUtf8Representable = _ref.requestBodyIsUtf8Representable,\n    response = _ref.response,\n    interceptor = _ref.interceptor;\n  var logger = interceptor.scope.logger;\n  function start() {\n    req.headers = req.getHeaders();\n    interceptor.scope.emit('request', req, interceptor, requestBodyString);\n    if (typeof interceptor.errorMessage !== 'undefined') {\n      var error;\n      if (typeof interceptor.errorMessage === 'object') {\n        error = interceptor.errorMessage;\n      } else {\n        error = new Error(interceptor.errorMessage);\n      }\n      var delay = interceptor.delayBodyInMs + interceptor.delayConnectionInMs;\n      common.setTimeout(function () {\n        return req.destroy(error);\n      }, delay);\n      return;\n    }\n\n    // This will be null if we have a fullReplyFunction,\n    // in that case status code will be set in `parseFullReplyResult`\n    response.statusCode = interceptor.statusCode;\n\n    // Clone headers/rawHeaders to not override them when evaluating later\n    response.rawHeaders = _toConsumableArray(interceptor.rawHeaders);\n    logger('response.rawHeaders:', response.rawHeaders);\n\n    // TODO: MAJOR: Don't tack the request onto the interceptor.\n    // The only reason we do this is so that it's available inside reply functions.\n    // It would be better to pass the request as an argument to the functions instead.\n    // Not adding the req as a third arg now because it should first be decided if (path, body, req)\n    // is the signature we want to go with going forward.\n    interceptor.req = req;\n    if (interceptor.replyFunction) {\n      var parsedRequestBody = parseJSONRequestBody(req, requestBodyString);\n      var fn = interceptor.replyFunction;\n      if (fn.length === 3) {\n        // Handle the case of an async reply function, the third parameter being the callback.\n        fn = util.promisify(fn);\n      }\n\n      // At this point `fn` is either a synchronous function or a promise-returning function;\n      // wrapping in `Promise.resolve` makes it into a promise either way.\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody)).then(continueWithResponseBody).catch(function (err) {\n        return req.destroy(err);\n      });\n      return;\n    }\n    if (interceptor.fullReplyFunction) {\n      var _parsedRequestBody = parseJSONRequestBody(req, requestBodyString);\n      var _fn = interceptor.fullReplyFunction;\n      if (_fn.length === 3) {\n        _fn = util.promisify(_fn);\n      }\n      Promise.resolve(_fn.call(interceptor, options.path, _parsedRequestBody)).then(continueWithFullResponse).catch(function (err) {\n        return req.destroy(err);\n      });\n      return;\n    }\n    if (common.isContentEncoded(interceptor.headers) && !common.isStream(interceptor.body)) {\n      //  If the content is encoded we know that the response body *must* be an array\n      //  of response buffers which should be mocked one by one.\n      //  (otherwise decompressions after the first one fails as unzip expects to receive\n      //  buffer by buffer and not one single merged buffer)\n      var bufferData = Array.isArray(interceptor.body) ? interceptor.body : [interceptor.body];\n      var responseBuffers = bufferData.map(function (data) {\n        return Buffer.from(data, 'hex');\n      });\n      var _responseBody = new ReadableBuffers(responseBuffers);\n      continueWithResponseBody(_responseBody);\n      return;\n    }\n\n    // If we get to this point, the body is either a string or an object that\n    // will eventually be JSON stringified.\n    var responseBody = interceptor.body;\n\n    // If the request was not UTF8-representable then we assume that the\n    // response won't be either. In that case we send the response as a Buffer\n    // object as that's what the client will expect.\n    if (!requestBodyIsUtf8Representable && typeof responseBody === 'string') {\n      // Try to create the buffer from the interceptor's body response as hex.\n      responseBody = Buffer.from(responseBody, 'hex');\n\n      // Creating buffers does not necessarily throw errors; check for difference in size.\n      if (!responseBody || interceptor.body.length > 0 && responseBody.length === 0) {\n        // We fallback on constructing buffer from utf8 representation of the body.\n        responseBody = Buffer.from(interceptor.body, 'utf8');\n      }\n    }\n    return continueWithResponseBody(responseBody);\n  }\n  function continueWithFullResponse(fullReplyResult) {\n    var responseBody;\n    try {\n      responseBody = parseFullReplyResult(response, fullReplyResult);\n    } catch (err) {\n      req.destroy(err);\n      return;\n    }\n    continueWithResponseBody(responseBody);\n  }\n  function prepareResponseHeaders(body) {\n    var _response$rawHeaders2;\n    var defaultHeaders = _toConsumableArray(interceptor.scope._defaultReplyHeaders);\n\n    // Include a JSON content type when JSON.stringify is called on the body.\n    // This is a convenience added by Nock that has no analog in Node. It's added to the\n    // defaults, so it will be ignored if the caller explicitly provided the header already.\n    var isJSON = body !== undefined && typeof body !== 'string' && !Buffer.isBuffer(body) && !common.isStream(body);\n    if (isJSON) {\n      defaultHeaders.push('Content-Type', 'application/json');\n    }\n    (_response$rawHeaders2 = response.rawHeaders).push.apply(_response$rawHeaders2, _toConsumableArray(selectDefaultHeaders(response.rawHeaders, defaultHeaders)));\n\n    // Evaluate functional headers.\n    common.forEachHeader(response.rawHeaders, function (value, fieldName, i) {\n      if (typeof value === 'function') {\n        response.rawHeaders[i + 1] = value(req, response, body);\n      }\n    });\n    response.headers = common.headersArrayToObject(response.rawHeaders);\n  }\n  function continueWithResponseBody(rawBody) {\n    prepareResponseHeaders(rawBody);\n    var bodyAsStream = convertBodyToStream(rawBody);\n    bodyAsStream.pause();\n\n    // IncomingMessage extends Readable so we can't simply pipe.\n    bodyAsStream.on('data', function (chunk) {\n      response.push(chunk);\n    });\n    bodyAsStream.on('end', function () {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_message_complete\n      response.complete = true;\n      response.push(null);\n      interceptor.scope.emit('replied', req, interceptor);\n    });\n    bodyAsStream.on('error', function (err) {\n      response.emit('error', err);\n    });\n    var delayBodyInMs = interceptor.delayBodyInMs,\n      delayConnectionInMs = interceptor.delayConnectionInMs;\n    function respond() {\n      if (common.isRequestDestroyed(req)) {\n        return;\n      }\n\n      // Even though we've had the response object for awhile at this point,\n      // we only attach it to the request immediately before the `response`\n      // event because, as in Node, it alters the error handling around aborts.\n      req.res = response;\n      response.req = req;\n      logger('emitting response');\n      req.emit('response', response);\n      common.setTimeout(function () {\n        return bodyAsStream.resume();\n      }, delayBodyInMs);\n    }\n    socket.applyDelay(delayConnectionInMs);\n    common.setTimeout(respond, delayConnectionInMs);\n  }\n\n  // Calling `start` immediately could take the request all the way to the connection delay\n  // during a single microtask execution. This setImmediate stalls the playback to ensure the\n  // correct events are emitted first ('socket', 'finish') and any aborts in the queue or\n  // called during a 'finish' listener can be called.\n  common.setImmediate(function () {\n    if (!common.isRequestDestroyed(req)) {\n      start();\n    }\n  });\n}\nmodule.exports = {\n  playbackInterceptor: playbackInterceptor\n};","map":{"version":3,"names":["_classCallCheck","require","default","_createClass","_inherits","_createSuper","_toConsumableArray","_slicedToArray","stream","util","zlib","debug","common","parseJSONRequestBody","req","requestBody","isJSONContent","headers","contentEncoding","String","gunzipSync","Buffer","from","inflateSync","JSON","parse","parseFullReplyResult","response","fullReplyResult","_response$rawHeaders","Array","isArray","Error","length","_fullReplyResult","status","_fullReplyResult$","body","Number","isInteger","concat","statusCode","rawHeaders","push","apply","headersInputToRawArray","selectDefaultHeaders","existingHeaders","defaultHeaders","definedHeaders","Set","result","forEachHeader","_","fieldName","add","toLowerCase","value","has","ReadableBuffers","_stream$Readable","_super","buffers","_this","opts","arguments","undefined","call","key","_read","_size","shift","Readable","convertBodyToStream","isStream","isBuffer","stringify","playbackInterceptor","_ref","socket","options","requestBodyString","requestBodyIsUtf8Representable","interceptor","logger","scope","start","getHeaders","emit","errorMessage","error","delay","delayBodyInMs","delayConnectionInMs","setTimeout","destroy","replyFunction","parsedRequestBody","fn","promisify","Promise","resolve","path","then","continueWithResponseBody","catch","err","fullReplyFunction","continueWithFullResponse","isContentEncoded","bufferData","responseBuffers","map","data","responseBody","prepareResponseHeaders","_response$rawHeaders2","_defaultReplyHeaders","isJSON","i","headersArrayToObject","rawBody","bodyAsStream","pause","on","chunk","complete","respond","isRequestDestroyed","res","resume","applyDelay","setImmediate","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/nock/lib/playback_interceptor.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst zlib = require('zlib')\nconst debug = require('debug')('nock.playback_interceptor')\nconst common = require('./common')\n\nfunction parseJSONRequestBody(req, requestBody) {\n  if (!requestBody || !common.isJSONContent(req.headers)) {\n    return requestBody\n  }\n\n  if (common.contentEncoding(req.headers, 'gzip')) {\n    requestBody = String(zlib.gunzipSync(Buffer.from(requestBody, 'hex')))\n  } else if (common.contentEncoding(req.headers, 'deflate')) {\n    requestBody = String(zlib.inflateSync(Buffer.from(requestBody, 'hex')))\n  }\n\n  return JSON.parse(requestBody)\n}\n\nfunction parseFullReplyResult(response, fullReplyResult) {\n  debug('full response from callback result: %j', fullReplyResult)\n\n  if (!Array.isArray(fullReplyResult)) {\n    throw Error('A single function provided to .reply MUST return an array')\n  }\n\n  if (fullReplyResult.length > 3) {\n    throw Error(\n      'The array returned from the .reply callback contains too many values'\n    )\n  }\n\n  const [status, body = '', headers] = fullReplyResult\n\n  if (!Number.isInteger(status)) {\n    throw new Error(`Invalid ${typeof status} value for status code`)\n  }\n\n  response.statusCode = status\n  response.rawHeaders.push(...common.headersInputToRawArray(headers))\n  debug('response.rawHeaders after reply: %j', response.rawHeaders)\n\n  return body\n}\n\n/**\n * Determine which of the default headers should be added to the response.\n *\n * Don't include any defaults whose case-insensitive keys are already on the response.\n */\nfunction selectDefaultHeaders(existingHeaders, defaultHeaders) {\n  if (!defaultHeaders.length) {\n    return [] // return early if we don't need to bother\n  }\n\n  const definedHeaders = new Set()\n  const result = []\n\n  common.forEachHeader(existingHeaders, (_, fieldName) => {\n    definedHeaders.add(fieldName.toLowerCase())\n  })\n  common.forEachHeader(defaultHeaders, (value, fieldName) => {\n    if (!definedHeaders.has(fieldName.toLowerCase())) {\n      result.push(fieldName, value)\n    }\n  })\n\n  return result\n}\n\n// Presents a list of Buffers as a Readable\nclass ReadableBuffers extends stream.Readable {\n  constructor(buffers, opts = {}) {\n    super(opts)\n\n    this.buffers = buffers\n  }\n\n  _read(_size) {\n    while (this.buffers.length) {\n      if (!this.push(this.buffers.shift())) {\n        return\n      }\n    }\n    this.push(null)\n  }\n}\n\nfunction convertBodyToStream(body) {\n  if (common.isStream(body)) {\n    return body\n  }\n\n  if (body === undefined) {\n    return new ReadableBuffers([])\n  }\n\n  if (Buffer.isBuffer(body)) {\n    return new ReadableBuffers([body])\n  }\n\n  if (typeof body !== 'string') {\n    body = JSON.stringify(body)\n  }\n\n  return new ReadableBuffers([Buffer.from(body)])\n}\n\n/**\n * Play back an interceptor using the given request and mock response.\n */\nfunction playbackInterceptor({\n  req,\n  socket,\n  options,\n  requestBodyString,\n  requestBodyIsUtf8Representable,\n  response,\n  interceptor,\n}) {\n  const { logger } = interceptor.scope\n\n  function start() {\n    req.headers = req.getHeaders()\n\n    interceptor.scope.emit('request', req, interceptor, requestBodyString)\n\n    if (typeof interceptor.errorMessage !== 'undefined') {\n      let error\n      if (typeof interceptor.errorMessage === 'object') {\n        error = interceptor.errorMessage\n      } else {\n        error = new Error(interceptor.errorMessage)\n      }\n\n      const delay = interceptor.delayBodyInMs + interceptor.delayConnectionInMs\n      common.setTimeout(() => req.destroy(error), delay)\n      return\n    }\n\n    // This will be null if we have a fullReplyFunction,\n    // in that case status code will be set in `parseFullReplyResult`\n    response.statusCode = interceptor.statusCode\n\n    // Clone headers/rawHeaders to not override them when evaluating later\n    response.rawHeaders = [...interceptor.rawHeaders]\n    logger('response.rawHeaders:', response.rawHeaders)\n\n    // TODO: MAJOR: Don't tack the request onto the interceptor.\n    // The only reason we do this is so that it's available inside reply functions.\n    // It would be better to pass the request as an argument to the functions instead.\n    // Not adding the req as a third arg now because it should first be decided if (path, body, req)\n    // is the signature we want to go with going forward.\n    interceptor.req = req\n\n    if (interceptor.replyFunction) {\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n      let fn = interceptor.replyFunction\n      if (fn.length === 3) {\n        // Handle the case of an async reply function, the third parameter being the callback.\n        fn = util.promisify(fn)\n      }\n\n      // At this point `fn` is either a synchronous function or a promise-returning function;\n      // wrapping in `Promise.resolve` makes it into a promise either way.\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n        .then(continueWithResponseBody)\n        .catch(err => req.destroy(err))\n      return\n    }\n\n    if (interceptor.fullReplyFunction) {\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n      let fn = interceptor.fullReplyFunction\n      if (fn.length === 3) {\n        fn = util.promisify(fn)\n      }\n\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n        .then(continueWithFullResponse)\n        .catch(err => req.destroy(err))\n      return\n    }\n\n    if (\n      common.isContentEncoded(interceptor.headers) &&\n      !common.isStream(interceptor.body)\n    ) {\n      //  If the content is encoded we know that the response body *must* be an array\n      //  of response buffers which should be mocked one by one.\n      //  (otherwise decompressions after the first one fails as unzip expects to receive\n      //  buffer by buffer and not one single merged buffer)\n      const bufferData = Array.isArray(interceptor.body)\n        ? interceptor.body\n        : [interceptor.body]\n      const responseBuffers = bufferData.map(data => Buffer.from(data, 'hex'))\n      const responseBody = new ReadableBuffers(responseBuffers)\n      continueWithResponseBody(responseBody)\n      return\n    }\n\n    // If we get to this point, the body is either a string or an object that\n    // will eventually be JSON stringified.\n    let responseBody = interceptor.body\n\n    // If the request was not UTF8-representable then we assume that the\n    // response won't be either. In that case we send the response as a Buffer\n    // object as that's what the client will expect.\n    if (!requestBodyIsUtf8Representable && typeof responseBody === 'string') {\n      // Try to create the buffer from the interceptor's body response as hex.\n      responseBody = Buffer.from(responseBody, 'hex')\n\n      // Creating buffers does not necessarily throw errors; check for difference in size.\n      if (\n        !responseBody ||\n        (interceptor.body.length > 0 && responseBody.length === 0)\n      ) {\n        // We fallback on constructing buffer from utf8 representation of the body.\n        responseBody = Buffer.from(interceptor.body, 'utf8')\n      }\n    }\n\n    return continueWithResponseBody(responseBody)\n  }\n\n  function continueWithFullResponse(fullReplyResult) {\n    let responseBody\n    try {\n      responseBody = parseFullReplyResult(response, fullReplyResult)\n    } catch (err) {\n      req.destroy(err)\n      return\n    }\n\n    continueWithResponseBody(responseBody)\n  }\n\n  function prepareResponseHeaders(body) {\n    const defaultHeaders = [...interceptor.scope._defaultReplyHeaders]\n\n    // Include a JSON content type when JSON.stringify is called on the body.\n    // This is a convenience added by Nock that has no analog in Node. It's added to the\n    // defaults, so it will be ignored if the caller explicitly provided the header already.\n    const isJSON =\n      body !== undefined &&\n      typeof body !== 'string' &&\n      !Buffer.isBuffer(body) &&\n      !common.isStream(body)\n\n    if (isJSON) {\n      defaultHeaders.push('Content-Type', 'application/json')\n    }\n\n    response.rawHeaders.push(\n      ...selectDefaultHeaders(response.rawHeaders, defaultHeaders)\n    )\n\n    // Evaluate functional headers.\n    common.forEachHeader(response.rawHeaders, (value, fieldName, i) => {\n      if (typeof value === 'function') {\n        response.rawHeaders[i + 1] = value(req, response, body)\n      }\n    })\n\n    response.headers = common.headersArrayToObject(response.rawHeaders)\n  }\n\n  function continueWithResponseBody(rawBody) {\n    prepareResponseHeaders(rawBody)\n    const bodyAsStream = convertBodyToStream(rawBody)\n    bodyAsStream.pause()\n\n    // IncomingMessage extends Readable so we can't simply pipe.\n    bodyAsStream.on('data', function (chunk) {\n      response.push(chunk)\n    })\n    bodyAsStream.on('end', function () {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_message_complete\n      response.complete = true\n      response.push(null)\n\n      interceptor.scope.emit('replied', req, interceptor)\n    })\n    bodyAsStream.on('error', function (err) {\n      response.emit('error', err)\n    })\n\n    const { delayBodyInMs, delayConnectionInMs } = interceptor\n\n    function respond() {\n      if (common.isRequestDestroyed(req)) {\n        return\n      }\n\n      // Even though we've had the response object for awhile at this point,\n      // we only attach it to the request immediately before the `response`\n      // event because, as in Node, it alters the error handling around aborts.\n      req.res = response\n      response.req = req\n\n      logger('emitting response')\n      req.emit('response', response)\n\n      common.setTimeout(() => bodyAsStream.resume(), delayBodyInMs)\n    }\n\n    socket.applyDelay(delayConnectionInMs)\n    common.setTimeout(respond, delayConnectionInMs)\n  }\n\n  // Calling `start` immediately could take the request all the way to the connection delay\n  // during a single microtask execution. This setImmediate stalls the playback to ensure the\n  // correct events are emitted first ('socket', 'finish') and any aborts in the queue or\n  // called during a 'finish' listener can be called.\n  common.setImmediate(() => {\n    if (!common.isRequestDestroyed(req)) {\n      start()\n    }\n  })\n}\n\nmodule.exports = { playbackInterceptor }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}