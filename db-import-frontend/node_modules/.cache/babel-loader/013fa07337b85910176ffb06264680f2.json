{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar _ = require(\"lodash\");\nvar Utils = require(\"../../utils\");\nvar DataTypes = require(\"../../data-types\");\nvar TableHints = require(\"../../table-hints\");\nvar AbstractQueryGenerator = require(\"../abstract/query-generator\");\nvar randomBytes = require(\"crypto\").randomBytes;\nvar semver = require(\"semver\");\nvar Op = require(\"../../operators\");\nvar throwMethodUndefined = function throwMethodUndefined(methodName) {\n  throw new Error(\"The method \\\"\".concat(methodName, \"\\\" is not defined! Please add it to your sql dialect.\"));\n};\nvar MSSQLQueryGenerator = /*#__PURE__*/function (_AbstractQueryGenerat) {\n  _inherits(MSSQLQueryGenerator, _AbstractQueryGenerat);\n  var _super = _createSuper(MSSQLQueryGenerator);\n  function MSSQLQueryGenerator() {\n    _classCallCheck(this, MSSQLQueryGenerator);\n    return _super.apply(this, arguments);\n  }\n  _createClass(MSSQLQueryGenerator, [{\n    key: \"createDatabaseQuery\",\n    value: function createDatabaseQuery(databaseName, options) {\n      options = __spreadValues({\n        collate: null\n      }, options);\n      var collation = options.collate ? \"COLLATE \".concat(this.escape(options.collate)) : \"\";\n      return [\"IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =\", wrapSingleQuote(databaseName), \")\", \"BEGIN\", \"CREATE DATABASE\", this.quoteIdentifier(databaseName), \"\".concat(collation, \";\"), \"END;\"].join(\" \");\n    }\n  }, {\n    key: \"dropDatabaseQuery\",\n    value: function dropDatabaseQuery(databaseName) {\n      return [\"IF EXISTS (SELECT * FROM sys.databases WHERE name =\", wrapSingleQuote(databaseName), \")\", \"BEGIN\", \"DROP DATABASE\", this.quoteIdentifier(databaseName), \";\", \"END;\"].join(\" \");\n    }\n  }, {\n    key: \"createSchema\",\n    value: function createSchema(schema) {\n      return [\"IF NOT EXISTS (SELECT schema_name\", \"FROM information_schema.schemata\", \"WHERE schema_name =\", wrapSingleQuote(schema), \")\", \"BEGIN\", \"EXEC sp_executesql N'CREATE SCHEMA\", this.quoteIdentifier(schema), \";'\", \"END;\"].join(\" \");\n    }\n  }, {\n    key: \"dropSchema\",\n    value: function dropSchema(schema) {\n      var quotedSchema = wrapSingleQuote(schema);\n      return [\"IF EXISTS (SELECT schema_name\", \"FROM information_schema.schemata\", \"WHERE schema_name =\", quotedSchema, \")\", \"BEGIN\", \"DECLARE @id INT, @ms_sql NVARCHAR(2000);\", \"DECLARE @cascade TABLE (\", \"id INT NOT NULL IDENTITY PRIMARY KEY,\", \"ms_sql NVARCHAR(2000) NOT NULL );\", \"INSERT INTO @cascade ( ms_sql )\", \"SELECT CASE WHEN o.type IN ('F','PK')\", \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\", \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\", \"FROM sys.objects o\", \"JOIN sys.schemas s on o.schema_id = s.schema_id\", \"LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id\", \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema, \"ORDER BY o.type ASC;\", \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\", \"WHILE @id IS NOT NULL\", \"BEGIN\", \"BEGIN TRY EXEC sp_executesql @ms_sql; END TRY\", \"BEGIN CATCH BREAK; THROW; END CATCH;\", \"DELETE FROM @cascade WHERE id = @id;\", \"SELECT @id = NULL, @ms_sql = NULL;\", \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\", \"END\", \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\", \"END;\"].join(\" \");\n    }\n  }, {\n    key: \"showSchemasQuery\",\n    value: function showSchemasQuery() {\n      return ['SELECT \"name\" as \"schema_name\" FROM sys.schemas as s', 'WHERE \"s\".\"name\" NOT IN (', \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\", \")\", \"AND\", '\"s\".\"name\" NOT LIKE', \"'db_%'\"].join(\" \");\n    }\n  }, {\n    key: \"versionQuery\",\n    value: function versionQuery() {\n      return [\"DECLARE @ms_ver NVARCHAR(20);\", \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\", \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"].join(\" \");\n    }\n  }, {\n    key: \"createTableQuery\",\n    value: function createTableQuery(tableName, attributes, options) {\n      var _this = this;\n      var primaryKeys = [],\n        foreignKeys = {},\n        attributesClauseParts = [];\n      var commentStr = \"\";\n      for (var attr in attributes) {\n        if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n          var dataType = attributes[attr];\n          var match = void 0;\n          if (dataType.includes(\"COMMENT \")) {\n            var commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n            var commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n            commentStr += this.commentTemplate(commentText, tableName, attr);\n            dataType = commentMatch[1];\n          }\n          if (dataType.includes(\"PRIMARY KEY\")) {\n            primaryKeys.push(attr);\n            if (dataType.includes(\"REFERENCES\")) {\n              match = dataType.match(/^(.+) (REFERENCES.*)$/);\n              attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1].replace(\"PRIMARY KEY\", \"\")));\n              foreignKeys[attr] = match[2];\n            } else {\n              attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType.replace(\"PRIMARY KEY\", \"\")));\n            }\n          } else if (dataType.includes(\"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1]));\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType));\n          }\n        }\n      }\n      var pkString = primaryKeys.map(function (pk) {\n        return _this.quoteIdentifier(pk);\n      }).join(\", \");\n      if (options.uniqueKeys) {\n        _.each(options.uniqueKeys, function (columns, indexName) {\n          if (columns.customIndex) {\n            if (typeof indexName !== \"string\") {\n              indexName = \"uniq_\".concat(tableName, \"_\").concat(columns.fields.join(\"_\"));\n            }\n            attributesClauseParts.push(\"CONSTRAINT \".concat(_this.quoteIdentifier(indexName), \" UNIQUE (\").concat(columns.fields.map(function (field) {\n              return _this.quoteIdentifier(field);\n            }).join(\", \"), \")\"));\n          }\n        });\n      }\n      if (pkString.length > 0) {\n        attributesClauseParts.push(\"PRIMARY KEY (\".concat(pkString, \")\"));\n      }\n      for (var fkey in foreignKeys) {\n        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n          attributesClauseParts.push(\"FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]));\n        }\n      }\n      var quotedTableName = this.quoteTable(tableName);\n      return Utils.joinSQLFragments([\"IF OBJECT_ID('\".concat(quotedTableName, \"', 'U') IS NULL\"), \"CREATE TABLE \".concat(quotedTableName, \" (\").concat(attributesClauseParts.join(\", \"), \")\"), \";\", commentStr]);\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema) {\n      var sql = [\"SELECT\", \"c.COLUMN_NAME AS 'Name',\", \"c.DATA_TYPE AS 'Type',\", \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\", \"c.IS_NULLABLE as 'IsNull',\", \"COLUMN_DEFAULT AS 'Default',\", \"pk.CONSTRAINT_TYPE AS 'Constraint',\", \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\", \"CAST(prop.value AS NVARCHAR) AS 'Comment'\", \"FROM\", \"INFORMATION_SCHEMA.TABLES t\", \"INNER JOIN\", \"INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA\", \"LEFT JOIN (SELECT tc.table_schema, tc.table_name, \", \"cu.column_name, tc.CONSTRAINT_TYPE \", \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc \", \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu \", \"ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name \", \"and tc.constraint_name=cu.constraint_name \", \"and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk \", \"ON pk.table_schema=c.table_schema \", \"AND pk.table_name=c.table_name \", \"AND pk.column_name=c.column_name \", \"INNER JOIN sys.columns AS sc\", \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\", \"LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id\", \"AND prop.minor_id = sc.column_id\", \"AND prop.name = 'MS_Description'\", \"WHERE t.TABLE_NAME =\", wrapSingleQuote(tableName)].join(\" \");\n      if (schema) {\n        sql += \"AND t.TABLE_SCHEMA =\".concat(wrapSingleQuote(schema));\n      }\n      return sql;\n    }\n  }, {\n    key: \"renameTableQuery\",\n    value: function renameTableQuery(before, after) {\n      return \"EXEC sp_rename \".concat(this.quoteTable(before), \", \").concat(this.quoteTable(after), \";\");\n    }\n  }, {\n    key: \"showTablesQuery\",\n    value: function showTablesQuery() {\n      return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n    }\n  }, {\n    key: \"tableExistsQuery\",\n    value: function tableExistsQuery(table) {\n      var tableName = table.tableName || table;\n      var schemaName = table.schema || \"dbo\";\n      return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = \".concat(this.escape(tableName), \" AND TABLE_SCHEMA = \").concat(this.escape(schemaName));\n    }\n  }, {\n    key: \"dropTableQuery\",\n    value: function dropTableQuery(tableName) {\n      var quoteTbl = this.quoteTable(tableName);\n      return Utils.joinSQLFragments([\"IF OBJECT_ID('\".concat(quoteTbl, \"', 'U') IS NOT NULL\"), \"DROP TABLE\", quoteTbl, \";\"]);\n    }\n  }, {\n    key: \"addColumnQuery\",\n    value: function addColumnQuery(table, key, dataType) {\n      dataType.field = key;\n      var commentStr = \"\";\n      if (dataType.comment && _.isString(dataType.comment)) {\n        commentStr = this.commentTemplate(dataType.comment, table, key);\n        delete dataType[\"comment\"];\n      }\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n        context: \"addColumn\"\n      }), \";\", commentStr]);\n    }\n  }, {\n    key: \"commentTemplate\",\n    value: function commentTemplate(comment, table, column) {\n      return \" EXEC sp_addextendedproperty @name = N'MS_Description', @value = \".concat(this.escape(comment), \", @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = \").concat(this.quoteIdentifier(table), \", @level2type = N'Column', @level2name = \").concat(this.quoteIdentifier(column), \";\");\n    }\n  }, {\n    key: \"removeColumnQuery\",\n    value: function removeColumnQuery(tableName, attributeName) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP COLUMN\", this.quoteIdentifier(attributeName), \";\"]);\n    }\n  }, {\n    key: \"changeColumnQuery\",\n    value: function changeColumnQuery(tableName, attributes) {\n      var attrString = [],\n        constraintString = [];\n      var commentString = \"\";\n      for (var attributeName in attributes) {\n        var quotedAttrName = this.quoteIdentifier(attributeName);\n        var definition = attributes[attributeName];\n        if (definition.includes(\"COMMENT \")) {\n          var commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n          var commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n          commentString += this.commentTemplate(commentText, tableName, attributeName);\n          definition = commentMatch[1];\n        }\n        if (definition.includes(\"REFERENCES\")) {\n          constraintString.push(\"FOREIGN KEY (\".concat(quotedAttrName, \") \").concat(definition.replace(/.+?(?=REFERENCES)/, \"\")));\n        } else {\n          attrString.push(\"\".concat(quotedAttrName, \" \").concat(definition));\n        }\n      }\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), attrString.length && \"ALTER COLUMN \".concat(attrString.join(\", \")), constraintString.length && \"ADD \".concat(constraintString.join(\", \")), \";\", commentString]);\n    }\n  }, {\n    key: \"renameColumnQuery\",\n    value: function renameColumnQuery(tableName, attrBefore, attributes) {\n      var newName = Object.keys(attributes)[0];\n      return Utils.joinSQLFragments([\"EXEC sp_rename\", \"'\".concat(this.quoteTable(tableName), \".\").concat(attrBefore, \"',\"), \"'\".concat(newName, \"',\"), \"'COLUMN'\", \";\"]);\n    }\n  }, {\n    key: \"bulkInsertQuery\",\n    value: function bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n      var _this2 = this;\n      var quotedTable = this.quoteTable(tableName);\n      options = options || {};\n      attributes = attributes || {};\n      var tuples = [];\n      var allAttributes = [];\n      var allQueries = [];\n      var needIdentityInsertWrapper = false,\n        outputFragment = \"\";\n      if (options.returning) {\n        var returnValues = this.generateReturnValues(attributes, options);\n        outputFragment = returnValues.outputFragment;\n      }\n      var emptyQuery = \"INSERT INTO \".concat(quotedTable).concat(outputFragment, \" DEFAULT VALUES\");\n      attrValueHashes.forEach(function (attrValueHash) {\n        var fields = Object.keys(attrValueHash);\n        var firstAttr = attributes[fields[0]];\n        if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n          allQueries.push(emptyQuery);\n          return;\n        }\n        _.forOwn(attrValueHash, function (value, key) {\n          if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n            needIdentityInsertWrapper = true;\n          }\n          if (!allAttributes.includes(key)) {\n            if (value === null && attributes[key] && attributes[key].autoIncrement) return;\n            allAttributes.push(key);\n          }\n        });\n      });\n      if (allAttributes.length > 0) {\n        attrValueHashes.forEach(function (attrValueHash) {\n          tuples.push(\"(\".concat(allAttributes.map(function (key) {\n            return _this2.escape(attrValueHash[key]);\n          }).join(\",\"), \")\"));\n        });\n        var quotedAttributes = allAttributes.map(function (attr) {\n          return _this2.quoteIdentifier(attr);\n        }).join(\",\");\n        allQueries.push(function (tupleStr) {\n          return \"INSERT INTO \".concat(quotedTable, \" (\").concat(quotedAttributes, \")\").concat(outputFragment, \" VALUES \").concat(tupleStr, \";\");\n        });\n      }\n      var commands = [];\n      var offset = 0;\n      var batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n      var _loop = function _loop() {\n        var tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n        var generatedQuery = allQueries.map(function (v) {\n          return typeof v === \"string\" ? v : v(tupleStr);\n        }).join(\";\");\n        if (needIdentityInsertWrapper) {\n          generatedQuery = \"SET IDENTITY_INSERT \".concat(quotedTable, \" ON; \").concat(generatedQuery, \"; SET IDENTITY_INSERT \").concat(quotedTable, \" OFF;\");\n        }\n        commands.push(generatedQuery);\n        offset += batch;\n      };\n      while (offset < Math.max(tuples.length, 1)) {\n        _loop();\n      }\n      return commands.join(\";\");\n    }\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {\n      var sql = _get(_getPrototypeOf(MSSQLQueryGenerator.prototype), \"updateQuery\", this).call(this, tableName, attrValueHash, where, options, attributes);\n      if (options.limit) {\n        var updateArgs = \"UPDATE TOP(\".concat(this.escape(options.limit), \")\");\n        sql.query = sql.query.replace(\"UPDATE\", updateArgs);\n      }\n      return sql;\n    }\n  }, {\n    key: \"upsertQuery\",\n    value: function upsertQuery(tableName, insertValues, updateValues, where, model) {\n      var _this3 = this;\n      var targetTableAlias = this.quoteTable(\"\".concat(tableName, \"_target\"));\n      var sourceTableAlias = this.quoteTable(\"\".concat(tableName, \"_source\"));\n      var primaryKeysAttrs = [];\n      var identityAttrs = [];\n      var uniqueAttrs = [];\n      var tableNameQuoted = this.quoteTable(tableName);\n      var needIdentityInsertWrapper = false;\n      for (var key in model.rawAttributes) {\n        if (model.rawAttributes[key].primaryKey) {\n          primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n        }\n        if (model.rawAttributes[key].unique) {\n          uniqueAttrs.push(model.rawAttributes[key].field || key);\n        }\n        if (model.rawAttributes[key].autoIncrement) {\n          identityAttrs.push(model.rawAttributes[key].field || key);\n        }\n      }\n      var _iterator2 = _createForOfIteratorHelper(model._indexes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var index = _step2.value;\n          if (index.unique && index.fields) {\n            var _iterator3 = _createForOfIteratorHelper(index.fields),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var field = _step3.value;\n                var fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n                if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n                  uniqueAttrs.push(fieldName);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var updateKeys = Object.keys(updateValues);\n      var insertKeys = Object.keys(insertValues);\n      var insertKeysQuoted = insertKeys.map(function (key) {\n        return _this3.quoteIdentifier(key);\n      }).join(\", \");\n      var insertValuesEscaped = insertKeys.map(function (key) {\n        return _this3.escape(insertValues[key]);\n      }).join(\", \");\n      var sourceTableQuery = \"VALUES(\".concat(insertValuesEscaped, \")\");\n      var joinCondition;\n      identityAttrs.forEach(function (key) {\n        if (insertValues[key] && insertValues[key] !== null) {\n          needIdentityInsertWrapper = true;\n        }\n      });\n      var clauses = where[Op.or].filter(function (clause) {\n        var valid = true;\n        for (var _key in clause) {\n          if (typeof clause[_key] === \"undefined\" || clause[_key] == null) {\n            valid = false;\n            break;\n          }\n        }\n        return valid;\n      });\n      var getJoinSnippet = function getJoinSnippet(array) {\n        return array.map(function (key) {\n          key = _this3.quoteIdentifier(key);\n          return \"\".concat(targetTableAlias, \".\").concat(key, \" = \").concat(sourceTableAlias, \".\").concat(key);\n        });\n      };\n      if (clauses.length === 0) {\n        throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n      } else {\n        for (var _key2 in clauses) {\n          var keys = Object.keys(clauses[_key2]);\n          if (primaryKeysAttrs.includes(keys[0])) {\n            joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n            break;\n          }\n        }\n        if (!joinCondition) {\n          joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n        }\n      }\n      var filteredUpdateClauses = updateKeys.filter(function (key) {\n        return !identityAttrs.includes(key);\n      }).map(function (key) {\n        var value = _this3.escape(updateValues[key]);\n        key = _this3.quoteIdentifier(key);\n        return \"\".concat(targetTableAlias, \".\").concat(key, \" = \").concat(value);\n      });\n      var updateSnippet = filteredUpdateClauses.length > 0 ? \"WHEN MATCHED THEN UPDATE SET \".concat(filteredUpdateClauses.join(\", \")) : \"\";\n      var insertSnippet = \"(\".concat(insertKeysQuoted, \") VALUES(\").concat(insertValuesEscaped, \")\");\n      var query = \"MERGE INTO \".concat(tableNameQuoted, \" WITH(HOLDLOCK) AS \").concat(targetTableAlias, \" USING (\").concat(sourceTableQuery, \") AS \").concat(sourceTableAlias, \"(\").concat(insertKeysQuoted, \") ON \").concat(joinCondition);\n      query += \" \".concat(updateSnippet, \" WHEN NOT MATCHED THEN INSERT \").concat(insertSnippet, \" OUTPUT $action, INSERTED.*;\");\n      if (needIdentityInsertWrapper) {\n        query = \"SET IDENTITY_INSERT \".concat(tableNameQuoted, \" ON; \").concat(query, \" SET IDENTITY_INSERT \").concat(tableNameQuoted, \" OFF;\");\n      }\n      return query;\n    }\n  }, {\n    key: \"truncateTableQuery\",\n    value: function truncateTableQuery(tableName) {\n      return \"TRUNCATE TABLE \".concat(this.quoteTable(tableName));\n    }\n  }, {\n    key: \"deleteQuery\",\n    value: function deleteQuery(tableName, where) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var model = arguments.length > 3 ? arguments[3] : undefined;\n      var table = this.quoteTable(tableName);\n      var whereClause = this.getWhereConditions(where, null, model, options);\n      return Utils.joinSQLFragments([\"DELETE\", options.limit && \"TOP(\".concat(this.escape(options.limit), \")\"), \"FROM\", table, whereClause && \"WHERE \".concat(whereClause), \";\", \"SELECT @@ROWCOUNT AS AFFECTEDROWS\", \";\"]);\n    }\n  }, {\n    key: \"showIndexesQuery\",\n    value: function showIndexesQuery(tableName) {\n      return \"EXEC sys.sp_helpindex @objname = N'\".concat(this.quoteTable(tableName), \"';\");\n    }\n  }, {\n    key: \"showConstraintsQuery\",\n    value: function showConstraintsQuery(tableName) {\n      return \"EXEC sp_helpconstraint @objname = \".concat(this.escape(this.quoteTable(tableName)), \";\");\n    }\n  }, {\n    key: \"removeIndexQuery\",\n    value: function removeIndexQuery(tableName, indexNameOrAttributes) {\n      var indexName = indexNameOrAttributes;\n      if (typeof indexName !== \"string\") {\n        indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join(\"_\")));\n      }\n      return \"DROP INDEX \".concat(this.quoteIdentifiers(indexName), \" ON \").concat(this.quoteIdentifiers(tableName));\n    }\n  }, {\n    key: \"attributeToSQL\",\n    value: function attributeToSQL(attribute, options) {\n      var _this4 = this;\n      if (!_.isPlainObject(attribute)) {\n        attribute = {\n          type: attribute\n        };\n      }\n      if (attribute.references) {\n        if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n          this.sequelize.log(\"MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        }\n      }\n      var template;\n      if (attribute.type instanceof DataTypes.ENUM) {\n        if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n        template = attribute.type.toSql();\n        template += \" CHECK (\".concat(this.quoteIdentifier(attribute.field), \" IN(\").concat(attribute.values.map(function (value) {\n          return _this4.escape(value);\n        }).join(\", \"), \"))\");\n        return template;\n      }\n      template = attribute.type.toString();\n      if (attribute.allowNull === false) {\n        template += \" NOT NULL\";\n      } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += \" NULL\";\n      }\n      if (attribute.autoIncrement) {\n        template += \" IDENTITY(1,1)\";\n      }\n      if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n      }\n      if (attribute.unique === true) {\n        template += \" UNIQUE\";\n      }\n      if (attribute.primaryKey) {\n        template += \" PRIMARY KEY\";\n      }\n      if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n        template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n        if (attribute.references.key) {\n          template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n        } else {\n          template += \" (\".concat(this.quoteIdentifier(\"id\"), \")\");\n        }\n        if (attribute.onDelete) {\n          template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n        }\n        if (attribute.onUpdate) {\n          template += \" ON UPDATE \".concat(attribute.onUpdate.toUpperCase());\n        }\n      }\n      if (attribute.comment && typeof attribute.comment === \"string\") {\n        template += \" COMMENT \".concat(attribute.comment);\n      }\n      return template;\n    }\n  }, {\n    key: \"attributesToSQL\",\n    value: function attributesToSQL(attributes, options) {\n      var result = {},\n        existingConstraints = [];\n      var key, attribute;\n      for (key in attributes) {\n        attribute = attributes[key];\n        if (attribute.references) {\n          if (existingConstraints.includes(attribute.references.model.toString())) {\n            attribute.onDelete = \"\";\n            attribute.onUpdate = \"\";\n          } else {\n            existingConstraints.push(attribute.references.model.toString());\n            attribute.onUpdate = \"\";\n          }\n        }\n        if (key && !attribute.field) attribute.field = key;\n        result[attribute.field || key] = this.attributeToSQL(attribute, options);\n      }\n      return result;\n    }\n  }, {\n    key: \"createTrigger\",\n    value: function createTrigger() {\n      throwMethodUndefined(\"createTrigger\");\n    }\n  }, {\n    key: \"dropTrigger\",\n    value: function dropTrigger() {\n      throwMethodUndefined(\"dropTrigger\");\n    }\n  }, {\n    key: \"renameTrigger\",\n    value: function renameTrigger() {\n      throwMethodUndefined(\"renameTrigger\");\n    }\n  }, {\n    key: \"createFunction\",\n    value: function createFunction() {\n      throwMethodUndefined(\"createFunction\");\n    }\n  }, {\n    key: \"dropFunction\",\n    value: function dropFunction() {\n      throwMethodUndefined(\"dropFunction\");\n    }\n  }, {\n    key: \"renameFunction\",\n    value: function renameFunction() {\n      throwMethodUndefined(\"renameFunction\");\n    }\n  }, {\n    key: \"_getForeignKeysQueryPrefix\",\n    value: function _getForeignKeysQueryPrefix(catalogName) {\n      return \"SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, \".concat(catalogName ? \"constraintCatalog = '\".concat(catalogName, \"', \") : \"\", \"constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), \").concat(catalogName ? \"tableCatalog = '\".concat(catalogName, \"', \") : \"\", \"columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), \").concat(catalogName ? \"referencedCatalog = '\".concat(catalogName, \"', \") : \"\", \"referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID\");\n    }\n  }, {\n    key: \"getForeignKeysQuery\",\n    value: function getForeignKeysQuery(table, catalogName) {\n      var tableName = table.tableName || table;\n      var sql = \"\".concat(this._getForeignKeysQueryPrefix(catalogName), \" WHERE TB.NAME =\").concat(wrapSingleQuote(tableName));\n      if (table.schema) {\n        sql += \" AND SCHEMA_NAME(TB.SCHEMA_ID) =\".concat(wrapSingleQuote(table.schema));\n      }\n      return sql;\n    }\n  }, {\n    key: \"getForeignKeyQuery\",\n    value: function getForeignKeyQuery(table, attributeName) {\n      var tableName = table.tableName || table;\n      return Utils.joinSQLFragments([this._getForeignKeysQueryPrefix(), \"WHERE\", \"TB.NAME =\".concat(wrapSingleQuote(tableName)), \"AND\", \"COL.NAME =\".concat(wrapSingleQuote(attributeName)), table.schema && \"AND SCHEMA_NAME(TB.SCHEMA_ID) =\".concat(wrapSingleQuote(table.schema))]);\n    }\n  }, {\n    key: \"getPrimaryKeyConstraintQuery\",\n    value: function getPrimaryKeyConstraintQuery(table, attributeName) {\n      var tableName = wrapSingleQuote(table.tableName || table);\n      return Utils.joinSQLFragments([\"SELECT K.TABLE_NAME AS tableName,\", \"K.COLUMN_NAME AS columnName,\", \"K.CONSTRAINT_NAME AS constraintName\", \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C\", \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K\", \"ON C.TABLE_NAME = K.TABLE_NAME\", \"AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG\", \"AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA\", \"AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME\", \"WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'\", \"AND K.COLUMN_NAME = \".concat(wrapSingleQuote(attributeName)), \"AND K.TABLE_NAME = \".concat(tableName), \";\"]);\n    }\n  }, {\n    key: \"dropForeignKeyQuery\",\n    value: function dropForeignKeyQuery(tableName, foreignKey) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(foreignKey)]);\n    }\n  }, {\n    key: \"getDefaultConstraintQuery\",\n    value: function getDefaultConstraintQuery(tableName, attributeName) {\n      var quotedTable = this.quoteTable(tableName);\n      return Utils.joinSQLFragments([\"SELECT name FROM sys.default_constraints\", \"WHERE PARENT_OBJECT_ID = OBJECT_ID('\".concat(quotedTable, \"', 'U')\"), \"AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('\".concat(attributeName, \"')\"), \"AND object_id = OBJECT_ID('\".concat(quotedTable, \"', 'U'))\"), \";\"]);\n    }\n  }, {\n    key: \"dropConstraintQuery\",\n    value: function dropConstraintQuery(tableName, constraintName) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP CONSTRAINT\", this.quoteIdentifier(constraintName), \";\"]);\n    }\n  }, {\n    key: \"setIsolationLevelQuery\",\n    value: function setIsolationLevelQuery() {}\n  }, {\n    key: \"generateTransactionId\",\n    value: function generateTransactionId() {\n      return randomBytes(10).toString(\"hex\");\n    }\n  }, {\n    key: \"startTransactionQuery\",\n    value: function startTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return \"SAVE TRANSACTION \".concat(this.quoteIdentifier(transaction.name), \";\");\n      }\n      return \"BEGIN TRANSACTION;\";\n    }\n  }, {\n    key: \"commitTransactionQuery\",\n    value: function commitTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return;\n      }\n      return \"COMMIT TRANSACTION;\";\n    }\n  }, {\n    key: \"rollbackTransactionQuery\",\n    value: function rollbackTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return \"ROLLBACK TRANSACTION \".concat(this.quoteIdentifier(transaction.name), \";\");\n      }\n      return \"ROLLBACK TRANSACTION;\";\n    }\n  }, {\n    key: \"selectFromTableFragment\",\n    value: function selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n      this._throwOnEmptyAttributes(attributes, {\n        modelName: model && model.name,\n        as: mainTableAs\n      });\n      var dbVersion = this.sequelize.options.databaseVersion;\n      var isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, \"11.0.0\");\n      if (isSQLServer2008 && options.offset) {\n        var offset = options.offset || 0;\n        var isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n        var orders = {\n          mainQueryOrder: []\n        };\n        if (options.order) {\n          orders = this.getQueryOrders(options, model, isSubQuery);\n        }\n        if (orders.mainQueryOrder.length === 0) {\n          orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n        }\n        var tmpTable = mainTableAs || \"OffsetTable\";\n        if (options.include) {\n          var subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;\n          var mainTable = {\n            name: mainTableAs,\n            quotedName: null,\n            as: null,\n            model: model\n          };\n          var topLevelInfo = {\n            names: mainTable,\n            options: options,\n            subQuery: subQuery\n          };\n          var mainJoinQueries = [];\n          var _iterator4 = _createForOfIteratorHelper(options.include),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var include = _step4.value;\n              if (include.separate) {\n                continue;\n              }\n              var joinQueries = this.generateInclude(include, {\n                externalAs: mainTableAs,\n                internalAs: mainTableAs\n              }, topLevelInfo);\n              mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          return Utils.joinSQLFragments([\"SELECT TOP 100 PERCENT\", attributes.join(\", \"), \"FROM (\", [\"SELECT\", options.limit && \"TOP \".concat(options.limit), \"* FROM (\", [\"SELECT ROW_NUMBER() OVER (\", [\"ORDER BY\", orders.mainQueryOrder.join(\", \")], \") as row_num, \".concat(tmpTable, \".* FROM (\"), [\"SELECT DISTINCT\", \"\".concat(tmpTable, \".* FROM \").concat(tables, \" AS \").concat(tmpTable), mainJoinQueries, where && \"WHERE \".concat(where)], \") AS \".concat(tmpTable)], \") AS \".concat(tmpTable, \" WHERE row_num > \").concat(offset)], \") AS \".concat(tmpTable)]);\n        }\n        return Utils.joinSQLFragments([\"SELECT TOP 100 PERCENT\", attributes.join(\", \"), \"FROM (\", [\"SELECT\", options.limit && \"TOP \".concat(options.limit), \"* FROM (\", [\"SELECT ROW_NUMBER() OVER (\", [\"ORDER BY\", orders.mainQueryOrder.join(\", \")], \") as row_num, * FROM \".concat(tables, \" AS \").concat(tmpTable), where && \"WHERE \".concat(where)], \") AS \".concat(tmpTable, \" WHERE row_num > \").concat(offset)], \") AS \".concat(tmpTable)]);\n      }\n      return Utils.joinSQLFragments([\"SELECT\", isSQLServer2008 && options.limit && \"TOP \".concat(options.limit), attributes.join(\", \"), \"FROM \".concat(tables), mainTableAs && \"AS \".concat(mainTableAs), options.tableHint && TableHints[options.tableHint] && \"WITH (\".concat(TableHints[options.tableHint], \")\")]);\n    }\n  }, {\n    key: \"addLimitAndOffset\",\n    value: function addLimitAndOffset(options, model) {\n      if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, \"11.0.0\")) {\n        return \"\";\n      }\n      var offset = options.offset || 0;\n      var isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n      var fragment = \"\";\n      var orders = {};\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n      if (options.limit || options.offset) {\n        if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n          var primaryKey = model.primaryKeyField;\n          var tablePkFragment = \"\".concat(this.quoteTable(options.tableAs || model.name), \".\").concat(this.quoteIdentifier(primaryKey));\n          var aliasedAttribute = (options.attributes || []).find(function (attr) {\n            return Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey);\n          });\n          if (aliasedAttribute) {\n            var modelName = this.quoteIdentifier(options.tableAs || model.name);\n            var alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n            primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n          }\n          if (!options.order || !options.order.length) {\n            fragment += \" ORDER BY \".concat(tablePkFragment);\n          } else {\n            var orderFieldNames = (options.order || []).map(function (order) {\n              var value = Array.isArray(order) ? order[0] : order;\n              if (value instanceof Utils.Col) {\n                return value.col;\n              }\n              if (value instanceof Utils.Literal) {\n                return value.val;\n              }\n              return value;\n            });\n            var primaryKeyFieldAlreadyPresent = orderFieldNames.some(function (fieldName) {\n              return fieldName === (primaryKey.col || primaryKey);\n            });\n            if (!primaryKeyFieldAlreadyPresent) {\n              fragment += options.order && !isSubQuery ? \", \" : \" ORDER BY \";\n              fragment += tablePkFragment;\n            }\n          }\n        }\n        if (options.offset || options.limit) {\n          fragment += \" OFFSET \".concat(this.escape(offset), \" ROWS\");\n        }\n        if (options.limit) {\n          fragment += \" FETCH NEXT \".concat(this.escape(options.limit), \" ROWS ONLY\");\n        }\n      }\n      return fragment;\n    }\n  }, {\n    key: \"booleanValue\",\n    value: function booleanValue(value) {\n      return value ? 1 : 0;\n    }\n  }, {\n    key: \"quoteIdentifier\",\n    value: function quoteIdentifier(identifier, force) {\n      return \"[\".concat(identifier.replace(/[[\\]']+/g, \"\"), \"]\");\n    }\n  }]);\n  return MSSQLQueryGenerator;\n}(AbstractQueryGenerator);\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\nmodule.exports = MSSQLQueryGenerator;","map":{"version":3,"names":["_","require","Utils","DataTypes","TableHints","AbstractQueryGenerator","randomBytes","semver","Op","throwMethodUndefined","methodName","Error","concat","MSSQLQueryGenerator","_AbstractQueryGenerat","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","createDatabaseQuery","databaseName","options","__spreadValues","collate","collation","escape","wrapSingleQuote","quoteIdentifier","join","dropDatabaseQuery","createSchema","schema","dropSchema","quotedSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","_this","primaryKeys","foreignKeys","attributesClauseParts","commentStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","commentMatch","commentText","replace","trim","commentTemplate","push","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","quotedTableName","quoteTable","joinSQLFragments","describeTableQuery","sql","renameTableQuery","before","after","showTablesQuery","tableExistsQuery","table","schemaName","dropTableQuery","quoteTbl","addColumnQuery","comment","isString","attributeToSQL","context","column","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","commentString","quotedAttrName","definition","renameColumnQuery","attrBefore","newName","keys","bulkInsertQuery","attrValueHashes","_this2","quotedTable","tuples","allAttributes","allQueries","needIdentityInsertWrapper","outputFragment","returning","returnValues","generateReturnValues","emptyQuery","forEach","attrValueHash","firstAttr","autoIncrement","forOwn","quotedAttributes","tupleStr","commands","offset","batch","Math","floor","_loop","slice","min","generatedQuery","v","max","updateQuery","where","_get","_getPrototypeOf","limit","updateArgs","query","upsertQuery","insertValues","updateValues","model","_this3","targetTableAlias","sourceTableAlias","primaryKeysAttrs","identityAttrs","uniqueAttrs","tableNameQuoted","rawAttributes","primaryKey","unique","_iterator2","_createForOfIteratorHelper","_indexes","_step2","s","n","done","index","_iterator3","_step3","fieldName","name","attribute","err","e","f","updateKeys","insertKeys","insertKeysQuoted","insertValuesEscaped","sourceTableQuery","joinCondition","clauses","or","filter","clause","valid","getJoinSnippet","array","filteredUpdateClauses","updateSnippet","insertSnippet","truncateTableQuery","deleteQuery","undefined","whereClause","getWhereConditions","showIndexesQuery","showConstraintsQuery","removeIndexQuery","indexNameOrAttributes","underscore","quoteIdentifiers","_this4","isPlainObject","type","references","Model","sequelize","log","onDelete","onUpdate","template","ENUM","values","toSql","toString","allowNull","defaultValueSchemable","defaultValue","_binary","withoutForeignKeyConstraints","toUpperCase","attributesToSQL","result","existingConstraints","createTrigger","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","_getForeignKeysQueryPrefix","catalogName","getForeignKeysQuery","getForeignKeyQuery","getPrimaryKeyConstraintQuery","dropForeignKeyQuery","foreignKey","getDefaultConstraintQuery","dropConstraintQuery","constraintName","setIsolationLevelQuery","generateTransactionId","startTransactionQuery","transaction","parent","commitTransactionQuery","rollbackTransactionQuery","selectFromTableFragment","tables","mainTableAs","_throwOnEmptyAttributes","modelName","as","dbVersion","databaseVersion","isSQLServer2008","lt","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","mainQueryOrder","order","getQueryOrders","primaryKeyField","tmpTable","include","subQuery","mainTable","quotedName","topLevelInfo","names","mainJoinQueries","_iterator4","_step4","separate","joinQueries","generateInclude","externalAs","internalAs","mainQuery","tableHint","addLimitAndOffset","fragment","subQueryOrder","tablePkFragment","tableAs","aliasedAttribute","find","Array","isArray","alias","_getAliasForField","Col","orderFieldNames","col","Literal","val","primaryKeyFieldAlreadyPresent","some","booleanValue","identifier","force","addTicks","removeTicks","module","exports"],"sources":["../../../src/dialects/mssql/query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst TableHints = require('../../table-hints');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst semver = require('semver');\nconst Op = require('../../operators');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = { collate: null, ...options };\n\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;'\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;'\n    ].join(' ');\n  }\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"\n    ].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = {},\n      attributesClauseParts = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${\n            this.quoteIdentifier(indexName)\n          } UNIQUE (${\n            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n          })`);\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,\n      ';',\n      commentStr\n    ]);\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"CAST(prop.value AS NVARCHAR) AS 'Comment'\",\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.CONSTRAINT_TYPE ',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'INNER JOIN sys.columns AS sc',\n      \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\",\n      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',\n      'AND prop.minor_id = sc.column_id',\n      \"AND prop.name = 'MS_Description'\",\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || 'dbo';\n\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      'DROP TABLE',\n      quoteTbl,\n      ';'\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType['comment'];\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: 'addColumn' }),\n      ';',\n      commentStr\n    ]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' +\n        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +\n        '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' +\n        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +\n        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n      constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';',\n      commentString\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\n      'EXEC sp_rename',\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      \"'COLUMN'\",\n      ';'\n    ]);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n    let needIdentityInsertWrapper = false,\n      outputFragment = '';\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key])).join(',')\n        })`);\n      });\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //IDENTITY_INSERT Condition\n    identityAttrs.forEach(key => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    });\n\n    //Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (typeof clause[key] === 'undefined' || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const filteredUpdateClauses = updateKeys.filter(key => !identityAttrs.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(', ')}` : '';\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n\n    return Utils.joinSQLFragments([\n      'DELETE',\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      'FROM',\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      ';',\n      'SELECT @@ROWCOUNT AS AFFECTEDROWS',\n      ';'\n    ]);\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references) {\n\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ') }))`;\n      return template;\n    }\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${'SELECT ' +\n        'constraint_name = OBJ.NAME, ' +\n        'constraintName = OBJ.NAME, '}${\n      catalogName ? `constraintCatalog = '${catalogName}', ` : ''\n    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +\n        'tableName = TB.NAME, ' +\n        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${\n          catalogName ? `tableCatalog = '${catalogName}', ` : ''\n        }columnName = COL.NAME, ` +\n        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${\n          catalogName ? `referencedCatalog = '${catalogName}', ` : ''\n        }referencedTableName = RTB.NAME, ` +\n        'referencedColumnName = RCOL.NAME ' +\n      'FROM sys.foreign_key_columns FKC ' +\n        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +\n        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +\n        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +\n        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +\n        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      'WHERE',\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      'AND',\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`\n    ]);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      ';'\n    ]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(foreignKey)\n    ]);\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      'SELECT name FROM sys.default_constraints',\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      ';'\n    ]);\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP CONSTRAINT',\n      this.quoteIdentifier(constraintName),\n      ';'\n    ]);\n  }\n\n  setIsolationLevelQuery() {\n\n  }\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');\n\n    if (isSQLServer2008 && options.offset) {\n      // For earlier versions of SQL server, we need to nest several queries\n      // in order to emulate the OFFSET behavior.\n      //\n      // 1. The outermost query selects all items from the inner query block.\n      //    This is due to a limitation in SQL server with the use of computed\n      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n      // 2. The next query handles the LIMIT and OFFSET behavior by getting\n      //    the TOP N rows of the query where the row number is > OFFSET\n      // 3. The innermost query is the actual set we want information from\n\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n\n      const tmpTable = mainTableAs || 'OffsetTable';\n\n      if (options.include) {\n        const subQuery = options.subQuery === undefined ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n\n        return Utils.joinSQLFragments([\n          'SELECT TOP 100 PERCENT',\n          attributes.join(', '),\n          'FROM (',\n          [\n            'SELECT',\n            options.limit && `TOP ${options.limit}`,\n            '* FROM (',\n            [\n              'SELECT ROW_NUMBER() OVER (',\n              [\n                'ORDER BY',\n                orders.mainQueryOrder.join(', ')\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                'SELECT DISTINCT',\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`\n              ],\n              `) AS ${tmpTable}`\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`\n          ],\n          `) AS ${tmpTable}`\n        ]);\n      }\n      return Utils.joinSQLFragments([\n        'SELECT TOP 100 PERCENT',\n        attributes.join(', '),\n        'FROM (',\n        [\n          'SELECT',\n          options.limit && `TOP ${options.limit}`,\n          '* FROM (',\n          [\n            'SELECT ROW_NUMBER() OVER (',\n            [\n              'ORDER BY',\n              orders.mainQueryOrder.join(', ')\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`\n        ],\n        `) AS ${tmpTable}`\n      ]);\n    }\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(', '),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`\n    ]);\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // TODO: document why this is adding the primary key of the model in ORDER BY\n      //  if options.include is set\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find(attr => Array.isArray(attr)\n            && attr[1]\n            && (attr[0] === primaryKey || attr[1] === primaryKey));\n\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map(order => {\n            const value = Array.isArray(order) ? order[0] : order;\n\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some(\n            fieldName => fieldName === (primaryKey.col || primaryKey)\n          );\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, '')}]`;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}