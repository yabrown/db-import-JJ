{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nvar _ = require(\"lodash\");\nvar Utils = require(\"../../utils\");\nvar AbstractQueryGenerator = require(\"../abstract/query-generator\");\nvar util = require(\"util\");\nvar Op = require(\"../../operators\");\nvar JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nvar JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nvar TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nvar FOREIGN_KEY_FIELDS = [\"CONSTRAINT_NAME as constraint_name\", \"CONSTRAINT_NAME as constraintName\", \"CONSTRAINT_SCHEMA as constraintSchema\", \"CONSTRAINT_SCHEMA as constraintCatalog\", \"TABLE_NAME as tableName\", \"TABLE_SCHEMA as tableSchema\", \"TABLE_SCHEMA as tableCatalog\", \"COLUMN_NAME as columnName\", \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\", \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\", \"REFERENCED_TABLE_NAME as referencedTableName\", \"REFERENCED_COLUMN_NAME as referencedColumnName\"].join(\",\");\nvar SNOWFLAKE_RESERVED_WORDS = \"account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with\".split(\",\");\nvar typeWithoutDefault = /* @__PURE__ */new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nvar SnowflakeQueryGenerator = /*#__PURE__*/function (_AbstractQueryGenerat) {\n  _inherits(SnowflakeQueryGenerator, _AbstractQueryGenerat);\n  var _super = _createSuper(SnowflakeQueryGenerator);\n  function SnowflakeQueryGenerator(options) {\n    var _spreadProps;\n    var _this;\n    _classCallCheck(this, SnowflakeQueryGenerator);\n    _this = _super.call(this, options);\n    _this.OperatorMap = __spreadProps(__spreadValues({}, _this.OperatorMap), (_spreadProps = {}, _defineProperty(_spreadProps, Op.regexp, \"REGEXP\"), _defineProperty(_spreadProps, Op.notRegexp, \"NOT REGEXP\"), _spreadProps));\n    return _this;\n  }\n  _createClass(SnowflakeQueryGenerator, [{\n    key: \"createDatabaseQuery\",\n    value: function createDatabaseQuery(databaseName, options) {\n      options = __spreadValues({\n        charset: null,\n        collate: null\n      }, options);\n      return Utils.joinSQLFragments([\"CREATE DATABASE IF NOT EXISTS\", this.quoteIdentifier(databaseName), options.charset && \"DEFAULT CHARACTER SET \".concat(this.escape(options.charset)), options.collate && \"DEFAULT COLLATE \".concat(this.escape(options.collate)), \";\"]);\n    }\n  }, {\n    key: \"dropDatabaseQuery\",\n    value: function dropDatabaseQuery(databaseName) {\n      return \"DROP DATABASE IF EXISTS \".concat(this.quoteIdentifier(databaseName), \";\");\n    }\n  }, {\n    key: \"createSchema\",\n    value: function createSchema() {\n      return \"SHOW TABLES\";\n    }\n  }, {\n    key: \"showSchemasQuery\",\n    value: function showSchemasQuery() {\n      return \"SHOW TABLES\";\n    }\n  }, {\n    key: \"versionQuery\",\n    value: function versionQuery() {\n      return \"SELECT CURRENT_VERSION()\";\n    }\n  }, {\n    key: \"createTableQuery\",\n    value: function createTableQuery(tableName, attributes, options) {\n      var _this2 = this;\n      options = __spreadValues({\n        charset: null,\n        rowFormat: null\n      }, options);\n      var primaryKeys = [];\n      var foreignKeys = {};\n      var attrStr = [];\n      for (var attr in attributes) {\n        if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n        var dataType = attributes[attr];\n        var match = void 0;\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (dataType.includes(\"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1].replace(\"PRIMARY KEY\", \"\")));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType.replace(\"PRIMARY KEY\", \"\")));\n          }\n        } else if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(match[1]));\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(\"\".concat(this.quoteIdentifier(attr), \" \").concat(dataType));\n        }\n      }\n      var table = this.quoteTable(tableName);\n      var attributesClause = attrStr.join(\", \");\n      var pkString = primaryKeys.map(function (pk) {\n        return _this2.quoteIdentifier(pk);\n      }).join(\", \");\n      if (options.uniqueKeys) {\n        _.each(options.uniqueKeys, function (columns, indexName) {\n          if (columns.customIndex) {\n            if (typeof indexName !== \"string\") {\n              indexName = \"uniq_\".concat(tableName, \"_\").concat(columns.fields.join(\"_\"));\n            }\n            attributesClause += \", UNIQUE \".concat(_this2.quoteIdentifier(indexName), \" (\").concat(columns.fields.map(function (field) {\n              return _this2.quoteIdentifier(field);\n            }).join(\", \"), \")\");\n          }\n        });\n      }\n      if (pkString.length > 0) {\n        attributesClause += \", PRIMARY KEY (\".concat(pkString, \")\");\n      }\n      for (var fkey in foreignKeys) {\n        if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n          attributesClause += \", FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]);\n        }\n      }\n      return Utils.joinSQLFragments([\"CREATE TABLE IF NOT EXISTS\", table, \"(\".concat(attributesClause, \")\"), options.comment && typeof options.comment === \"string\" && \"COMMENT \".concat(this.escape(options.comment)), options.charset && \"DEFAULT CHARSET=\".concat(options.charset), options.collate && \"COLLATE \".concat(options.collate), options.rowFormat && \"ROW_FORMAT=\".concat(options.rowFormat), \";\"]);\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema, schemaDelimiter) {\n      var table = this.quoteTable(this.addSchema({\n        tableName: tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      }));\n      return \"SHOW FULL COLUMNS FROM \".concat(table, \";\");\n    }\n  }, {\n    key: \"showTablesQuery\",\n    value: function showTablesQuery(database) {\n      return Utils.joinSQLFragments([\"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\", database ? \"AND TABLE_SCHEMA = \".concat(this.escape(database)) : \"AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\", \";\"]);\n    }\n  }, {\n    key: \"tableExistsQuery\",\n    value: function tableExistsQuery(table) {\n      var tableName = table.tableName || table;\n      var schema = table.schema;\n      return Utils.joinSQLFragments([\"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\", \"AND TABLE_SCHEMA = \".concat(schema !== void 0 ? this.escape(schema) : \"CURRENT_SCHEMA()\"), \"AND TABLE_NAME = \".concat(this.escape(tableName)), \";\"]);\n    }\n  }, {\n    key: \"addColumnQuery\",\n    value: function addColumnQuery(table, key, dataType) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }), \";\"]);\n    }\n  }, {\n    key: \"removeColumnQuery\",\n    value: function removeColumnQuery(tableName, attributeName) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(attributeName), \";\"]);\n    }\n  }, {\n    key: \"changeColumnQuery\",\n    value: function changeColumnQuery(tableName, attributes) {\n      var _this3 = this;\n      var query = function query() {\n        for (var _len = arguments.length, subQuerys = new Array(_len), _key = 0; _key < _len; _key++) {\n          subQuerys[_key] = arguments[_key];\n        }\n        return Utils.joinSQLFragments([\"ALTER TABLE\", _this3.quoteTable(tableName), \"ALTER COLUMN\"].concat(subQuerys, [\";\"]));\n      };\n      var sql = [];\n      for (var attributeName in attributes) {\n        var definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n        var attrSql = [];\n        if (definition.includes(\"NOT NULL\")) {\n          attrSql.push(query(this.quoteIdentifier(attributeName), \"SET NOT NULL\"));\n          definition = definition.replace(\"NOT NULL\", \"\").trim();\n        } else if (!definition.includes(\"REFERENCES\")) {\n          attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP NOT NULL\"));\n        }\n        if (definition.includes(\"DEFAULT\")) {\n          attrSql.push(query(this.quoteIdentifier(attributeName), \"SET DEFAULT\", definition.match(/DEFAULT ([^;]+)/)[1]));\n          definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n        } else if (!definition.includes(\"REFERENCES\")) {\n          attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP DEFAULT\"));\n        }\n        if (definition.match(/UNIQUE;*$/)) {\n          definition = definition.replace(/UNIQUE;*$/, \"\");\n          attrSql.push(query(\"ADD UNIQUE (\", this.quoteIdentifier(attributeName), \")\").replace(\"ALTER COLUMN\", \"\"));\n        }\n        if (definition.includes(\"REFERENCES\")) {\n          definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n          attrSql.push(query(\"ADD FOREIGN KEY (\", this.quoteIdentifier(attributeName), \")\", definition).replace(\"ALTER COLUMN\", \"\"));\n        } else {\n          attrSql.push(query(this.quoteIdentifier(attributeName), \"TYPE\", definition));\n        }\n        sql.push(attrSql.join(\"\"));\n      }\n      return sql.join(\"\");\n    }\n  }, {\n    key: \"renameColumnQuery\",\n    value: function renameColumnQuery(tableName, attrBefore, attributes) {\n      var attrString = [];\n      for (var attrName in attributes) {\n        var definition = attributes[attrName];\n        attrString.push(\"'\".concat(attrBefore, \"' '\").concat(attrName, \"' \").concat(definition));\n      }\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"RENAME COLUMN\", attrString.join(\" to \"), \";\"]);\n    }\n  }, {\n    key: \"handleSequelizeMethod\",\n    value: function handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n      var _this4 = this;\n      if (attr instanceof Utils.Json) {\n        if (attr.conditions) {\n          var conditions = this.parseConditionObject(attr.conditions).map(function (condition) {\n            return \"\".concat(_this4.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), \" = '\").concat(condition.value, \"'\");\n          });\n          return conditions.join(\" AND \");\n        }\n        if (attr.path) {\n          var str;\n          if (this._checkValidJsonStatement(attr.path)) {\n            str = attr.path;\n          } else {\n            var paths = _.toPath(attr.path);\n            var column = paths.shift();\n            str = this.jsonPathExtractionQuery(column, paths);\n          }\n          if (attr.value) {\n            str += util.format(\" = %s\", this.escape(attr.value));\n          }\n          return str;\n        }\n      } else if (attr instanceof Utils.Cast) {\n        if (/timestamp/i.test(attr.type)) {\n          attr.type = \"datetime\";\n        } else if (attr.json && /boolean/i.test(attr.type)) {\n          attr.type = \"char\";\n        } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n          attr.type = \"decimal\";\n        } else if (/text/i.test(attr.type)) {\n          attr.type = \"char\";\n        }\n      }\n      return _get(_getPrototypeOf(SnowflakeQueryGenerator.prototype), \"handleSequelizeMethod\", this).call(this, attr, tableName, factory, options, prepend);\n    }\n  }, {\n    key: \"truncateTableQuery\",\n    value: function truncateTableQuery(tableName) {\n      return Utils.joinSQLFragments([\"TRUNCATE\", this.quoteTable(tableName)]);\n    }\n  }, {\n    key: \"deleteQuery\",\n    value: function deleteQuery(tableName, where) {\n      var _this5 = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var model = arguments.length > 3 ? arguments[3] : undefined;\n      var table = this.quoteTable(tableName);\n      var whereClause = this.getWhereConditions(where, null, model, options);\n      var limit = options.limit && \" LIMIT \".concat(this.escape(options.limit));\n      var primaryKeys = \"\";\n      var primaryKeysSelection = \"\";\n      if (whereClause) {\n        whereClause = \"WHERE \".concat(whereClause);\n      }\n      if (limit) {\n        if (!model) {\n          throw new Error(\"Cannot LIMIT delete without a model.\");\n        }\n        var pks = Object.values(model.primaryKeys).map(function (pk) {\n          return _this5.quoteIdentifier(pk.field);\n        }).join(\",\");\n        primaryKeys = model.primaryKeyAttributes.length > 1 ? \"(\".concat(pks, \")\") : pks;\n        primaryKeysSelection = pks;\n        return Utils.joinSQLFragments([\"DELETE FROM\", table, \"WHERE\", primaryKeys, \"IN (SELECT\", primaryKeysSelection, \"FROM\", table, whereClause, limit, \")\", \";\"]);\n      }\n      return Utils.joinSQLFragments([\"DELETE FROM\", table, whereClause, \";\"]);\n    }\n  }, {\n    key: \"showIndexesQuery\",\n    value: function showIndexesQuery() {\n      return \"SELECT '' FROM DUAL\";\n    }\n  }, {\n    key: \"showConstraintsQuery\",\n    value: function showConstraintsQuery(table, constraintName) {\n      var tableName = table.tableName || table;\n      var schemaName = table.schema;\n      return Utils.joinSQLFragments([\"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\", \"CONSTRAINT_NAME AS constraintName,\", \"CONSTRAINT_SCHEMA AS constraintSchema,\", \"CONSTRAINT_TYPE AS constraintType,\", \"TABLE_NAME AS tableName,\", \"TABLE_SCHEMA AS tableSchema\", \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\", \"WHERE table_name='\".concat(tableName, \"'\"), constraintName && \"AND constraint_name = '\".concat(constraintName, \"'\"), schemaName && \"AND TABLE_SCHEMA = '\".concat(schemaName, \"'\"), \";\"]);\n    }\n  }, {\n    key: \"removeIndexQuery\",\n    value: function removeIndexQuery(tableName, indexNameOrAttributes) {\n      var indexName = indexNameOrAttributes;\n      if (typeof indexName !== \"string\") {\n        indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join(\"_\")));\n      }\n      return Utils.joinSQLFragments([\"DROP INDEX\", this.quoteIdentifier(indexName), \"ON\", this.quoteTable(tableName), \";\"]);\n    }\n  }, {\n    key: \"attributeToSQL\",\n    value: function attributeToSQL(attribute, options) {\n      if (!_.isPlainObject(attribute)) {\n        attribute = {\n          type: attribute\n        };\n      }\n      var attributeString = attribute.type.toString({\n        escape: this.escape.bind(this)\n      });\n      var template = attributeString;\n      if (attribute.allowNull === false) {\n        template += \" NOT NULL\";\n      }\n      if (attribute.autoIncrement) {\n        template += \" AUTOINCREMENT\";\n      }\n      if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n      }\n      if (attribute.unique === true) {\n        template += \" UNIQUE\";\n      }\n      if (attribute.primaryKey) {\n        template += \" PRIMARY KEY\";\n      }\n      if (attribute.comment) {\n        template += \" COMMENT \".concat(this.escape(attribute.comment));\n      }\n      if (attribute.first) {\n        template += \" FIRST\";\n      }\n      if (attribute.after) {\n        template += \" AFTER \".concat(this.quoteIdentifier(attribute.after));\n      }\n      if (attribute.references) {\n        if (options && options.context === \"addColumn\" && options.foreignKey) {\n          var attrName = this.quoteIdentifier(options.foreignKey);\n          var fkName = this.quoteIdentifier(\"\".concat(options.tableName, \"_\").concat(attrName, \"_foreign_idx\"));\n          template += \", ADD CONSTRAINT \".concat(fkName, \" FOREIGN KEY (\").concat(attrName, \")\");\n        }\n        template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n        if (attribute.references.key) {\n          template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n        } else {\n          template += \" (\".concat(this.quoteIdentifier(\"id\"), \")\");\n        }\n        if (attribute.onDelete) {\n          template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n        }\n        if (attribute.onUpdate) {\n          template += \" ON UPDATE \".concat(attribute.onUpdate.toUpperCase());\n        }\n      }\n      return template;\n    }\n  }, {\n    key: \"attributesToSQL\",\n    value: function attributesToSQL(attributes, options) {\n      var result = {};\n      for (var key in attributes) {\n        var attribute = attributes[key];\n        result[attribute.field || key] = this.attributeToSQL(attribute, options);\n      }\n      return result;\n    }\n  }, {\n    key: \"_checkValidJsonStatement\",\n    value: function _checkValidJsonStatement(stmt) {\n      if (typeof stmt !== \"string\") {\n        return false;\n      }\n      var currentIndex = 0;\n      var openingBrackets = 0;\n      var closingBrackets = 0;\n      var hasJsonFunction = false;\n      var hasInvalidToken = false;\n      while (currentIndex < stmt.length) {\n        var string = stmt.substr(currentIndex);\n        var functionMatches = JSON_FUNCTION_REGEX.exec(string);\n        if (functionMatches) {\n          currentIndex += functionMatches[0].indexOf(\"(\");\n          hasJsonFunction = true;\n          continue;\n        }\n        var operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n        if (operatorMatches) {\n          currentIndex += operatorMatches[0].length;\n          hasJsonFunction = true;\n          continue;\n        }\n        var tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n        if (tokenMatches) {\n          var capturedToken = tokenMatches[1];\n          if (capturedToken === \"(\") {\n            openingBrackets++;\n          } else if (capturedToken === \")\") {\n            closingBrackets++;\n          } else if (capturedToken === \";\") {\n            hasInvalidToken = true;\n            break;\n          }\n          currentIndex += tokenMatches[0].length;\n          continue;\n        }\n        break;\n      }\n      if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n        throw new Error(\"Invalid json statement: \".concat(stmt));\n      }\n      return hasJsonFunction;\n    }\n  }, {\n    key: \"dataTypeMapping\",\n    value: function dataTypeMapping(tableName, attr, dataType) {\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n      }\n      if (dataType.includes(\"SERIAL\")) {\n        if (dataType.includes(\"BIGINT\")) {\n          dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n          dataType = dataType.replace(\"BIGINT\", \"\");\n        } else if (dataType.includes(\"SMALLINT\")) {\n          dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n          dataType = dataType.replace(\"SMALLINT\", \"\");\n        } else {\n          dataType = dataType.replace(\"INTEGER\", \"\");\n        }\n        dataType = dataType.replace(\"NOT NULL\", \"\");\n      }\n      return dataType;\n    }\n  }, {\n    key: \"getForeignKeysQuery\",\n    value: function getForeignKeysQuery(table, schemaName) {\n      var tableName = table.tableName || table;\n      return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '\".concat(tableName, \"'\"), \"AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='\".concat(schemaName, \"'\"), \"AND REFERENCED_TABLE_NAME IS NOT NULL\", \";\"]);\n    }\n  }, {\n    key: \"getForeignKeyQuery\",\n    value: function getForeignKeyQuery(table, columnName) {\n      var quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n      var quotedTableName = wrapSingleQuote(table.tableName || table);\n      var quotedColumnName = wrapSingleQuote(columnName);\n      return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\", \"WHERE (\", [\"REFERENCED_TABLE_NAME = \".concat(quotedTableName), table.schema && \"AND REFERENCED_TABLE_SCHEMA = \".concat(quotedSchemaName), \"AND REFERENCED_COLUMN_NAME = \".concat(quotedColumnName)], \") OR (\", [\"TABLE_NAME = \".concat(quotedTableName), table.schema && \"AND TABLE_SCHEMA = \".concat(quotedSchemaName), \"AND COLUMN_NAME = \".concat(quotedColumnName), \"AND REFERENCED_TABLE_NAME IS NOT NULL\"], \")\"]);\n    }\n  }, {\n    key: \"dropForeignKeyQuery\",\n    value: function dropForeignKeyQuery(tableName, foreignKey) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP FOREIGN KEY\", this.quoteIdentifier(foreignKey), \";\"]);\n    }\n  }, {\n    key: \"addLimitAndOffset\",\n    value: function addLimitAndOffset(options) {\n      var fragment = [];\n      if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {\n        fragment = fragment.concat([\" LIMIT \", this.escape(options.limit), \" OFFSET \", this.escape(options.offset)]);\n      } else if (options.limit !== null && options.limit !== void 0) {\n        fragment = [\" LIMIT \", this.escape(options.limit)];\n      }\n      return fragment.join(\"\");\n    }\n  }, {\n    key: \"quoteIdentifier\",\n    value: function quoteIdentifier(identifier, force) {\n      var optForceQuote = force || false;\n      var optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n      var rawIdentifier = Utils.removeTicks(identifier, '\"');\n      if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n        return Utils.addTicks(rawIdentifier, '\"');\n      }\n      return rawIdentifier;\n    }\n  }]);\n  return SnowflakeQueryGenerator;\n}(AbstractQueryGenerator);\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = SnowflakeQueryGenerator;","map":{"version":3,"names":["_","require","Utils","AbstractQueryGenerator","util","Op","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","FOREIGN_KEY_FIELDS","join","SNOWFLAKE_RESERVED_WORDS","split","typeWithoutDefault","Set","SnowflakeQueryGenerator","_AbstractQueryGenerat","_inherits","_super","_createSuper","options","_spreadProps","_this","_classCallCheck","call","OperatorMap","__spreadProps","__spreadValues","_defineProperty","regexp","notRegexp","_createClass","key","value","createDatabaseQuery","databaseName","charset","collate","joinSQLFragments","quoteIdentifier","concat","escape","dropDatabaseQuery","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","_this2","rowFormat","primaryKeys","foreignKeys","attrStr","attr","Object","prototype","hasOwnProperty","dataType","match","includes","push","replace","table","quoteTable","attributesClause","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","comment","describeTableQuery","schema","schemaDelimiter","addSchema","_schema","_schemaDelimiter","showTablesQuery","database","tableExistsQuery","addColumnQuery","attributeToSQL","context","foreignKey","removeColumnQuery","attributeName","changeColumnQuery","_this3","query","_len","arguments","subQuerys","Array","_key","sql","definition","dataTypeMapping","attrSql","trim","renameColumnQuery","attrBefore","attrString","attrName","handleSequelizeMethod","factory","prepend","_this4","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","str","_checkValidJsonStatement","paths","toPath","column","shift","format","Cast","test","type","json","_get","_getPrototypeOf","truncateTableQuery","deleteQuery","where","_this5","undefined","model","whereClause","getWhereConditions","limit","primaryKeysSelection","Error","pks","values","primaryKeyAttributes","showIndexesQuery","showConstraintsQuery","constraintName","schemaName","removeIndexQuery","indexNameOrAttributes","underscore","attribute","isPlainObject","attributeString","toString","bind","template","allowNull","autoIncrement","has","_binary","defaultValueSchemable","defaultValue","unique","primaryKey","first","after","references","fkName","onDelete","toUpperCase","onUpdate","attributesToSQL","result","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","indexOf","operatorMatches","tokenMatches","capturedToken","getForeignKeysQuery","getForeignKeyQuery","columnName","quotedSchemaName","wrapSingleQuote","quotedTableName","quotedColumnName","dropForeignKeyQuery","addLimitAndOffset","fragment","offset","identifier","force","optForceQuote","optQuoteIdentifiers","quoteIdentifiers","rawIdentifier","removeTicks","toLowerCase","addTicks","module","exports"],"sources":["../../../src/dialects/snowflake/query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  'CONSTRAINT_NAME as constraint_name',\n  'CONSTRAINT_NAME as constraintName',\n  'CONSTRAINT_SCHEMA as constraintSchema',\n  'CONSTRAINT_SCHEMA as constraintCatalog',\n  'TABLE_NAME as tableName',\n  'TABLE_SCHEMA as tableSchema',\n  'TABLE_SCHEMA as tableCatalog',\n  'COLUMN_NAME as columnName',\n  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n  'REFERENCED_TABLE_NAME as referencedTableName',\n  'REFERENCED_COLUMN_NAME as referencedColumnName'\n].join(',');\n\n/**\n * list of reserved words in Snowflake\n * source: https://docs.snowflake.com/en/sql-reference/reserved-keywords.html\n *\n * @private\n */\nconst SNOWFLAKE_RESERVED_WORDS = 'account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with'.split(',');\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = {\n      ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n\n    return Utils.joinSQLFragments([\n      'CREATE DATABASE IF NOT EXISTS',\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      ';'\n    ]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT CURRENT_VERSION()';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'CREATE TABLE IF NOT EXISTS',\n      table,\n      `(${attributesClause})`,\n      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      ';'\n    ]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\n      'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'',\n      database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : 'AND TABLE_SCHEMA NOT IN ( \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')',\n      ';'\n    ]);\n  }\n\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'',\n      `AND TABLE_SCHEMA = ${schema !== undefined ? this.escape(schema) : 'CURRENT_SCHEMA()'}`,\n      `AND TABLE_NAME = ${this.escape(tableName)}`,\n      ';'\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      }),\n      ';'\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'ALTER COLUMN',\n      ...subQuerys,\n      ';'\n    ]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n\n      if (definition.includes('NOT NULL')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'SET NOT NULL'));\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'DROP NOT NULL'));\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'SET DEFAULT', definition.match(/DEFAULT ([^;]+)/)[1]));\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'DROP DEFAULT'));\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql.push(query('ADD UNIQUE (', this.quoteIdentifier(attributeName), ')').replace('ALTER COLUMN', ''));\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql.push(query('ADD FOREIGN KEY (', this.quoteIdentifier(attributeName), ')', definition).replace('ALTER COLUMN', ''));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), 'TYPE', definition));\n      }\n\n      sql.push(attrSql.join(''));\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'RENAME COLUMN',\n      attrString.join(' to '),\n      ';'\n    ]);\n  }\n\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      // Parse nested object\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (attr.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (attr.value) {\n          str += util.format(' = %s', this.escape(attr.value));\n        }\n\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = 'datetime';\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        attr.type = 'char';\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = 'decimal';\n      } else if (/text/i.test(attr.type)) {\n        attr.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      'TRUNCATE',\n      this.quoteTable(tableName)\n    ]);\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = Object.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return Utils.joinSQLFragments([\n        'DELETE FROM',\n        table,\n        'WHERE',\n        primaryKeys,\n        'IN (SELECT',\n        primaryKeysSelection,\n        'FROM',\n        table,\n        whereClause,\n        limit,\n        ')',\n        ';'\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      'DELETE FROM',\n      table,\n      whereClause,\n      ';'\n    ]);\n  }\n\n  showIndexesQuery() {\n    return 'SELECT \\'\\' FROM DUAL';\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      ';'\n    ]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'DROP INDEX',\n      this.quoteIdentifier(indexName),\n      'ON',\n      this.quoteTable(tableName),\n      ';'\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' AUTOINCREMENT';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      'AND REFERENCED_TABLE_NAME IS NOT NULL',\n      ';'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',\n      'WHERE (',\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      ') OR (',\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        'AND REFERENCED_TABLE_NAME IS NOT NULL'\n      ],\n      ')'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP FOREIGN KEY',\n      this.quoteIdentifier(foreignKey),\n      ';'\n    ]);\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== undefined && options.offset !== 0) {\n      fragment = fragment.concat([' LIMIT ', this.escape(options.limit), ' OFFSET ', this.escape(options.offset)]);\n    } else if ( options.limit !== null && options.limit !== undefined ) {\n      fragment = [' LIMIT ', this.escape(options.limit)];\n    }\n    return fragment.join('');\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n\n    if (\n      optForceQuote === true ||\n      optQuoteIdentifiers !== false ||\n      identifier.includes('.') ||\n      identifier.includes('->') ||\n      SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())\n    ) {\n      // In Snowflake if tables or attributes are created double-quoted,\n      // they are also case sensitive. If they contain any uppercase\n      // characters, they must always be double-quoted. This makes it\n      // impossible to write queries in portable SQL if tables are created in\n      // this way. Hence, we strip quotes if we don't want case sensitivity.\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = SnowflakeQueryGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}