{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar _ = require(\"lodash\");\nvar SqlString = require(\"../../sql-string\");\nvar QueryTypes = require(\"../../query-types\");\nvar Dot = require(\"dottie\");\nvar deprecations = require(\"../../utils/deprecations\");\nvar uuid = require(\"uuid\").v4;\nvar _require = require(\"../../utils.js\"),\n  safeStringifyJson = _require.safeStringifyJson;\nvar AbstractQuery = /*#__PURE__*/function () {\n  function AbstractQuery(connection, sequelize, options) {\n    _classCallCheck(this, AbstractQuery);\n    this.uuid = uuid();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = __spreadValues({\n      plain: false,\n      raw: false,\n      logging: console.log\n    }, options);\n    this.checkLoggingOption();\n    if (options.rawErrors) {\n      this.formatError = AbstractQuery.prototype.formatError;\n    }\n  }\n  _createClass(AbstractQuery, [{\n    key: \"formatError\",\n    value: function formatError(error, errStack) {\n      error.stack = errStack;\n      return error;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      throw new Error(\"The run method wasn't overwritten!\");\n    }\n  }, {\n    key: \"checkLoggingOption\",\n    value: function checkLoggingOption() {\n      if (this.options.logging === true) {\n        deprecations.noTrueLogging();\n        this.options.logging = console.log;\n      }\n    }\n  }, {\n    key: \"getInsertIdField\",\n    value: function getInsertIdField() {\n      return \"insertId\";\n    }\n  }, {\n    key: \"getUniqueConstraintErrorMessage\",\n    value: function getUniqueConstraintErrorMessage(field) {\n      var message = field ? \"\".concat(field, \" must be unique\") : \"Must be unique\";\n      if (field && this.model) {\n        for (var _i = 0, _Object$keys = Object.keys(this.model.uniqueKeys); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          if (this.model.uniqueKeys[key].fields.includes(field.replace(/\"/g, \"\"))) {\n            if (this.model.uniqueKeys[key].msg) {\n              message = this.model.uniqueKeys[key].msg;\n            }\n          }\n        }\n      }\n      return message;\n    }\n  }, {\n    key: \"isRawQuery\",\n    value: function isRawQuery() {\n      return this.options.type === QueryTypes.RAW;\n    }\n  }, {\n    key: \"isVersionQuery\",\n    value: function isVersionQuery() {\n      return this.options.type === QueryTypes.VERSION;\n    }\n  }, {\n    key: \"isUpsertQuery\",\n    value: function isUpsertQuery() {\n      return this.options.type === QueryTypes.UPSERT;\n    }\n  }, {\n    key: \"isInsertQuery\",\n    value: function isInsertQuery(results, metaData) {\n      var result = true;\n      if (this.options.type === QueryTypes.INSERT) {\n        return true;\n      }\n      result = result && this.sql.toLowerCase().startsWith(\"insert into\");\n      result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));\n      result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));\n      return result;\n    }\n  }, {\n    key: \"handleInsertQuery\",\n    value: function handleInsertQuery(results, metaData) {\n      if (this.instance) {\n        var autoIncrementAttribute = this.model.autoIncrementAttribute;\n        var id = null;\n        id = id || results && results[this.getInsertIdField()];\n        id = id || metaData && metaData[this.getInsertIdField()];\n        this.instance[autoIncrementAttribute] = id;\n      }\n    }\n  }, {\n    key: \"isShowTablesQuery\",\n    value: function isShowTablesQuery() {\n      return this.options.type === QueryTypes.SHOWTABLES;\n    }\n  }, {\n    key: \"handleShowTablesQuery\",\n    value: function handleShowTablesQuery(results) {\n      return _.flatten(results.map(function (resultSet) {\n        return Object.values(resultSet);\n      }));\n    }\n  }, {\n    key: \"isShowIndexesQuery\",\n    value: function isShowIndexesQuery() {\n      return this.options.type === QueryTypes.SHOWINDEXES;\n    }\n  }, {\n    key: \"isShowConstraintsQuery\",\n    value: function isShowConstraintsQuery() {\n      return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n    }\n  }, {\n    key: \"isDescribeQuery\",\n    value: function isDescribeQuery() {\n      return this.options.type === QueryTypes.DESCRIBE;\n    }\n  }, {\n    key: \"isSelectQuery\",\n    value: function isSelectQuery() {\n      return this.options.type === QueryTypes.SELECT;\n    }\n  }, {\n    key: \"isBulkUpdateQuery\",\n    value: function isBulkUpdateQuery() {\n      return this.options.type === QueryTypes.BULKUPDATE;\n    }\n  }, {\n    key: \"isBulkDeleteQuery\",\n    value: function isBulkDeleteQuery() {\n      return this.options.type === QueryTypes.BULKDELETE;\n    }\n  }, {\n    key: \"isForeignKeysQuery\",\n    value: function isForeignKeysQuery() {\n      return this.options.type === QueryTypes.FOREIGNKEYS;\n    }\n  }, {\n    key: \"isUpdateQuery\",\n    value: function isUpdateQuery() {\n      return this.options.type === QueryTypes.UPDATE;\n    }\n  }, {\n    key: \"handleSelectQuery\",\n    value: function handleSelectQuery(results) {\n      var _this = this;\n      var result = null;\n      if (this.options.fieldMap) {\n        var fieldMap = this.options.fieldMap;\n        results = results.map(function (result2) {\n          return _.reduce(fieldMap, function (result3, name, field) {\n            if (result3[field] !== void 0 && name !== field) {\n              result3[name] = result3[field];\n              delete result3[field];\n            }\n            return result3;\n          }, result2);\n        });\n      }\n      if (this.options.raw) {\n        result = results.map(function (result2) {\n          var o = {};\n          for (var key in result2) {\n            if (Object.prototype.hasOwnProperty.call(result2, key)) {\n              o[key] = result2[key];\n            }\n          }\n          if (_this.options.nest) {\n            o = Dot.transform(o);\n          }\n          return o;\n        });\n      } else if (this.options.hasJoin === true) {\n        results = AbstractQuery._groupJoinData(results, {\n          model: this.model,\n          includeMap: this.options.includeMap,\n          includeNames: this.options.includeNames\n        }, {\n          checkExisting: this.options.hasMultiAssociation\n        });\n        result = this.model.bulkBuild(results, {\n          isNewRecord: false,\n          include: this.options.include,\n          includeNames: this.options.includeNames,\n          includeMap: this.options.includeMap,\n          includeValidated: true,\n          attributes: this.options.originalAttributes || this.options.attributes,\n          raw: true\n        });\n      } else {\n        result = this.model.bulkBuild(results, {\n          isNewRecord: false,\n          raw: true,\n          attributes: this.options.originalAttributes || this.options.attributes\n        });\n      }\n      if (this.options.plain) {\n        result = result.length === 0 ? null : result[0];\n      }\n      return result;\n    }\n  }, {\n    key: \"isShowOrDescribeQuery\",\n    value: function isShowOrDescribeQuery() {\n      var result = false;\n      result = result || this.sql.toLowerCase().startsWith(\"show\");\n      result = result || this.sql.toLowerCase().startsWith(\"describe\");\n      return result;\n    }\n  }, {\n    key: \"isCallQuery\",\n    value: function isCallQuery() {\n      return this.sql.toLowerCase().startsWith(\"call\");\n    }\n  }, {\n    key: \"_logQuery\",\n    value: function _logQuery(sql, debugContext, parameters) {\n      var _this2 = this;\n      var connection = this.connection,\n        options = this.options;\n      var benchmark = this.sequelize.options.benchmark || options.benchmark;\n      var logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;\n      var startTime = Date.now();\n      var logParameter = \"\";\n      if (logQueryParameters && parameters) {\n        var delimiter = sql.endsWith(\";\") ? \"\" : \";\";\n        var paramStr;\n        if (Array.isArray(parameters)) {\n          paramStr = parameters.map(function (p) {\n            return safeStringifyJson(p);\n          }).join(\", \");\n        } else {\n          paramStr = safeStringifyJson(parameters);\n        }\n        logParameter = \"\".concat(delimiter, \" \").concat(paramStr);\n      }\n      var fmt = \"(\".concat(connection.uuid || \"default\", \"): \").concat(sql).concat(logParameter);\n      var msg = \"Executing \".concat(fmt);\n      debugContext(msg);\n      if (!benchmark) {\n        this.sequelize.log(\"Executing \".concat(fmt), options);\n      }\n      return function () {\n        var afterMsg = \"Executed \".concat(fmt);\n        debugContext(afterMsg);\n        if (benchmark) {\n          _this2.sequelize.log(afterMsg, Date.now() - startTime, options);\n        }\n      };\n    }\n  }], [{\n    key: \"formatBindParameters\",\n    value: function formatBindParameters(sql, values, dialect, replacementFunc, options) {\n      if (!values) {\n        return [sql, []];\n      }\n      options = options || {};\n      if (typeof replacementFunc !== \"function\") {\n        options = replacementFunc || {};\n        replacementFunc = void 0;\n      }\n      if (!replacementFunc) {\n        if (options.skipValueReplace) {\n          replacementFunc = function replacementFunc(match, key, values2) {\n            if (values2[key] !== void 0) {\n              return match;\n            }\n            return void 0;\n          };\n        } else {\n          replacementFunc = function replacementFunc(match, key, values2, timeZone2, dialect2) {\n            if (values2[key] !== void 0) {\n              return SqlString.escape(values2[key], timeZone2, dialect2);\n            }\n            return void 0;\n          };\n        }\n      } else if (options.skipValueReplace) {\n        var origReplacementFunc = replacementFunc;\n        replacementFunc = function replacementFunc(match, key, values2, timeZone2, dialect2, options2) {\n          if (origReplacementFunc(match, key, values2, timeZone2, dialect2, options2) !== void 0) {\n            return match;\n          }\n          return void 0;\n        };\n      }\n      var timeZone = null;\n      var list = Array.isArray(values);\n      sql = sql.replace(/\\B\\$(\\$|\\w+)/g, function (match, key) {\n        if (key === \"$\") {\n          return options.skipUnescape ? match : key;\n        }\n        var replVal;\n        if (list) {\n          if (key.match(/^[1-9]\\d*$/)) {\n            key = key - 1;\n            replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n          }\n        } else if (!key.match(/^\\d*$/)) {\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n        if (replVal === void 0) {\n          throw new Error(\"Named bind parameter \\\"\".concat(match, \"\\\" has no value in the given object.\"));\n        }\n        return replVal;\n      });\n      return [sql, []];\n    }\n  }, {\n    key: \"_groupJoinData\",\n    value: function _groupJoinData(rows, includeOptions, options) {\n      if (!rows.length) {\n        return [];\n      }\n      var i;\n      var length;\n      var $i;\n      var $length;\n      var rowsI;\n      var row;\n      var rowsLength = rows.length;\n      var keys;\n      var key;\n      var keyI;\n      var keyLength;\n      var prevKey;\n      var values;\n      var topValues;\n      var topExists;\n      var checkExisting = options.checkExisting;\n      var itemHash;\n      var parentHash;\n      var topHash;\n      var results = checkExisting ? [] : new Array(rowsLength);\n      var resultMap = {};\n      var includeMap = {};\n      var $keyPrefix;\n      var $keyPrefixString;\n      var $prevKeyPrefixString;\n      var $prevKeyPrefix;\n      var $lastKeyPrefix;\n      var $current;\n      var $parent;\n      var previousPiece;\n      var buildIncludeMap = function buildIncludeMap(piece) {\n        if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {\n          includeMap[key] = $current = $current.includeMap[piece];\n          if (previousPiece) {\n            previousPiece = \"\".concat(previousPiece, \".\").concat(piece);\n          } else {\n            previousPiece = piece;\n          }\n          includeMap[previousPiece] = $current;\n        }\n      };\n      var keyPrefixStringMemo = {};\n      var keyPrefixString = function keyPrefixString(key2, memo) {\n        if (!Object.prototype.hasOwnProperty.call(memo, key2)) {\n          memo[key2] = key2.substr(0, key2.lastIndexOf(\".\"));\n        }\n        return memo[key2];\n      };\n      var removeKeyPrefixMemo = {};\n      var removeKeyPrefix = function removeKeyPrefix(key2) {\n        if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key2)) {\n          var index = key2.lastIndexOf(\".\");\n          removeKeyPrefixMemo[key2] = key2.substr(index === -1 ? 0 : index + 1);\n        }\n        return removeKeyPrefixMemo[key2];\n      };\n      var keyPrefixMemo = {};\n      var keyPrefix = function keyPrefix(key2) {\n        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key2)) {\n          var prefixString = keyPrefixString(key2, keyPrefixStringMemo);\n          if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {\n            keyPrefixMemo[prefixString] = prefixString ? prefixString.split(\".\") : [];\n          }\n          keyPrefixMemo[key2] = keyPrefixMemo[prefixString];\n        }\n        return keyPrefixMemo[key2];\n      };\n      var lastKeyPrefixMemo = {};\n      var lastKeyPrefix = function lastKeyPrefix(key2) {\n        if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key2)) {\n          var prefix2 = keyPrefix(key2);\n          var length2 = prefix2.length;\n          lastKeyPrefixMemo[key2] = !length2 ? \"\" : prefix2[length2 - 1];\n        }\n        return lastKeyPrefixMemo[key2];\n      };\n      var getUniqueKeyAttributes = function getUniqueKeyAttributes(model) {\n        var uniqueKeyAttributes2 = _.chain(model.uniqueKeys);\n        uniqueKeyAttributes2 = uniqueKeyAttributes2.result(\"\".concat(uniqueKeyAttributes2.findKey(), \".fields\")).map(function (field) {\n          return _.findKey(model.attributes, function (chr) {\n            return chr.field === field;\n          });\n        }).value();\n        return uniqueKeyAttributes2;\n      };\n      var stringify = function stringify(obj) {\n        return obj instanceof Buffer ? obj.toString(\"hex\") : obj;\n      };\n      var primaryKeyAttributes;\n      var uniqueKeyAttributes;\n      var prefix;\n      for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n        row = rows[rowsI];\n        if (rowsI === 0) {\n          keys = Object.keys(row);\n          keyLength = keys.length;\n        }\n        if (checkExisting) {\n          topExists = false;\n          $length = includeOptions.model.primaryKeyAttributes.length;\n          topHash = \"\";\n          if ($length === 1) {\n            topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);\n          } else if ($length > 1) {\n            for ($i = 0; $i < $length; $i++) {\n              topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);\n            }\n          } else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {\n            uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n            for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n              topHash += row[uniqueKeyAttributes[$i]];\n            }\n          }\n        }\n        topValues = values = {};\n        $prevKeyPrefix = void 0;\n        for (keyI = 0; keyI < keyLength; keyI++) {\n          key = keys[keyI];\n          $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n          $keyPrefix = keyPrefix(key);\n          if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {\n            if (!$keyPrefix.length) {\n              includeMap[key] = includeMap[\"\"] = includeOptions;\n            } else {\n              $current = includeOptions;\n              previousPiece = void 0;\n              $keyPrefix.forEach(buildIncludeMap);\n            }\n          }\n          if ($prevKeyPrefix !== void 0 && $prevKeyPrefix !== $keyPrefix) {\n            if (checkExisting) {\n              length = $prevKeyPrefix.length;\n              $parent = null;\n              parentHash = null;\n              if (length) {\n                for (i = 0; i < length; i++) {\n                  prefix = $parent ? \"\".concat($parent, \".\").concat($prevKeyPrefix[i]) : $prevKeyPrefix[i];\n                  primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                  $length = primaryKeyAttributes.length;\n                  itemHash = prefix;\n                  if ($length === 1) {\n                    itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[0])]);\n                  } else if ($length > 1) {\n                    for ($i = 0; $i < $length; $i++) {\n                      itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[$i])]);\n                    }\n                  } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                    uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                    for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                      itemHash += row[\"\".concat(prefix, \".\").concat(uniqueKeyAttributes[$i])];\n                    }\n                  }\n                  if (!parentHash) {\n                    parentHash = topHash;\n                  }\n                  itemHash = parentHash + itemHash;\n                  $parent = prefix;\n                  if (i < length - 1) {\n                    parentHash = itemHash;\n                  }\n                }\n              } else {\n                itemHash = topHash;\n              }\n              if (itemHash === topHash) {\n                if (!resultMap[itemHash]) {\n                  resultMap[itemHash] = values;\n                } else {\n                  topExists = true;\n                }\n              } else if (!resultMap[itemHash]) {\n                $parent = resultMap[parentHash];\n                $lastKeyPrefix = lastKeyPrefix(prevKey);\n                if (includeMap[prevKey].association.isSingleAssociation) {\n                  if ($parent) {\n                    $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                  }\n                } else {\n                  if (!$parent[$lastKeyPrefix]) {\n                    $parent[$lastKeyPrefix] = [];\n                  }\n                  $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n                }\n              }\n              values = {};\n            } else {\n              $current = topValues;\n              length = $keyPrefix.length;\n              if (length) {\n                for (i = 0; i < length; i++) {\n                  if (i === length - 1) {\n                    values = $current[$keyPrefix[i]] = {};\n                  }\n                  $current = $current[$keyPrefix[i]] || {};\n                }\n              }\n            }\n          }\n          values[removeKeyPrefix(key)] = row[key];\n          prevKey = key;\n          $prevKeyPrefix = $keyPrefix;\n          $prevKeyPrefixString = $keyPrefixString;\n        }\n        if (checkExisting) {\n          length = $prevKeyPrefix.length;\n          $parent = null;\n          parentHash = null;\n          if (length) {\n            for (i = 0; i < length; i++) {\n              prefix = $parent ? \"\".concat($parent, \".\").concat($prevKeyPrefix[i]) : $prevKeyPrefix[i];\n              primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n              $length = primaryKeyAttributes.length;\n              itemHash = prefix;\n              if ($length === 1) {\n                itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[0])]);\n              } else if ($length > 0) {\n                for ($i = 0; $i < $length; $i++) {\n                  itemHash += stringify(row[\"\".concat(prefix, \".\").concat(primaryKeyAttributes[$i])]);\n                }\n              } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                  itemHash += row[\"\".concat(prefix, \".\").concat(uniqueKeyAttributes[$i])];\n                }\n              }\n              if (!parentHash) {\n                parentHash = topHash;\n              }\n              itemHash = parentHash + itemHash;\n              $parent = prefix;\n              if (i < length - 1) {\n                parentHash = itemHash;\n              }\n            }\n          } else {\n            itemHash = topHash;\n          }\n          if (itemHash === topHash) {\n            if (!resultMap[itemHash]) {\n              resultMap[itemHash] = values;\n            } else {\n              topExists = true;\n            }\n          } else if (!resultMap[itemHash]) {\n            $parent = resultMap[parentHash];\n            $lastKeyPrefix = lastKeyPrefix(prevKey);\n            if (includeMap[prevKey].association.isSingleAssociation) {\n              if ($parent) {\n                $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n              }\n            } else {\n              if (!$parent[$lastKeyPrefix]) {\n                $parent[$lastKeyPrefix] = [];\n              }\n              $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n            }\n          }\n          if (!topExists) {\n            results.push(topValues);\n          }\n        } else {\n          results[rowsI] = topValues;\n        }\n      }\n      return results;\n    }\n  }]);\n  return AbstractQuery;\n}();\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports.default = AbstractQuery;","map":{"version":3,"names":["_","require","SqlString","QueryTypes","Dot","deprecations","uuid","v4","_require","safeStringifyJson","AbstractQuery","connection","sequelize","options","_classCallCheck","instance","model","__spreadValues","plain","raw","logging","console","log","checkLoggingOption","rawErrors","formatError","prototype","_createClass","key","value","error","errStack","stack","run","Error","noTrueLogging","getInsertIdField","getUniqueConstraintErrorMessage","field","message","concat","_i","_Object$keys","Object","keys","uniqueKeys","length","fields","includes","replace","msg","isRawQuery","type","RAW","isVersionQuery","VERSION","isUpsertQuery","UPSERT","isInsertQuery","results","metaData","result","INSERT","sql","toLowerCase","startsWith","hasOwnProperty","call","handleInsertQuery","autoIncrementAttribute","id","isShowTablesQuery","SHOWTABLES","handleShowTablesQuery","flatten","map","resultSet","values","isShowIndexesQuery","SHOWINDEXES","isShowConstraintsQuery","SHOWCONSTRAINTS","isDescribeQuery","DESCRIBE","isSelectQuery","SELECT","isBulkUpdateQuery","BULKUPDATE","isBulkDeleteQuery","BULKDELETE","isForeignKeysQuery","FOREIGNKEYS","isUpdateQuery","UPDATE","handleSelectQuery","_this","fieldMap","result2","reduce","result3","name","o","nest","transform","hasJoin","_groupJoinData","includeMap","includeNames","checkExisting","hasMultiAssociation","bulkBuild","isNewRecord","include","includeValidated","attributes","originalAttributes","isShowOrDescribeQuery","isCallQuery","_logQuery","debugContext","parameters","_this2","benchmark","logQueryParameters","startTime","Date","now","logParameter","delimiter","endsWith","paramStr","Array","isArray","p","join","fmt","afterMsg","formatBindParameters","dialect","replacementFunc","skipValueReplace","match","values2","timeZone2","dialect2","escape","origReplacementFunc","options2","timeZone","list","skipUnescape","replVal","rows","includeOptions","i","$i","$length","rowsI","row","rowsLength","keyI","keyLength","prevKey","topValues","topExists","itemHash","parentHash","topHash","resultMap","$keyPrefix","$keyPrefixString","$prevKeyPrefixString","$prevKeyPrefix","$lastKeyPrefix","$current","$parent","previousPiece","buildIncludeMap","piece","keyPrefixStringMemo","keyPrefixString","key2","memo","substr","lastIndexOf","removeKeyPrefixMemo","removeKeyPrefix","index","keyPrefixMemo","keyPrefix","prefixString","split","lastKeyPrefixMemo","lastKeyPrefix","prefix2","length2","getUniqueKeyAttributes","uniqueKeyAttributes2","chain","findKey","chr","stringify","obj","Buffer","toString","primaryKeyAttributes","uniqueKeyAttributes","prefix","isEmpty","forEach","association","isSingleAssociation","push","module","exports","default"],"sources":["../../../src/dialects/abstract/query.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst SqlString = require('../../sql-string');\nconst QueryTypes = require('../../query-types');\nconst Dot = require('dottie');\nconst deprecations = require('../../utils/deprecations');\nconst uuid = require('uuid').v4;\nconst { safeStringifyJson } = require('../../utils.js');\n\nclass AbstractQuery {\n\n  constructor(connection, sequelize, options) {\n    this.uuid = uuid();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = {\n      plain: false,\n      raw: false,\n      // eslint-disable-next-line no-console\n      logging: console.log,\n      ...options\n    };\n    this.checkLoggingOption();\n\n    if (options.rawErrors) {\n      // The default implementation in AbstractQuery just returns the same\n      // error object. By overidding this.formatError, this saves every dialect\n      // having to check for options.rawErrors in their own formatError\n      // implementations.\n      this.formatError = AbstractQuery.prototype.formatError;\n    }\n  }\n\n  /**\n   * rewrite query with parameters\n   *\n   * Examples:\n   *\n   *   query.formatBindParameters('select $1 as foo', ['fooval']);\n   *\n   *   query.formatBindParameters('select $foo as foo', { foo: 'fooval' });\n   *\n   * Options\n   *   skipUnescape: bool, skip unescaping $$\n   *   skipValueReplace: bool, do not replace (but do unescape $$). Check correct syntax and if all values are available\n   *\n   * @param {string} sql\n   * @param {object|Array} values\n   * @param {string} dialect\n   * @param {Function} [replacementFunc]\n   * @param {object} [options]\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect, replacementFunc, options) {\n    if (!values) {\n      return [sql, []];\n    }\n\n    options = options || {};\n    if (typeof replacementFunc !== 'function') {\n      options = replacementFunc || {};\n      replacementFunc = undefined;\n    }\n\n    if (!replacementFunc) {\n      if (options.skipValueReplace) {\n        replacementFunc = (match, key, values) => {\n          if (values[key] !== undefined) {\n            return match;\n          }\n          return undefined;\n        };\n      } else {\n        replacementFunc = (match, key, values, timeZone, dialect) => {\n          if (values[key] !== undefined) {\n            return SqlString.escape(values[key], timeZone, dialect);\n          }\n          return undefined;\n        };\n      }\n    } else if (options.skipValueReplace) {\n      const origReplacementFunc = replacementFunc;\n      replacementFunc = (match, key, values, timeZone, dialect, options) => {\n        if (origReplacementFunc(match, key, values, timeZone, dialect, options) !== undefined) {\n          return match;\n        }\n        return undefined;\n      };\n    }\n\n    const timeZone = null;\n    const list = Array.isArray(values);\n    sql = sql.replace(/\\B\\$(\\$|\\w+)/g, (match, key) => {\n      if ('$' === key) {\n        return options.skipUnescape ? match : key;\n      }\n\n      let replVal;\n      if (list) {\n        if (key.match(/^[1-9]\\d*$/)) {\n          key = key - 1;\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n      } else if (!key.match(/^\\d*$/)) {\n        replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n      }\n      if (replVal === undefined) {\n        throw new Error(`Named bind parameter \"${match}\" has no value in the given object.`);\n      }\n      return replVal;\n    });\n    return [sql, []];\n  }\n\n  /**\n   * Formats a raw database error from the database library into a common Sequelize exception.\n   *\n   * @param {Error} error The exception object.\n   * @param {object} errStack The stack trace that started the database query.\n   * @returns {BaseError} the new formatted error object.\n   */\n  formatError(error, errStack) {\n    // Default implementation, no formatting.\n    // Each dialect overrides this method to parse errors from their respective the database engines.\n    error.stack = errStack;\n\n    return error;\n  }\n\n  /**\n   * Execute the passed sql query.\n   *\n   * Examples:\n   *\n   *     query.run('SELECT 1')\n   *\n   * @private\n   */\n  run() {\n    throw new Error('The run method wasn\\'t overwritten!');\n  }\n\n  /**\n   * Check the logging option of the instance and print deprecation warnings.\n   *\n   * @private\n   */\n  checkLoggingOption() {\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      // eslint-disable-next-line no-console\n      this.options.logging = console.log;\n    }\n  }\n\n  /**\n   * Get the attributes of an insert query, which contains the just inserted id.\n   *\n   * @returns {string} The field name.\n   * @private\n   */\n  getInsertIdField() {\n    return 'insertId';\n  }\n\n  getUniqueConstraintErrorMessage(field) {\n    let message = field ? `${field} must be unique` : 'Must be unique';\n\n    if (field && this.model) {\n      for (const key of Object.keys(this.model.uniqueKeys)) {\n        if (this.model.uniqueKeys[key].fields.includes(field.replace(/\"/g, ''))) {\n          if (this.model.uniqueKeys[key].msg) {\n            message = this.model.uniqueKeys[key].msg;\n          }\n        }\n      }\n    }\n    return message;\n  }\n\n  isRawQuery() {\n    return this.options.type === QueryTypes.RAW;\n  }\n\n  isVersionQuery() {\n    return this.options.type === QueryTypes.VERSION;\n  }\n\n  isUpsertQuery() {\n    return this.options.type === QueryTypes.UPSERT;\n  }\n\n  isInsertQuery(results, metaData) {\n    let result = true;\n\n    if (this.options.type === QueryTypes.INSERT) {\n      return true;\n    }\n\n    // is insert query if sql contains insert into\n    result = result && this.sql.toLowerCase().startsWith('insert into');\n\n    // is insert query if no results are passed or if the result has the inserted id\n    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));\n\n    // is insert query if no metadata are passed or if the metadata has the inserted id\n    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));\n\n    return result;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      // add the inserted row id to the instance\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n\n      id = id || results && results[this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n\n  isShowTablesQuery() {\n    return this.options.type === QueryTypes.SHOWTABLES;\n  }\n\n  handleShowTablesQuery(results) {\n    return _.flatten(results.map(resultSet => Object.values(resultSet)));\n  }\n\n  isShowIndexesQuery() {\n    return this.options.type === QueryTypes.SHOWINDEXES;\n  }\n\n  isShowConstraintsQuery() {\n    return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n  }\n\n  isDescribeQuery() {\n    return this.options.type === QueryTypes.DESCRIBE;\n  }\n\n  isSelectQuery() {\n    return this.options.type === QueryTypes.SELECT;\n  }\n\n  isBulkUpdateQuery() {\n    return this.options.type === QueryTypes.BULKUPDATE;\n  }\n\n  isBulkDeleteQuery() {\n    return this.options.type === QueryTypes.BULKDELETE;\n  }\n\n  isForeignKeysQuery() {\n    return this.options.type === QueryTypes.FOREIGNKEYS;\n  }\n\n  isUpdateQuery() {\n    return this.options.type === QueryTypes.UPDATE;\n  }\n\n  handleSelectQuery(results) {\n    let result = null;\n\n    // Map raw fields to names if a mapping is provided\n    if (this.options.fieldMap) {\n      const fieldMap = this.options.fieldMap;\n      results = results.map(result => _.reduce(fieldMap, (result, name, field) => {\n        if (result[field] !== undefined && name !== field) {\n          result[name] = result[field];\n          delete result[field];\n        }\n        return result;\n      }, result));\n    }\n\n    // Raw queries\n    if (this.options.raw) {\n      result = results.map(result => {\n        let o = {};\n\n        for (const key in result) {\n          if (Object.prototype.hasOwnProperty.call(result, key)) {\n            o[key] = result[key];\n          }\n        }\n\n        if (this.options.nest) {\n          o = Dot.transform(o);\n        }\n\n        return o;\n      });\n    // Queries with include\n    } else if (this.options.hasJoin === true) {\n      results = AbstractQuery._groupJoinData(results, {\n        model: this.model,\n        includeMap: this.options.includeMap,\n        includeNames: this.options.includeNames\n      }, {\n        checkExisting: this.options.hasMultiAssociation\n      });\n\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        include: this.options.include,\n        includeNames: this.options.includeNames,\n        includeMap: this.options.includeMap,\n        includeValidated: true,\n        attributes: this.options.originalAttributes || this.options.attributes,\n        raw: true\n      });\n    // Regular queries\n    } else {\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        raw: true,\n        attributes: this.options.originalAttributes || this.options.attributes\n      });\n    }\n\n    // return the first real model instance if options.plain is set (e.g. Model.find)\n    if (this.options.plain) {\n      result = result.length === 0 ? null : result[0];\n    }\n    return result;\n  }\n\n  isShowOrDescribeQuery() {\n    let result = false;\n\n    result = result || this.sql.toLowerCase().startsWith('show');\n    result = result || this.sql.toLowerCase().startsWith('describe');\n\n    return result;\n  }\n\n  isCallQuery() {\n    return this.sql.toLowerCase().startsWith('call');\n  }\n\n  /**\n   * @param {string} sql\n   * @param {Function} debugContext\n   * @param {Array|object} parameters\n   * @protected\n   * @returns {Function} A function to call after the query was completed.\n   */\n  _logQuery(sql, debugContext, parameters) {\n    const { connection, options } = this;\n    const benchmark = this.sequelize.options.benchmark || options.benchmark;\n    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;\n    const startTime = Date.now();\n    let logParameter = '';\n\n    if (logQueryParameters && parameters) {\n      const delimiter = sql.endsWith(';') ? '' : ';';\n      let paramStr;\n      if (Array.isArray(parameters)) {\n        paramStr = parameters.map(p=>safeStringifyJson(p)).join(', ');\n      } else {\n        paramStr = safeStringifyJson(parameters);\n      }\n      logParameter = `${delimiter} ${paramStr}`;\n    }\n    const fmt = `(${connection.uuid || 'default'}): ${sql}${logParameter}`;\n    const msg = `Executing ${fmt}`;\n    debugContext(msg);\n    if (!benchmark) {\n      this.sequelize.log(`Executing ${fmt}`, options);\n    }\n    return () => {\n      const afterMsg = `Executed ${fmt}`;\n      debugContext(afterMsg);\n      if (benchmark) {\n        this.sequelize.log(afterMsg, Date.now() - startTime, options);\n      }\n    };\n  }\n\n  /**\n   * The function takes the result of the query execution and groups\n   * the associated data by the callee.\n   *\n   * Example:\n   *   groupJoinData([\n   *     {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 1 }\n   *     }, {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 2 }\n   *     }, {\n   *       some: 'data',\n   *       id: 1,\n   *       association: { foo: 'bar', id: 3 }\n   *     }\n   *   ])\n   *\n   * Result:\n   *   Something like this:\n   *\n   *   [\n   *     {\n   *       some: 'data',\n   *       id: 1,\n   *       association: [\n   *         { foo: 'bar', id: 1 },\n   *         { foo: 'bar', id: 2 },\n   *         { foo: 'bar', id: 3 }\n   *       ]\n   *     }\n   *   ]\n   *\n   * @param {Array} rows\n   * @param {object} includeOptions\n   * @param {object} options\n   * @private\n   */\n  static _groupJoinData(rows, includeOptions, options) {\n\n    /*\n     * Assumptions\n     * ID is not necessarily the first field\n     * All fields for a level is grouped in the same set (i.e. Panel.id, Task.id, Panel.title is not possible)\n     * Parent keys will be seen before any include/child keys\n     * Previous set won't necessarily be parent set (one parent could have two children, one child would then be previous set for the other)\n     */\n\n    /*\n     * Author (MH) comment: This code is an unreadable mess, but it's performant.\n     * groupJoinData is a performance critical function so we prioritize perf over readability.\n     */\n    if (!rows.length) {\n      return [];\n    }\n\n    // Generic looping\n    let i;\n    let length;\n    let $i;\n    let $length;\n    // Row specific looping\n    let rowsI;\n    let row;\n    const rowsLength = rows.length;\n    // Key specific looping\n    let keys;\n    let key;\n    let keyI;\n    let keyLength;\n    let prevKey;\n    let values;\n    let topValues;\n    let topExists;\n    const checkExisting = options.checkExisting;\n    // If we don't have to deduplicate we can pre-allocate the resulting array\n    let itemHash;\n    let parentHash;\n    let topHash;\n    const results = checkExisting ? [] : new Array(rowsLength);\n    const resultMap = {};\n    const includeMap = {};\n    // Result variables for the respective functions\n    let $keyPrefix;\n    let $keyPrefixString;\n    let $prevKeyPrefixString; // eslint-disable-line\n    let $prevKeyPrefix;\n    let $lastKeyPrefix;\n    let $current;\n    let $parent;\n    // Map each key to an include option\n    let previousPiece;\n    const buildIncludeMap = piece => {\n      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {\n        includeMap[key] = $current = $current.includeMap[piece];\n        if (previousPiece) {\n          previousPiece = `${previousPiece}.${piece}`;\n        } else {\n          previousPiece = piece;\n        }\n        includeMap[previousPiece] = $current;\n      }\n    };\n    // Calculate the string prefix of a key ('User.Results' for 'User.Results.id')\n    const keyPrefixStringMemo = {};\n    const keyPrefixString = (key, memo) => {\n      if (!Object.prototype.hasOwnProperty.call(memo, key)) {\n        memo[key] = key.substr(0, key.lastIndexOf('.'));\n      }\n      return memo[key];\n    };\n    // Removes the prefix from a key ('id' for 'User.Results.id')\n    const removeKeyPrefixMemo = {};\n    const removeKeyPrefix = key => {\n      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key)) {\n        const index = key.lastIndexOf('.');\n        removeKeyPrefixMemo[key] = key.substr(index === -1 ? 0 : index + 1);\n      }\n      return removeKeyPrefixMemo[key];\n    };\n    // Calculates the array prefix of a key (['User', 'Results'] for 'User.Results.id')\n    const keyPrefixMemo = {};\n    const keyPrefix = key => {\n      // We use a double memo and keyPrefixString so that different keys with the same prefix will receive the same array instead of differnet arrays with equal values\n      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key)) {\n        const prefixString = keyPrefixString(key, keyPrefixStringMemo);\n        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {\n          keyPrefixMemo[prefixString] = prefixString ? prefixString.split('.') : [];\n        }\n        keyPrefixMemo[key] = keyPrefixMemo[prefixString];\n      }\n      return keyPrefixMemo[key];\n    };\n    // Calcuate the last item in the array prefix ('Results' for 'User.Results.id')\n    const lastKeyPrefixMemo = {};\n    const lastKeyPrefix = key => {\n      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key)) {\n        const prefix = keyPrefix(key);\n        const length = prefix.length;\n\n        lastKeyPrefixMemo[key] = !length ? '' : prefix[length - 1];\n      }\n      return lastKeyPrefixMemo[key];\n    };\n    const getUniqueKeyAttributes = model => {\n      let uniqueKeyAttributes = _.chain(model.uniqueKeys);\n      uniqueKeyAttributes = uniqueKeyAttributes\n        .result(`${uniqueKeyAttributes.findKey()}.fields`)\n        .map(field => _.findKey(model.attributes, chr => chr.field === field))\n        .value();\n\n      return uniqueKeyAttributes;\n    };\n    const stringify = obj => obj instanceof Buffer ? obj.toString('hex') : obj;\n    let primaryKeyAttributes;\n    let uniqueKeyAttributes;\n    let prefix;\n\n    for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n      row = rows[rowsI];\n\n      // Keys are the same for all rows, so only need to compute them on the first row\n      if (rowsI === 0) {\n        keys = Object.keys(row);\n        keyLength = keys.length;\n      }\n\n      if (checkExisting) {\n        topExists = false;\n\n        // Compute top level hash key (this is usually just the primary key values)\n        $length = includeOptions.model.primaryKeyAttributes.length;\n        topHash = '';\n        if ($length === 1) {\n          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);\n        }\n        else if ($length > 1) {\n          for ($i = 0; $i < $length; $i++) {\n            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);\n          }\n        }\n        else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {\n          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n            topHash += row[uniqueKeyAttributes[$i]];\n          }\n        }\n      }\n\n      topValues = values = {};\n      $prevKeyPrefix = undefined;\n      for (keyI = 0; keyI < keyLength; keyI++) {\n        key = keys[keyI];\n\n        // The string prefix isn't actualy needed\n        // We use it so keyPrefix for different keys will resolve to the same array if they have the same prefix\n        // TODO: Find a better way?\n        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n        $keyPrefix = keyPrefix(key);\n\n        // On the first row we compute the includeMap\n        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {\n          if (!$keyPrefix.length) {\n            includeMap[key] = includeMap[''] = includeOptions;\n          } else {\n            $current = includeOptions;\n            previousPiece = undefined;\n            $keyPrefix.forEach(buildIncludeMap);\n          }\n        }\n        // End of key set\n        if ($prevKeyPrefix !== undefined && $prevKeyPrefix !== $keyPrefix) {\n          if (checkExisting) {\n            // Compute hash key for this set instance\n            // TODO: Optimize\n            length = $prevKeyPrefix.length;\n            $parent = null;\n            parentHash = null;\n\n            if (length) {\n              for (i = 0; i < length; i++) {\n                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                $length = primaryKeyAttributes.length;\n                itemHash = prefix;\n                if ($length === 1) {\n                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n                }\n                else if ($length > 1) {\n                  for ($i = 0; $i < $length; $i++) {\n                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n                  }\n                }\n                else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n                  }\n                }\n                if (!parentHash) {\n                  parentHash = topHash;\n                }\n\n                itemHash = parentHash + itemHash;\n                $parent = prefix;\n                if (i < length - 1) {\n                  parentHash = itemHash;\n                }\n              }\n            } else {\n              itemHash = topHash;\n            }\n\n            if (itemHash === topHash) {\n              if (!resultMap[itemHash]) {\n                resultMap[itemHash] = values;\n              } else {\n                topExists = true;\n              }\n            } else if (!resultMap[itemHash]) {\n              $parent = resultMap[parentHash];\n              $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n              if (includeMap[prevKey].association.isSingleAssociation) {\n                if ($parent) {\n                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                }\n              } else {\n                if (!$parent[$lastKeyPrefix]) {\n                  $parent[$lastKeyPrefix] = [];\n                }\n                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n              }\n            }\n\n            // Reset values\n            values = {};\n          } else {\n            // If checkExisting is false it's because there's only 1:1 associations in this query\n            // However we still need to map onto the appropriate parent\n            // For 1:1 we map forward, initializing the value object on the parent to be filled in the next iterations of the loop\n            $current = topValues;\n            length = $keyPrefix.length;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                if (i === length - 1) {\n                  values = $current[$keyPrefix[i]] = {};\n                }\n                $current = $current[$keyPrefix[i]] || {};\n              }\n            }\n          }\n        }\n\n        // End of iteration, set value and set prev values (for next iteration)\n        values[removeKeyPrefix(key)] = row[key];\n        prevKey = key;\n        $prevKeyPrefix = $keyPrefix;\n        $prevKeyPrefixString = $keyPrefixString;\n      }\n\n      if (checkExisting) {\n        length = $prevKeyPrefix.length;\n        $parent = null;\n        parentHash = null;\n\n        if (length) {\n          for (i = 0; i < length; i++) {\n            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n            $length = primaryKeyAttributes.length;\n            itemHash = prefix;\n            if ($length === 1) {\n              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n            }\n            else if ($length > 0) {\n              for ($i = 0; $i < $length; $i++) {\n                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n              }\n            }\n            else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n              }\n            }\n            if (!parentHash) {\n              parentHash = topHash;\n            }\n\n            itemHash = parentHash + itemHash;\n            $parent = prefix;\n            if (i < length - 1) {\n              parentHash = itemHash;\n            }\n          }\n        } else {\n          itemHash = topHash;\n        }\n\n        if (itemHash === topHash) {\n          if (!resultMap[itemHash]) {\n            resultMap[itemHash] = values;\n          } else {\n            topExists = true;\n          }\n        } else if (!resultMap[itemHash]) {\n          $parent = resultMap[parentHash];\n          $lastKeyPrefix = lastKeyPrefix(prevKey);\n\n          if (includeMap[prevKey].association.isSingleAssociation) {\n            if ($parent) {\n              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n            }\n          } else {\n            if (!$parent[$lastKeyPrefix]) {\n              $parent[$lastKeyPrefix] = [];\n            }\n            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n          }\n        }\n        if (!topExists) {\n          results.push(topValues);\n        }\n      } else {\n        results[rowsI] = topValues;\n      }\n    }\n\n    return results;\n  }\n}\n\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports.default = AbstractQuery;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}