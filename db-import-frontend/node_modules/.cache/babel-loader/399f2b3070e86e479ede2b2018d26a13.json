{"ast":null,"code":"import _defineProperty from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A set of constants used internally when processing requests.\n */\nvar Constants = {\n  DefaultScope: \"/.default\",\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\"\n  }\n};\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport var authorizeRequestOnTenantChallenge = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(challengeOptions) {\n    var requestOptions, challenge, challengeInfo, challengeScopes, tenantId, accessToken;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          requestOptions = requestToOptions(challengeOptions.request);\n          challenge = getChallenge(challengeOptions.response);\n          if (!challenge) {\n            _context.next = 13;\n            break;\n          }\n          challengeInfo = parseChallenge(challenge);\n          challengeScopes = buildScopes(challengeOptions, challengeInfo);\n          tenantId = extractTenantId(challengeInfo);\n          _context.next = 8;\n          return challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), {\n            tenantId: tenantId\n          }));\n        case 8:\n          accessToken = _context.sent;\n          if (accessToken) {\n            _context.next = 11;\n            break;\n          }\n          return _context.abrupt(\"return\", false);\n        case 11:\n          challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, \"Bearer \".concat(accessToken.token));\n          return _context.abrupt(\"return\", true);\n        case 13:\n          return _context.abrupt(\"return\", false);\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function authorizeRequestOnTenantChallenge(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n  var parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  var pathSegments = parsedAuthUri.pathname.split(\"/\");\n  var tenantId = pathSegments[1];\n  return tenantId;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n  if (!challengeInfo.resource_uri) {\n    return challengeOptions.scopes;\n  }\n  var challengeScopes = new URL(challengeInfo.resource_uri);\n  challengeScopes.pathname = Constants.DefaultScope;\n  return [challengeScopes.toString()];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n  var challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n  var bearerChallenge = challenge.slice(\"Bearer \".length);\n  var challengeParts = \"\".concat(bearerChallenge.trim(), \" \").split(\" \").filter(function (x) {\n    return x;\n  });\n  var keyValuePairs = challengeParts.map(function (keyValue) {\n    return function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        key = _ref3[0],\n        value = _ref3[1];\n      return _defineProperty({}, key, value);\n    }(keyValue.trim().split(\"=\"));\n  });\n  // Key-value pairs to plain object:\n  return keyValuePairs.reduce(function (a, b) {\n    return Object.assign(Object.assign({}, a), b);\n  }, {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout\n    },\n    tracingOptions: request.tracingOptions\n  };\n}","map":{"version":3,"names":["Constants","DefaultScope","HeaderConstants","AUTHORIZATION","authorizeRequestOnTenantChallenge","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","challengeOptions","requestOptions","challenge","challengeInfo","challengeScopes","tenantId","accessToken","wrap","_callee$","_context","prev","next","requestToOptions","request","getChallenge","response","parseChallenge","buildScopes","extractTenantId","getAccessToken","Object","assign","sent","abrupt","headers","set","concat","token","stop","_x","apply","arguments","parsedAuthUri","URL","authorization_uri","pathSegments","pathname","split","resource_uri","scopes","toString","get","status","bearerChallenge","slice","length","challengeParts","trim","filter","x","keyValuePairs","map","keyValue","_ref2","_ref3","_slicedToArray","key","value","_defineProperty","reduce","a","b","abortSignal","timeout","tracingOptions"],"sources":["../../src/authorizeRequestOnTenantChallenge.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AuthorizeRequestOnChallengeOptions,\n  PipelineRequest,\n  PipelineResponse,\n} from \"@azure/core-rest-pipeline\";\n\nimport { GetTokenOptions } from \"@azure/core-auth\";\n\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n  DefaultScope: \"/.default\",\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\",\n  },\n};\n\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge: (\n  challengeOptions: AuthorizeRequestOnChallengeOptions\n) => Promise<boolean> = async (challengeOptions) => {\n  const requestOptions = requestToOptions(challengeOptions.request);\n  const challenge = getChallenge(challengeOptions.response);\n  if (challenge) {\n    const challengeInfo: Challenge = parseChallenge(challenge);\n    const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n    const tenantId = extractTenantId(challengeInfo);\n    const accessToken = await challengeOptions.getAccessToken(challengeScopes, {\n      ...requestOptions,\n      tenantId,\n    });\n\n    if (!accessToken) {\n      return false;\n    }\n\n    challengeOptions.request.headers.set(\n      Constants.HeaderConstants.AUTHORIZATION,\n      `Bearer ${accessToken.token}`\n    );\n    return true;\n  }\n  return false;\n};\n\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo: Challenge): string {\n  const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  const pathSegments = parsedAuthUri.pathname.split(\"/\");\n  const tenantId = pathSegments[1];\n\n  return tenantId;\n}\n\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(\n  challengeOptions: AuthorizeRequestOnChallengeOptions,\n  challengeInfo: Challenge\n): string[] {\n  if (!challengeInfo.resource_uri) {\n    return challengeOptions.scopes;\n  }\n\n  const challengeScopes = new URL(challengeInfo.resource_uri);\n  challengeScopes.pathname = Constants.DefaultScope;\n  return [challengeScopes.toString()];\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * Challenge structure\n */\ninterface Challenge {\n  authorization_uri: string;\n  resource_uri?: string;\n}\n\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge: string): Challenge {\n  const bearerChallenge = challenge.slice(\"Bearer \".length);\n  const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter((x) => x);\n  const keyValuePairs = challengeParts.map((keyValue) =>\n    (([key, value]) => ({ [key]: value }))(keyValue.trim().split(\"=\"))\n  );\n  // Key-value pairs to plain object:\n  return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {} as Challenge);\n}\n\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request: PipelineRequest): GetTokenOptions {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout,\n    },\n    tracingOptions: request.tracingOptions,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}