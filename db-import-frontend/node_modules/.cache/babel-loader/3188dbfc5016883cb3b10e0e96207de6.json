{"ast":null,"code":"import _slicedToArray from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as base64 from \"./base64\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces\";\nimport { isDuration, isValidUuid } from \"./utils\";\nvar SerializerImpl = /*#__PURE__*/function () {\n  function SerializerImpl() {\n    var modelMappers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var isXML = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    _classCallCheck(this, SerializerImpl);\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n  /**\n   * @deprecated Removing the constraints validation on client side.\n   */\n  _createClass(SerializerImpl, [{\n    key: \"validateConstraints\",\n    value: function validateConstraints(mapper, value, objectName) {\n      var failValidation = function failValidation(constraintName, constraintValue) {\n        throw new Error(\"\\\"\".concat(objectName, \"\\\" with value \\\"\").concat(value, \"\\\" should satisfy the constraint \\\"\").concat(constraintName, \"\\\": \").concat(constraintValue, \".\"));\n      };\n      if (mapper.constraints && value !== undefined && value !== null) {\n        var _mapper$constraints = mapper.constraints,\n          ExclusiveMaximum = _mapper$constraints.ExclusiveMaximum,\n          ExclusiveMinimum = _mapper$constraints.ExclusiveMinimum,\n          InclusiveMaximum = _mapper$constraints.InclusiveMaximum,\n          InclusiveMinimum = _mapper$constraints.InclusiveMinimum,\n          MaxItems = _mapper$constraints.MaxItems,\n          MaxLength = _mapper$constraints.MaxLength,\n          MinItems = _mapper$constraints.MinItems,\n          MinLength = _mapper$constraints.MinLength,\n          MultipleOf = _mapper$constraints.MultipleOf,\n          Pattern = _mapper$constraints.Pattern,\n          UniqueItems = _mapper$constraints.UniqueItems;\n        if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n          failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n        }\n        if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n          failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n        }\n        if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n          failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n        }\n        if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n          failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n        }\n        if (MaxItems !== undefined && value.length > MaxItems) {\n          failValidation(\"MaxItems\", MaxItems);\n        }\n        if (MaxLength !== undefined && value.length > MaxLength) {\n          failValidation(\"MaxLength\", MaxLength);\n        }\n        if (MinItems !== undefined && value.length < MinItems) {\n          failValidation(\"MinItems\", MinItems);\n        }\n        if (MinLength !== undefined && value.length < MinLength) {\n          failValidation(\"MinLength\", MinLength);\n        }\n        if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n          failValidation(\"MultipleOf\", MultipleOf);\n        }\n        if (Pattern) {\n          var pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n          if (typeof value !== \"string\" || value.match(pattern) === null) {\n            failValidation(\"Pattern\", Pattern);\n          }\n        }\n        if (UniqueItems && value.some(function (item, i, ar) {\n          return ar.indexOf(item) !== i;\n        })) {\n          failValidation(\"UniqueItems\", UniqueItems);\n        }\n      }\n    }\n    /**\n     * Serialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param object - A valid Javascript object to be serialized\n     *\n     * @param objectName - Name of the serialized object\n     *\n     * @param options - additional options to serialization\n     *\n     * @returns A valid serialized Javascript object\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize(mapper, object, objectName) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        xml: {}\n      };\n      var _a, _b, _c;\n      var updatedOptions = {\n        xml: {\n          rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n          includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n          xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n        }\n      };\n      var payload = {};\n      var mapperType = mapper.type.name;\n      if (!objectName) {\n        objectName = mapper.serializedName;\n      }\n      if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = [];\n      }\n      if (mapper.isConstant) {\n        object = mapper.defaultValue;\n      }\n      // This table of allowed values should help explain\n      // the mapper.required and mapper.nullable properties.\n      // X means \"neither undefined or null are allowed\".\n      //           || required\n      //           || true      | false\n      //  nullable || ==========================\n      //      true || null      | undefined/null\n      //     false || X         | undefined\n      // undefined || X         | undefined/null\n      var required = mapper.required,\n        nullable = mapper.nullable;\n      if (required && nullable && object === undefined) {\n        throw new Error(\"\".concat(objectName, \" cannot be undefined.\"));\n      }\n      if (required && !nullable && (object === undefined || object === null)) {\n        throw new Error(\"\".concat(objectName, \" cannot be null or undefined.\"));\n      }\n      if (!required && nullable === false && object === null) {\n        throw new Error(\"\".concat(objectName, \" cannot be null.\"));\n      }\n      if (object === undefined || object === null) {\n        payload = object;\n      } else {\n        if (mapperType.match(/^any$/i) !== null) {\n          payload = object;\n        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n          payload = serializeBasicTypes(mapperType, objectName, object);\n        } else if (mapperType.match(/^Enum$/i) !== null) {\n          var enumMapper = mapper;\n          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n          payload = serializeDateTypes(mapperType, object, objectName);\n        } else if (mapperType.match(/^ByteArray$/i) !== null) {\n          payload = serializeByteArrayType(objectName, object);\n        } else if (mapperType.match(/^Base64Url$/i) !== null) {\n          payload = serializeBase64UrlType(objectName, object);\n        } else if (mapperType.match(/^Sequence$/i) !== null) {\n          payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n        } else if (mapperType.match(/^Dictionary$/i) !== null) {\n          payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n        } else if (mapperType.match(/^Composite$/i) !== null) {\n          payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n        }\n      }\n      return payload;\n    }\n    /**\n     * Deserialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param responseBody - A valid Javascript entity to be deserialized\n     *\n     * @param objectName - Name of the deserialized object\n     *\n     * @param options - Controls behavior of XML parser and builder.\n     *\n     * @returns A valid deserialized Javascript object\n     */\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(mapper, responseBody, objectName) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        xml: {}\n      };\n      var _a, _b, _c, _d;\n      var updatedOptions = {\n        xml: {\n          rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n          includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n          xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n        },\n        ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false\n      };\n      if (responseBody === undefined || responseBody === null) {\n        if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n          // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n          // between the list being empty versus being missing,\n          // so let's do the more user-friendly thing and return an empty list.\n          responseBody = [];\n        }\n        // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n        if (mapper.defaultValue !== undefined) {\n          responseBody = mapper.defaultValue;\n        }\n        return responseBody;\n      }\n      var payload;\n      var mapperType = mapper.type.name;\n      if (!objectName) {\n        objectName = mapper.serializedName;\n      }\n      if (mapperType.match(/^Composite$/i) !== null) {\n        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n      } else {\n        if (this.isXML) {\n          var xmlCharKey = updatedOptions.xml.xmlCharKey;\n          /**\n           * If the mapper specifies this as a non-composite type value but the responseBody contains\n           * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n           * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n           */\n          if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n            responseBody = responseBody[xmlCharKey];\n          }\n        }\n        if (mapperType.match(/^Number$/i) !== null) {\n          payload = parseFloat(responseBody);\n          if (isNaN(payload)) {\n            payload = responseBody;\n          }\n        } else if (mapperType.match(/^Boolean$/i) !== null) {\n          if (responseBody === \"true\") {\n            payload = true;\n          } else if (responseBody === \"false\") {\n            payload = false;\n          } else {\n            payload = responseBody;\n          }\n        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n          payload = responseBody;\n        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n          payload = new Date(responseBody);\n        } else if (mapperType.match(/^UnixTime$/i) !== null) {\n          payload = unixTimeToDate(responseBody);\n        } else if (mapperType.match(/^ByteArray$/i) !== null) {\n          payload = base64.decodeString(responseBody);\n        } else if (mapperType.match(/^Base64Url$/i) !== null) {\n          payload = base64UrlToByteArray(responseBody);\n        } else if (mapperType.match(/^Sequence$/i) !== null) {\n          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n        } else if (mapperType.match(/^Dictionary$/i) !== null) {\n          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n        }\n      }\n      if (mapper.isConstant) {\n        payload = mapper.defaultValue;\n      }\n      return payload;\n    }\n  }]);\n  return SerializerImpl;\n}();\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer() {\n  var modelMappers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var isXML = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return new SerializerImpl(modelMappers, isXML);\n}\nfunction trimEnd(str, ch) {\n  var len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(\"Please provide an input of type Uint8Array for converting to Base64Url.\");\n  }\n  // Uint8Array to Base64.\n  var str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n  var classes = [];\n  var partialclass = \"\";\n  if (prop) {\n    var subwords = prop.split(\".\");\n    var _iterator = _createForOfIteratorHelper(subwords),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        if (item.charAt(item.length - 1) === \"\\\\\") {\n          partialclass += item.substr(0, item.length - 1) + \".\";\n        } else {\n          partialclass += item;\n          classes.push(partialclass);\n          partialclass = \"\";\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return classes;\n}\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n  return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(\"\".concat(objectName, \" with value \").concat(value, \" must be of type number.\"));\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(\"\".concat(objectName, \" with value \\\"\").concat(value, \"\\\" must be of type string.\"));\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n        throw new Error(\"\".concat(objectName, \" with value \\\"\").concat(value, \"\\\" must be of type string and a valid uuid.\"));\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(\"\".concat(objectName, \" with value \").concat(value, \" must be of type boolean.\"));\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      var objectType = typeof value;\n      if (objectType !== \"string\" && typeof value.pipe !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) &&\n      // File objects count as a type of Blob, so we want to use instanceof explicitly\n      !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) && objectType !== \"function\") {\n        throw new Error(\"\".concat(objectName, \" must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream.\"));\n      }\n    }\n  }\n  return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(\"Please provide a set of allowedValues to validate \".concat(objectName, \" as an Enum Type.\"));\n  }\n  var isPresent = allowedValues.some(function (item) {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\"\".concat(value, \" is not a valid value for \").concat(objectName, \". The valid values are: \").concat(JSON.stringify(allowedValues), \".\"));\n  }\n  return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(\"\".concat(objectName, \" must be of type Uint8Array.\"));\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\nfunction serializeBase64UrlType(objectName, value) {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(\"\".concat(objectName, \" must be of type Uint8Array.\"));\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value !== undefined && value !== null) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in ISO8601 format.\"));\n      }\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in ISO8601 format.\"));\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in RFC-1123 format.\"));\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(\"\".concat(objectName, \" must be an instanceof Date or a string in RFC-1123/ISO8601 format \") + \"for it to be serialized in UnixTime/Epoch format.\");\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!isDuration(value)) {\n        throw new Error(\"\".concat(objectName, \" must be a string in ISO 8601 format. Instead was \\\"\").concat(value, \"\\\".\"));\n      }\n    }\n  }\n  return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n  var _a;\n  if (!Array.isArray(object)) {\n    throw new Error(\"\".concat(objectName, \" must be of type Array.\"));\n  }\n  var elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName, \".\"));\n  }\n  // Quirk: Composite mappers referenced by `element` might\n  // not have *all* properties declared (like uberParent),\n  // so let's try to look up the full definition by name.\n  if (elementType.type.name === \"Composite\" && elementType.type.className) {\n    elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;\n  }\n  var tempArray = [];\n  for (var i = 0; i < object.length; i++) {\n    var serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n    if (isXml && elementType.xmlNamespace) {\n      var xmlnsKey = elementType.xmlNamespacePrefix ? \"xmlns:\".concat(elementType.xmlNamespacePrefix) : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = Object.assign({}, serializedValue);\n        tempArray[i][XML_ATTRKEY] = _defineProperty({}, xmlnsKey, elementType.xmlNamespace);\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xml.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = _defineProperty({}, xmlnsKey, elementType.xmlNamespace);\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n  if (typeof object !== \"object\") {\n    throw new Error(\"\".concat(objectName, \" must be of type object.\"));\n  }\n  var valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName, \".\"));\n  }\n  var tempDictionary = {};\n  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    var xmlnsKey = mapper.xmlNamespacePrefix ? \"xmlns:\".concat(mapper.xmlNamespacePrefix) : \"xmlns\";\n    var result = tempDictionary;\n    result[XML_ATTRKEY] = _defineProperty({}, xmlnsKey, mapper.xmlNamespace);\n    return result;\n  }\n  return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n  var additionalProperties = mapper.type.additionalProperties;\n  if (!additionalProperties && mapper.type.className) {\n    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n  }\n  return additionalProperties;\n}\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n  var className = mapper.type.className;\n  if (!className) {\n    throw new Error(\"Class name for model \\\"\".concat(objectName, \"\\\" is not provided in the mapper \\\"\").concat(JSON.stringify(mapper, undefined, 2), \"\\\".\"));\n  }\n  return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  var modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(\"mapper() cannot be null or undefined for model \\\"\".concat(mapper.type.className, \"\\\".\"));\n    }\n    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\"modelProperties cannot be null or undefined in the \" + \"mapper \\\"\".concat(JSON.stringify(modelMapper), \"\\\" of type \\\"\").concat(mapper.type.className, \"\\\" for object \\\"\").concat(objectName, \"\\\".\"));\n    }\n  }\n  return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n  if (object !== undefined && object !== null) {\n    var payload = {};\n    var modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (var _i2 = 0, _Object$keys2 = Object.keys(modelProps); _i2 < _Object$keys2.length; _i2++) {\n      var key = _Object$keys2[_i2];\n      var propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n      var propName = void 0;\n      var parentObject = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        var paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n        var _iterator2 = _createForOfIteratorHelper(paths),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var pathName = _step2.value;\n            var childObject = parentObject[pathName];\n            if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {\n              parentObject[pathName] = {};\n            }\n            parentObject = parentObject[pathName];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      if (parentObject !== undefined && parentObject !== null) {\n        if (isXml && mapper.xmlNamespace) {\n          var xmlnsKey = mapper.xmlNamespacePrefix ? \"xmlns:\".concat(mapper.xmlNamespacePrefix) : \"xmlns\";\n          parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), _defineProperty({}, xmlnsKey, mapper.xmlNamespace));\n        }\n        var propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        var toSerialize = object[key];\n        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {\n          toSerialize = mapper.serializedName;\n        }\n        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n        if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n          var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = _defineProperty({}, propertyMapper.xmlElementName, value);\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n    var additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      var propNames = Object.keys(modelProps);\n      var _loop = function _loop(clientPropName) {\n        var isAdditionalProperty = propNames.every(function (pn) {\n          return pn !== clientPropName;\n        });\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n        }\n      };\n      for (var clientPropName in object) {\n        _loop(clientPropName);\n      }\n    }\n    return payload;\n  }\n  return object;\n}\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n  var xmlnsKey = propertyMapper.xmlNamespacePrefix ? \"xmlns:\".concat(propertyMapper.xmlNamespacePrefix) : \"xmlns\";\n  var xmlNamespace = _defineProperty({}, xmlnsKey, propertyMapper.xmlNamespace);\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      var _result = Object.assign({}, serializedValue);\n      _result[XML_ATTRKEY] = xmlNamespace;\n      return _result;\n    }\n  }\n  var result = {};\n  result[options.xml.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\nfunction isSpecialXmlProperty(propertyName, options) {\n  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n  var _a, _b;\n  var xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n  var modelProps = resolveModelProperties(serializer, mapper, objectName);\n  var instance = {};\n  var handledPropertyNames = [];\n  for (var _i3 = 0, _Object$keys3 = Object.keys(modelProps); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var propertyMapper = modelProps[key];\n    var paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    var serializedName = propertyMapper.serializedName,\n      xmlName = propertyMapper.xmlName,\n      xmlElementName = propertyMapper.xmlElementName;\n    var propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      var dictionary = {};\n      for (var _i4 = 0, _Object$keys4 = Object.keys(responseBody); _i4 < _Object$keys4.length; _i4++) {\n        var headerKey = _Object$keys4[_i4];\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n        }\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        var propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          var wrapped = responseBody[xmlName];\n          var elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];\n          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n          handledPropertyNames.push(xmlName);\n        } else {\n          var property = responseBody[propertyName];\n          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n          handledPropertyNames.push(propertyName);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      var propertyInstance = void 0;\n      var res = responseBody;\n      // traversing the object step by step.\n      var steps = 0;\n      var _iterator3 = _createForOfIteratorHelper(paths),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          if (!res) break;\n          steps++;\n          res = res[item];\n        }\n        // only accept null when reaching the last position of object otherwise it would be undefined\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (res === null && steps < paths.length) {\n        res = undefined;\n      }\n      propertyInstance = res;\n      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {\n        propertyInstance = mapper.serializedName;\n      }\n      var serializedValue = void 0;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        var arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (var _i5 = 0, _Object$entries = Object.entries(instance); _i5 < _Object$entries.length; _i5++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),\n            k = _Object$entries$_i[0],\n            v = _Object$entries$_i[1];\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n  var additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    var isAdditionalProperty = function isAdditionalProperty(responsePropName) {\n      for (var clientPropName in modelProps) {\n        var _paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (_paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n    for (var responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n      }\n    }\n  } else if (responseBody && !options.ignoreUnknownProperties) {\n    for (var _i6 = 0, _Object$keys5 = Object.keys(responseBody); _i6 < _Object$keys5.length; _i6++) {\n      var _key = _Object$keys5[_i6];\n      if (instance[_key] === undefined && !handledPropertyNames.includes(_key) && !isSpecialXmlProperty(_key, options)) {\n        instance[_key] = responseBody[_key];\n      }\n    }\n  }\n  return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n  /* jshint validthis: true */\n  var value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName));\n  }\n  if (responseBody) {\n    var tempDictionary = {};\n    for (var _i7 = 0, _Object$keys6 = Object.keys(responseBody); _i7 < _Object$keys6.length; _i7++) {\n      var key = _Object$keys6[_i7];\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n  var _a;\n  var element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + \"mapper and it must of type \\\"object\\\" in \".concat(objectName));\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (element.type.name === \"Composite\" && element.type.className) {\n      element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;\n    }\n    var tempArray = [];\n    for (var i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], \"\".concat(objectName, \"[\").concat(i, \"]\"), options);\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\nfunction getIndexDiscriminator(discriminators, discriminatorValue, typeName) {\n  var typeNamesToCheck = [typeName];\n  while (typeNamesToCheck.length) {\n    var currentName = typeNamesToCheck.shift();\n    var indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + \".\" + discriminatorValue;\n    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n      return discriminators[indexDiscriminator];\n    } else {\n      for (var _i8 = 0, _Object$entries2 = Object.entries(discriminators); _i8 < _Object$entries2.length; _i8++) {\n        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i8], 2),\n          name = _Object$entries2$_i[0],\n          mapper = _Object$entries2$_i[1];\n        if (name.startsWith(currentName + \".\") && mapper.type.uberParent === currentName && mapper.type.className) {\n          typeNamesToCheck.push(mapper.type.className);\n        }\n      }\n    }\n  }\n  return undefined;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  var _a;\n  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName) {\n      // The serializedName might have \\\\, which we just want to ignore\n      if (polymorphicPropertyName === \"serializedName\") {\n        discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n      }\n      var discriminatorValue = object[discriminatorName];\n      var typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;\n      if (typeof discriminatorValue === \"string\" && typeName) {\n        var polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n}\n/**\n * Known types of Mappers\n */\nexport var MapperTypeNames = {\n  Base64Url: \"Base64Url\",\n  Boolean: \"Boolean\",\n  ByteArray: \"ByteArray\",\n  Composite: \"Composite\",\n  Date: \"Date\",\n  DateTime: \"DateTime\",\n  DateTimeRfc1123: \"DateTimeRfc1123\",\n  Dictionary: \"Dictionary\",\n  Enum: \"Enum\",\n  Number: \"Number\",\n  Object: \"Object\",\n  Sequence: \"Sequence\",\n  String: \"String\",\n  Stream: \"Stream\",\n  TimeSpan: \"TimeSpan\",\n  UnixTime: \"UnixTime\"\n};","map":{"version":3,"names":["base64","XML_ATTRKEY","XML_CHARKEY","isDuration","isValidUuid","SerializerImpl","modelMappers","arguments","length","undefined","isXML","_classCallCheck","_createClass","key","value","validateConstraints","mapper","objectName","failValidation","constraintName","constraintValue","Error","concat","constraints","_mapper$constraints","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","pattern","RegExp","match","some","item","i","ar","indexOf","serialize","object","options","xml","updatedOptions","rootName","_a","includeRoot","_b","xmlCharKey","_c","payload","mapperType","type","name","serializedName","isConstant","defaultValue","required","nullable","serializeBasicTypes","enumMapper","serializeEnumType","allowedValues","serializeDateTypes","serializeByteArrayType","serializeBase64UrlType","serializeSequenceType","Boolean","serializeDictionaryType","serializeCompositeType","deserialize","responseBody","ignoreUnknownProperties","_d","xmlIsWrapped","deserializeCompositeType","parseFloat","isNaN","Date","unixTimeToDate","decodeString","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","createSerializer","trimEnd","str","ch","len","substr","bufferToBase64Url","buffer","Uint8Array","encodeByteArray","replace","valueOf","splitSerializeName","prop","classes","partialclass","subwords","split","_iterator","_createForOfIteratorHelper","_step","s","n","done","charAt","push","err","e","f","dateToUnixTime","d","Math","floor","getTime","typeName","objectType","pipe","ArrayBuffer","isView","Blob","isPresent","toLowerCase","JSON","stringify","parse","toISOString","substring","toUTCString","serializer","isXml","Array","isArray","elementType","element","className","tempArray","serializedValue","xmlNamespace","xmlnsKey","xmlNamespacePrefix","Object","assign","_defineProperty","valueType","tempDictionary","_i","_Object$keys","keys","getXmlObjectValue","result","resolveAdditionalProperties","additionalProperties","modelMapper","resolveReferencedMapper","resolveModelProperties","modelProps","modelProperties","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","_i2","_Object$keys2","propertyMapper","readOnly","propName","parentObject","xmlName","xmlElementName","paths","pop","_iterator2","_step2","pathName","childObject","propertyObjectName","toSerialize","polymorphicDiscriminator","clientName","xmlIsAttribute","additionalPropertiesMapper","propNames","_loop","clientPropName","isAdditionalProperty","every","pn","includes","isSpecialXmlProperty","propertyName","instance","handledPropertyNames","_i3","_Object$keys3","headerCollectionPrefix","dictionary","_i4","_Object$keys4","headerKey","startsWith","xmlIsMsText","wrapped","elementList","property","propertyInstance","res","steps","_iterator3","_step3","arrayInstance","_i5","_Object$entries","entries","_Object$entries$_i","_slicedToArray","k","v","prototype","hasOwnProperty","call","responsePropName","_i6","_Object$keys5","_i7","_Object$keys6","getIndexDiscriminator","discriminators","discriminatorValue","typeNamesToCheck","currentName","shift","indexDiscriminator","_i8","_Object$entries2","_Object$entries2$_i","uberParent","polymorphicPropertyName","discriminatorName","polymorphicMapper","getPolymorphicDiscriminatorSafely","MapperTypeNames","Base64Url","ByteArray","Composite","DateTime","DateTimeRfc1123","Dictionary","Enum","Number","Sequence","String","Stream","TimeSpan","UnixTime"],"sources":["../../src/serializer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as base64 from \"./base64\";\nimport {\n  BaseMapper,\n  CompositeMapper,\n  DictionaryMapper,\n  EnumMapper,\n  Mapper,\n  MapperConstraints,\n  PolymorphicDiscriminator,\n  RequiredSerializerOptions,\n  SequenceMapper,\n  Serializer,\n  SerializerOptions,\n  XML_ATTRKEY,\n  XML_CHARKEY,\n} from \"./interfaces\";\nimport { isDuration, isValidUuid } from \"./utils\";\n\nclass SerializerImpl implements Serializer {\n  constructor(\n    public readonly modelMappers: { [key: string]: any } = {},\n    public readonly isXML: boolean = false\n  ) {}\n\n  /**\n   * @deprecated Removing the constraints validation on client side.\n   */\n  validateConstraints(mapper: Mapper, value: any, objectName: string): void {\n    const failValidation = (\n      constraintName: keyof MapperConstraints,\n      constraintValue: any\n    ): never => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`\n      );\n    };\n    if (mapper.constraints && value !== undefined && value !== null) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems,\n      } = mapper.constraints;\n      if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems !== undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength !== undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems !== undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength !== undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        value.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param object - A valid Javascript object to be serialized\n   *\n   * @param objectName - Name of the serialized object\n   *\n   * @param options - additional options to serialization\n   *\n   * @returns A valid serialized Javascript object\n   */\n  serialize(\n    mapper: Mapper,\n    object: any,\n    objectName?: string,\n    options: SerializerOptions = { xml: {} }\n  ): any {\n    const updatedOptions: RequiredSerializerOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY,\n      },\n    };\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && (object === undefined || object === null)) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object === undefined || object === null) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(\n          this,\n          mapper as CompositeMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param responseBody - A valid Javascript entity to be deserialized\n   *\n   * @param objectName - Name of the deserialized object\n   *\n   * @param options - Controls behavior of XML parser and builder.\n   *\n   * @returns A valid deserialized Javascript object\n   */\n  deserialize(\n    mapper: Mapper,\n    responseBody: any,\n    objectName: string,\n    options: SerializerOptions = { xml: {} }\n  ): any {\n    const updatedOptions: RequiredSerializerOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY,\n      },\n      ignoreUnknownProperties: options.ignoreUnknownProperties ?? false,\n    };\n    if (responseBody === undefined || responseBody === null) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(\n        this,\n        mapper as CompositeMapper,\n        responseBody,\n        objectName,\n        updatedOptions\n      );\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xml.xmlCharKey;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n          responseBody = responseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer(\n  modelMappers: { [key: string]: any } = {},\n  isXML: boolean = false\n): Serializer {\n  return new SerializerImpl(modelMappers, isXML);\n}\n\nfunction trimEnd(str: string, ch: string): string {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: Uint8Array): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`\n        );\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        typeof value.pipe !== \"function\" &&\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        // File objects count as a type of Blob, so we want to use instanceof explicitly\n        !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) &&\n        objectType !== \"function\"\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream.`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues\n      )}.`\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: any): any {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: any): any {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string): any {\n  if (value !== undefined && value !== null) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions\n): any {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  let elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  // Quirk: Composite mappers referenced by `element` might\n  // not have *all* properties declared (like uberParent),\n  // so let's try to look up the full definition by name.\n  if (elementType.type.name === \"Composite\" && elementType.type.className) {\n    elementType = serializer.modelMappers[elementType.type.className] ?? elementType;\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix\n        ? `xmlns:${elementType.xmlNamespacePrefix}`\n        : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = { ...serializedValue };\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xml.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions\n): any {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n    return result;\n  }\n\n  return tempDictionary;\n}\n\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): SequenceMapper | BaseMapper | CompositeMapper | DictionaryMapper | EnumMapper | undefined {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper?.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): CompositeMapper | undefined {\n  const className = mapper.type.className;\n  if (!className) {\n    throw new Error(\n      `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n        mapper,\n        undefined,\n        2\n      )}\".`\n    );\n  }\n\n  return serializer.modelMappers[className];\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n    modelProps = modelMapper?.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(modelMapper)}\" of type \"${\n            mapper.type.className\n          }\" for object \"${objectName}\".`\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object !== undefined && object !== null) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (\n            (childObject === undefined || childObject === null) &&\n            ((object[key] !== undefined && object[key] !== null) ||\n              propertyMapper.defaultValue !== undefined)\n          ) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject !== undefined && parentObject !== null) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix\n            ? `xmlns:${mapper.xmlNamespacePrefix}`\n            : \"xmlns\";\n          parentObject[XML_ATTRKEY] = {\n            ...parentObject[XML_ATTRKEY],\n            [xmlnsKey]: mapper.xmlNamespace,\n          };\n        }\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          (toSerialize === undefined || toSerialize === null)\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName,\n          options\n        );\n        if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: value };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]',\n            options\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction getXmlObjectValue(\n  propertyMapper: Mapper,\n  serializedValue: any,\n  isXml: boolean,\n  options: RequiredSerializerOptions\n): any {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix\n    ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n    : \"xmlns\";\n  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result: any = { ...serializedValue };\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n  const result: any = {};\n  result[options.xml.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName: string, options: RequiredSerializerOptions): boolean {\n  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions\n): any {\n  const xmlCharKey = options.xml.xmlCharKey ?? XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName,\n            options\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody[XML_ATTRKEY][xmlName!],\n          propertyObjectName,\n          options\n        );\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName!];\n          const elementList = wrapped?.[xmlElementName!] ?? [];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            elementList,\n            propertyObjectName,\n            options\n          );\n          handledPropertyNames.push(xmlName!);\n        } else {\n          const property = responseBody[propertyName!];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            property,\n            propertyObjectName,\n            options\n          );\n          handledPropertyNames.push(propertyName!);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      let steps = 0;\n      for (const item of paths) {\n        if (!res) break;\n        steps++;\n        res = res[item];\n      }\n      // only accept null when reaching the last position of object otherwise it would be undefined\n      if (res === null && steps < paths.length) {\n        res = undefined;\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        (propertyInstance === undefined || propertyInstance === null)\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string): boolean => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]',\n          options\n        );\n      }\n    }\n  } else if (responseBody && !options.ignoreUnknownProperties) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key, options)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions\n): any {\n  /* jshint validthis: true */\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions\n): any {\n  let element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (element.type.name === \"Composite\" && element.type.className) {\n      element = serializer.modelMappers[element.type.className] ?? element;\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(\n        element,\n        responseBody[i],\n        `${objectName}[${i}]`,\n        options\n      );\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getIndexDiscriminator(\n  discriminators: Record<string, CompositeMapper>,\n  discriminatorValue: string,\n  typeName: string\n): CompositeMapper | undefined {\n  const typeNamesToCheck = [typeName];\n  while (typeNamesToCheck.length) {\n    const currentName = typeNamesToCheck.shift();\n    const indexDiscriminator =\n      discriminatorValue === currentName\n        ? discriminatorValue\n        : currentName + \".\" + discriminatorValue;\n    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n      return discriminators[indexDiscriminator];\n    } else {\n      for (const [name, mapper] of Object.entries(discriminators)) {\n        if (\n          name.startsWith(currentName + \".\") &&\n          mapper.type.uberParent === currentName &&\n          mapper.type.className\n        ) {\n          typeNamesToCheck.push(mapper.type.className);\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\"\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n  if (polymorphicDiscriminator) {\n    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName) {\n      // The serializedName might have \\\\, which we just want to ignore\n      if (polymorphicPropertyName === \"serializedName\") {\n        discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n      }\n      const discriminatorValue = object[discriminatorName];\n      const typeName = mapper.type.uberParent ?? mapper.type.className;\n\n      if (typeof discriminatorValue === \"string\" && typeName) {\n        const polymorphicMapper = getIndexDiscriminator(\n          serializer.modelMappers.discriminators,\n          discriminatorValue,\n          typeName\n        );\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(\n  serializer: Serializer,\n  typeName?: string\n): PolymorphicDiscriminator | undefined {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\n/**\n * Known types of Mappers\n */\nexport const MapperTypeNames = {\n  Base64Url: \"Base64Url\",\n  Boolean: \"Boolean\",\n  ByteArray: \"ByteArray\",\n  Composite: \"Composite\",\n  Date: \"Date\",\n  DateTime: \"DateTime\",\n  DateTimeRfc1123: \"DateTimeRfc1123\",\n  Dictionary: \"Dictionary\",\n  Enum: \"Enum\",\n  Number: \"Number\",\n  Object: \"Object\",\n  Sequence: \"Sequence\",\n  String: \"String\",\n  Stream: \"Stream\",\n  TimeSpan: \"TimeSpan\",\n  UnixTime: \"UnixTime\",\n} as const;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}