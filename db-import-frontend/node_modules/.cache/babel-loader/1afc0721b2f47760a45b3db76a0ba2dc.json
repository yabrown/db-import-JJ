{"ast":null,"code":"'use strict';\n\nvar util = require('util');\nvar chownr = util.promisify(require('chownr'));\nvar mkdirp = require('mkdirp');\nvar inflight = require('promise-inflight');\nvar inferOwner = require('infer-owner');\n\n// Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\nvar self = {\n  uid: null,\n  gid: null\n};\nvar getSelf = function getSelf() {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid();\n    var setuid = process.setuid;\n    process.setuid = function (uid) {\n      self.uid = null;\n      process.setuid = setuid;\n      return process.setuid(uid);\n    };\n  }\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid();\n    var setgid = process.setgid;\n    process.setgid = function (gid) {\n      self.gid = null;\n      process.setgid = setgid;\n      return process.setgid(gid);\n    };\n  }\n};\nmodule.exports.chownr = fixOwner;\nfunction fixOwner(cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return Promise.resolve();\n  }\n  getSelf();\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return Promise.resolve();\n  }\n  return Promise.resolve(inferOwner(cache)).then(function (owner) {\n    var uid = owner.uid,\n      gid = owner.gid;\n\n    // No need to override if it's already what we used.\n    if (self.uid === uid && self.gid === gid) return;\n    return inflight('fixOwner: fixing ownership on ' + filepath, function () {\n      return chownr(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid).catch(function (err) {\n        if (err.code === 'ENOENT') return null;\n        throw err;\n      });\n    });\n  });\n}\nmodule.exports.chownr.sync = fixOwnerSync;\nfunction fixOwnerSync(cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return;\n  }\n  var _inferOwner$sync = inferOwner.sync(cache),\n    uid = _inferOwner$sync.uid,\n    gid = _inferOwner$sync.gid;\n  getSelf();\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return;\n  }\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return;\n  }\n  try {\n    chownr.sync(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid);\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') return null;\n    throw err;\n  }\n}\nmodule.exports.mkdirfix = mkdirfix;\nfunction mkdirfix(cache, p, cb) {\n  // we have to infer the owner _before_ making the directory, even though\n  // we aren't going to use the results, since the cache itself might not\n  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n  // to be correct if it creates the cache folder in the process.\n  return Promise.resolve(inferOwner(cache)).then(function () {\n    return mkdirp(p).then(function (made) {\n      if (made) return fixOwner(cache, made).then(function () {\n        return made;\n      });\n    }).catch(function (err) {\n      if (err.code === 'EEXIST') return fixOwner(cache, p).then(function () {\n        return null;\n      });\n      throw err;\n    });\n  });\n}\nmodule.exports.mkdirfix.sync = mkdirfixSync;\nfunction mkdirfixSync(cache, p) {\n  try {\n    inferOwner.sync(cache);\n    var made = mkdirp.sync(p);\n    if (made) {\n      fixOwnerSync(cache, made);\n      return made;\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p);\n      return null;\n    } else throw err;\n  }\n}","map":{"version":3,"names":["util","require","chownr","promisify","mkdirp","inflight","inferOwner","self","uid","gid","getSelf","process","getuid","setuid","getgid","setgid","module","exports","fixOwner","cache","filepath","Promise","resolve","then","owner","catch","err","code","sync","fixOwnerSync","_inferOwner$sync","mkdirfix","p","cb","made","mkdirfixSync"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/cacache/lib/util/fix-owner.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst chownr = util.promisify(require('chownr'))\nconst mkdirp = require('mkdirp')\nconst inflight = require('promise-inflight')\nconst inferOwner = require('infer-owner')\n\n// Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\nconst self = { uid: null, gid: null }\nconst getSelf = () => {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid()\n    const setuid = process.setuid\n    process.setuid = (uid) => {\n      self.uid = null\n      process.setuid = setuid\n      return process.setuid(uid)\n    }\n  }\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid()\n    const setgid = process.setgid\n    process.setgid = (gid) => {\n      self.gid = null\n      process.setgid = setgid\n      return process.setgid(gid)\n    }\n  }\n}\n\nmodule.exports.chownr = fixOwner\n\nfunction fixOwner (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return Promise.resolve()\n  }\n\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return Promise.resolve()\n  }\n\n  return Promise.resolve(inferOwner(cache)).then((owner) => {\n    const { uid, gid } = owner\n\n    // No need to override if it's already what we used.\n    if (self.uid === uid && self.gid === gid)\n      return\n\n    return inflight('fixOwner: fixing ownership on ' + filepath, () =>\n      chownr(\n        filepath,\n        typeof uid === 'number' ? uid : self.uid,\n        typeof gid === 'number' ? gid : self.gid\n      ).catch((err) => {\n        if (err.code === 'ENOENT')\n          return null\n\n        throw err\n      })\n    )\n  })\n}\n\nmodule.exports.chownr.sync = fixOwnerSync\n\nfunction fixOwnerSync (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return\n  }\n  const { uid, gid } = inferOwner.sync(cache)\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return\n  }\n\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return\n  }\n  try {\n    chownr.sync(\n      filepath,\n      typeof uid === 'number' ? uid : self.uid,\n      typeof gid === 'number' ? gid : self.gid\n    )\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT')\n      return null\n\n    throw err\n  }\n}\n\nmodule.exports.mkdirfix = mkdirfix\n\nfunction mkdirfix (cache, p, cb) {\n  // we have to infer the owner _before_ making the directory, even though\n  // we aren't going to use the results, since the cache itself might not\n  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n  // to be correct if it creates the cache folder in the process.\n  return Promise.resolve(inferOwner(cache)).then(() => {\n    return mkdirp(p)\n      .then((made) => {\n        if (made)\n          return fixOwner(cache, made).then(() => made)\n      })\n      .catch((err) => {\n        if (err.code === 'EEXIST')\n          return fixOwner(cache, p).then(() => null)\n\n        throw err\n      })\n  })\n}\n\nmodule.exports.mkdirfix.sync = mkdirfixSync\n\nfunction mkdirfixSync (cache, p) {\n  try {\n    inferOwner.sync(cache)\n    const made = mkdirp.sync(p)\n    if (made) {\n      fixOwnerSync(cache, made)\n      return made\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p)\n      return null\n    } else\n      throw err\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}