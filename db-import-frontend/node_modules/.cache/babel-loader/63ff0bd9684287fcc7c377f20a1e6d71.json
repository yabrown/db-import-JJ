{"ast":null,"code":"import _slicedToArray from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body) {\n  return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body) {\n  return Boolean(body && typeof body.getReader === \"function\" && typeof body.tee === \"function\");\n}\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nvar FetchHttpClient = /*#__PURE__*/function () {\n  function FetchHttpClient() {\n    _classCallCheck(this, FetchHttpClient);\n  }\n  _createClass(FetchHttpClient, [{\n    key: \"sendRequest\",\n    value:\n    /**\n     * Makes a request over an underlying transport layer and returns the response.\n     * @param request - The request to be made.\n     */\n    function () {\n      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {\n        var url, isInsecure;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              url = new URL(request.url);\n              isInsecure = url.protocol !== \"https:\";\n              if (!(isInsecure && !request.allowInsecureConnection)) {\n                _context.next = 4;\n                break;\n              }\n              throw new Error(\"Cannot connect to \".concat(request.url, \" while allowInsecureConnection is false.\"));\n            case 4:\n              if (!request.proxySettings) {\n                _context.next = 6;\n                break;\n              }\n              throw new Error(\"HTTP proxy is not supported in browser environment\");\n            case 6:\n              _context.prev = 6;\n              _context.next = 9;\n              return makeRequest(request);\n            case 9:\n              return _context.abrupt(\"return\", _context.sent);\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](6);\n              throw getError(_context.t0, request);\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[6, 12]]);\n      }));\n      function sendRequest(_x) {\n        return _sendRequest.apply(this, arguments);\n      }\n      return sendRequest;\n    }()\n  }]);\n  return FetchHttpClient;\n}();\n/**\n * Sends a request\n */\nfunction makeRequest(_x2) {\n  return _makeRequest.apply(this, arguments);\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nfunction _makeRequest() {\n  _makeRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {\n    var _setupAbortSignal, abortController, abortControllerCleanup, headers, requestBody, response;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _setupAbortSignal = setupAbortSignal(request), abortController = _setupAbortSignal.abortController, abortControllerCleanup = _setupAbortSignal.abortControllerCleanup;\n          _context3.prev = 1;\n          headers = buildFetchHeaders(request.headers);\n          requestBody = buildRequestBody(request);\n          /**\n           * Developers of the future:\n           * Do not set redirect: \"manual\" as part\n           * of request options.\n           * It will not work as you expect.\n           */\n          _context3.next = 6;\n          return fetch(request.url, {\n            body: requestBody,\n            method: request.method,\n            headers: headers,\n            signal: abortController.signal,\n            credentials: request.withCredentials ? \"include\" : \"same-origin\",\n            cache: \"no-store\"\n          });\n        case 6:\n          response = _context3.sent;\n          // If we're uploading a blob, we need to fire the progress event manually\n          if (isBlob(request.body) && request.onUploadProgress) {\n            request.onUploadProgress({\n              loadedBytes: request.body.size\n            });\n          }\n          return _context3.abrupt(\"return\", buildPipelineResponse(response, request));\n        case 9:\n          _context3.prev = 9;\n          if (abortControllerCleanup) {\n            abortControllerCleanup();\n          }\n          return _context3.finish(9);\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[1,, 9, 12]]);\n  }));\n  return _makeRequest.apply(this, arguments);\n}\nfunction buildPipelineResponse(_x3, _x4) {\n  return _buildPipelineResponse.apply(this, arguments);\n}\nfunction _buildPipelineResponse() {\n  _buildPipelineResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(httpResponse, request) {\n    var _a, _b, headers, response, bodyStream, responseStream, _responseStream;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          headers = buildPipelineHeaders(httpResponse);\n          response = {\n            request: request,\n            headers: headers,\n            status: httpResponse.status\n          };\n          bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;\n          if (!(\n          // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n          ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status)))) {\n            _context4.next = 7;\n            break;\n          }\n          if (request.enableBrowserStreams) {\n            response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n          } else {\n            responseStream = new Response(bodyStream);\n            response.blobBody = responseStream.blob();\n          }\n          _context4.next = 11;\n          break;\n        case 7:\n          _responseStream = new Response(bodyStream);\n          _context4.next = 10;\n          return _responseStream.text();\n        case 10:\n          response.bodyAsText = _context4.sent;\n        case 11:\n          return _context4.abrupt(\"return\", response);\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _buildPipelineResponse.apply(this, arguments);\n}\nfunction setupAbortSignal(request) {\n  var abortController = new AbortController();\n  // Cleanup function\n  var abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n  var abortListener;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n    abortListener = function abortListener(event) {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = function abortControllerCleanup() {\n      var _a;\n      if (abortListener) {\n        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(function () {\n      abortController.abort();\n    }, request.timeout);\n  }\n  return {\n    abortController: abortController,\n    abortControllerCleanup: abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\nfunction getError(e, request) {\n  var _a;\n  if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(\"Error sending request: \".concat(e.message), {\n      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n      request: request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n  var headers = new Headers();\n  var _iterator = _createForOfIteratorHelper(pipelineHeaders),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        name = _step$value[0],\n        value = _step$value[1];\n      headers.append(name, value);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n  var responseHeaders = createHttpHeaders();\n  var _iterator2 = _createForOfIteratorHelper(httpResponse.headers),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        name = _step2$value[0],\n        value = _step2$value[1];\n      responseHeaders.set(name, value);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return responseHeaders;\n}\nfunction buildRequestBody(request) {\n  var body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, onProgress) {\n  var loadedBytes = 0;\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform: function transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n        if (onProgress) {\n          onProgress({\n            loadedBytes: loadedBytes\n          });\n        }\n      }\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    var reader = readableStream.getReader();\n    return new ReadableStream({\n      pull: function pull(controller) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _a, _yield$reader$read, done, value;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return reader.read();\n              case 2:\n                _yield$reader$read = _context2.sent;\n                done = _yield$reader$read.done;\n                value = _yield$reader$read.value;\n                if (!(done || !value)) {\n                  _context2.next = 9;\n                  break;\n                }\n                // Close the stream\n                controller.close();\n                reader.releaseLock();\n                return _context2.abrupt(\"return\");\n              case 9:\n                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n                // Enqueue the next data chunk into our target stream\n                controller.enqueue(value);\n                if (onProgress) {\n                  onProgress({\n                    loadedBytes: loadedBytes\n                  });\n                }\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }))();\n      }\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","body","pipe","isReadableStream","Boolean","getReader","tee","isBlob","Blob","FetchHttpClient","_classCallCheck","_createClass","key","value","_sendRequest","_asyncToGenerator","_regeneratorRuntime","mark","_callee","request","url","isInsecure","wrap","_callee$","_context","prev","next","URL","protocol","allowInsecureConnection","Error","concat","proxySettings","makeRequest","abrupt","sent","t0","getError","stop","sendRequest","_x","apply","arguments","_x2","_makeRequest","_callee3","_setupAbortSignal","abortController","abortControllerCleanup","headers","requestBody","response","_callee3$","_context3","setupAbortSignal","buildFetchHeaders","buildRequestBody","fetch","method","signal","credentials","withCredentials","cache","onUploadProgress","loadedBytes","size","buildPipelineResponse","finish","_x3","_x4","_buildPipelineResponse","_callee4","httpResponse","_a","_b","bodyStream","responseStream","_responseStream","_callee4$","_context4","buildPipelineHeaders","status","buildBodyStream","onDownloadProgress","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","enableBrowserStreams","browserStreamBody","undefined","Response","blobBody","blob","text","bodyAsText","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","e","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","append","err","f","responseHeaders","_iterator2","_step2","_step2$value","set","readableStream","onProgress","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","reader","ReadableStream","pull","_callee2","_yield$reader$read","_callee2$","_context2","read","close","releaseLock","createFetchHttpClient","self"],"sources":["../../src/fetchHttpClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport {\n  HttpClient,\n  HttpHeaders as PipelineHeaders,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n} from \"./interfaces\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body: any): body is NodeJS.ReadableStream {\n  return body && typeof body.pipe === \"function\";\n}\n\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body: unknown): body is ReadableStream {\n  return Boolean(\n    body &&\n      typeof (body as ReadableStream).getReader === \"function\" &&\n      typeof (body as ReadableStream).tee === \"function\"\n  );\n}\n\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body: unknown): body is Blob {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient implements HttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    try {\n      return await makeRequest(request);\n    } catch (e: any) {\n      throw getError(e, request);\n    }\n  }\n}\n\n/**\n * Sends a request\n */\nasync function makeRequest(request: PipelineRequest): Promise<PipelineResponse> {\n  const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const requestBody = buildRequestBody(request);\n\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      credentials: request.withCredentials ? \"include\" : \"same-origin\",\n      cache: \"no-store\",\n    });\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({ loadedBytes: request.body.size });\n    }\n    return buildPipelineResponse(response, request);\n  } finally {\n    if (abortControllerCleanup) {\n      abortControllerCleanup();\n    }\n  }\n}\n\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse: Response, request: PipelineRequest) {\n  const headers = buildPipelineHeaders(httpResponse);\n  const response: PipelineResponse = {\n    request,\n    headers,\n    status: httpResponse.status,\n  };\n\n  const bodyStream = isReadableStream(httpResponse.body)\n    ? buildBodyStream(httpResponse.body, request.onDownloadProgress)\n    : httpResponse.body;\n\n  if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||\n    request.streamResponseStatusCodes?.has(response.status)\n  ) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream ?? undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n\n    response.bodyAsText = await responseStream.text();\n  }\n\n  return response;\n}\n\nfunction setupAbortSignal(request: PipelineRequest): {\n  abortController: AbortController;\n  abortControllerCleanup: (() => void) | undefined;\n} {\n  const abortController = new AbortController();\n\n  // Cleanup function\n  let abortControllerCleanup: (() => void) | undefined;\n\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener: ((event: any) => void) | undefined;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n\n    abortListener = (event: Event) => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      if (abortListener) {\n        request.abortSignal?.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return { abortController, abortControllerCleanup };\n}\n\n/**\n * Gets the specific error\n */\nfunction getError(e: RestError, request: PipelineRequest): RestError {\n  if (e && e?.name === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: e?.code ?? RestError.REQUEST_SEND_ERROR,\n      request,\n    });\n  }\n}\n\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders: PipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse: Response): PipelineHeaders {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\nfunction buildRequestBody(request: PipelineRequest) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(\n  readableStream: ReadableStream<Uint8Array>,\n  onProgress?: (progress: TransferProgressEvent) => void\n): ReadableStream<Uint8Array> {\n  let loadedBytes = 0;\n\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === null) {\n            controller.terminate();\n            return;\n          }\n\n          controller.enqueue(chunk);\n          loadedBytes += chunk.length;\n          if (onProgress) {\n            onProgress({ loadedBytes });\n          }\n        },\n      })\n    );\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        const { done, value } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n\n        loadedBytes += value?.length ?? 0;\n\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n\n        if (onProgress) {\n          onProgress({ loadedBytes });\n        }\n      },\n    });\n  }\n}\n\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient(): HttpClient {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream: ReadableStream): boolean {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}