{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { RegionDiscoverySources, ResponseCodes, Constants } from '../utils/Constants.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar RegionDiscovery = /** @class */function () {\n  function RegionDiscovery(networkInterface) {\n    this.networkInterface = networkInterface;\n  }\n  /**\r\n   * Detect the region from the application's environment.\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  RegionDiscovery.prototype.detectRegion = function (environmentRegion, regionDiscoveryMetadata, proxyUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            autodetectedRegionName = environmentRegion;\n            if (!!autodetectedRegionName) return [3 /*break*/, 8];\n            options = RegionDiscovery.IMDS_OPTIONS;\n            if (proxyUrl) {\n              options.proxyUrl = proxyUrl;\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 6,, 7]);\n            return [4 /*yield*/, this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];\n          case 2:\n            localIMDSVersionResponse = _a.sent();\n            if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = localIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n            if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest)) return [3 /*break*/, 5];\n            return [4 /*yield*/, this.getCurrentVersion(options)];\n          case 3:\n            currentIMDSVersion = _a.sent();\n            if (!currentIMDSVersion) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n              return [2 /*return*/, null];\n            }\n            return [4 /*yield*/, this.getRegionFromIMDS(currentIMDSVersion, options)];\n          case 4:\n            currentIMDSVersionResponse = _a.sent();\n            if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = currentIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n            _a.label = 5;\n          case 5:\n            return [3 /*break*/, 7];\n          case 6:\n            _a.sent();\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return [2 /*return*/, null];\n          case 7:\n            return [3 /*break*/, 9];\n          case 8:\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n            _a.label = 9;\n          case 9:\n            // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n            if (!autodetectedRegionName) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            }\n            return [2 /*return*/, autodetectedRegionName || null];\n        }\n      });\n    });\n  };\n  /**\r\n   * Make the call to the IMDS endpoint\r\n   *\r\n   * @param imdsEndpointUrl\r\n   * @returns Promise<NetworkResponse<string>>\r\n   */\n  RegionDiscovery.prototype.getRegionFromIMDS = function (version, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + \"?api-version=\" + version + \"&format=text\", options, Constants.IMDS_TIMEOUT)];\n      });\n    });\n  };\n  /**\r\n   * Get the most recent version of the IMDS endpoint available\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  RegionDiscovery.prototype.getCurrentVersion = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n            return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + \"?format=json\", options)];\n          case 1:\n            response = _a.sent();\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n              return [2 /*return*/, response.body[\"newest-versions\"][0]];\n            }\n            return [2 /*return*/, null];\n          case 2:\n            _a.sent();\n            return [2 /*return*/, null];\n          case 3:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  // Options for the IMDS endpoint request\n  RegionDiscovery.IMDS_OPTIONS = {\n    headers: {\n      Metadata: \"true\"\n    }\n  };\n  return RegionDiscovery;\n}();\nexport { RegionDiscovery };","map":{"version":3,"names":["RegionDiscovery","networkInterface","prototype","detectRegion","environmentRegion","regionDiscoveryMetadata","proxyUrl","autodetectedRegionName","options","IMDS_OPTIONS","getRegionFromIMDS","Constants","IMDS_VERSION","localIMDSVersionResponse","_a","sent","status","ResponseCodes","httpSuccess","body","region_source","RegionDiscoverySources","IMDS","httpBadRequest","getCurrentVersion","currentIMDSVersion","FAILED_AUTO_DETECTION","currentIMDSVersionResponse","ENVIRONMENT_VARIABLE","version","sendGetRequestAsync","IMDS_ENDPOINT","IMDS_TIMEOUT","response","length","headers","Metadata"],"sources":["../../src/authority/RegionDiscovery.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule } from \"../network/INetworkModule\";\nimport { NetworkResponse } from \"../network/NetworkManager\";\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse\";\nimport { Constants, RegionDiscoverySources, ResponseCodes } from \"../utils/Constants\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\nimport { ImdsOptions } from \"./ImdsOptions\";\n\nexport class RegionDiscovery {\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Options for the IMDS endpoint request\n    protected static IMDS_OPTIONS: ImdsOptions = {\n        headers: {\n            Metadata: \"true\",\n        },\n    };\n\n    constructor(networkInterface: INetworkModule) {\n        this.networkInterface = networkInterface;\n    }\n\n    /**\n     * Detect the region from the application's environment.\n     * \n     * @returns Promise<string | null>\n     */\n    public async detectRegion(environmentRegion: string | undefined, regionDiscoveryMetadata: RegionDiscoveryMetadata, proxyUrl: string): Promise<string | null> {\n        // Initialize auto detected region with the region from the envrionment \n        let autodetectedRegionName = environmentRegion;\n\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS \n        if (!autodetectedRegionName) {\n            const options = RegionDiscovery.IMDS_OPTIONS;\n            if (proxyUrl) {\n                options.proxyUrl = proxyUrl;\n            }\n\n            try {\n                const localIMDSVersionResponse = await this.getRegionFromIMDS(Constants.IMDS_VERSION, options);\n                if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n                    autodetectedRegionName = localIMDSVersionResponse.body;\n                    regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n                } \n                \n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry. \n                if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\n                    const currentIMDSVersion = await this.getCurrentVersion(options);\n                    if (!currentIMDSVersion) {\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                        return null;\n                    }\n\n                    const currentIMDSVersionResponse = await this.getRegionFromIMDS(currentIMDSVersion, options);\n                    if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n                        autodetectedRegionName = currentIMDSVersionResponse.body;\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n                    }\n                }\n            } catch(e) {\n                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                return null;\n            } \n        } else {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n        }\n\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n        if (!autodetectedRegionName) {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        }\n\n        return autodetectedRegionName || null;\n    }\n\n    /**\n     * Make the call to the IMDS endpoint\n     * \n     * @param imdsEndpointUrl\n     * @returns Promise<NetworkResponse<string>>\n     */\n    private async getRegionFromIMDS(version: string, options: ImdsOptions): Promise<NetworkResponse<string>> {\n        return this.networkInterface.sendGetRequestAsync<string>(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n    }\n\n    /**\n     * Get the most recent version of the IMDS endpoint available\n     *  \n     * @returns Promise<string | null>\n     */\n    private async getCurrentVersion(options: ImdsOptions): Promise<string | null> {\n        try {\n            const response = await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n                return response.body[\"newest-versions\"][0];\n            }\n\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}