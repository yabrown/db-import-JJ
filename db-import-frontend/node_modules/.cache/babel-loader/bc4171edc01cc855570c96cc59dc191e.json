{"ast":null,"code":"'use strict';\n\n// rfc7231 6.1\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar statusCodeCacheableByDefault = new Set([200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501]);\n\n// This implementation does not understand partial responses (206)\nvar understoodStatuses = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]);\nvar errorStatusCodes = new Set([500, 502, 503, 504]);\nvar hopByHopHeaders = {\n  date: true,\n  // included, because we add Age update Date\n  connection: true,\n  'keep-alive': true,\n  'proxy-authenticate': true,\n  'proxy-authorization': true,\n  te: true,\n  trailer: true,\n  'transfer-encoding': true,\n  upgrade: true\n};\nvar excludedFromRevalidationUpdate = {\n  // Since the old body is reused, it doesn't make sense to change properties of the body\n  'content-length': true,\n  'content-encoding': true,\n  'transfer-encoding': true,\n  'content-range': true\n};\nfunction toNumberOrZero(s) {\n  var n = parseInt(s, 10);\n  return isFinite(n) ? n : 0;\n}\n\n// RFC 5861\nfunction isErrorResponse(response) {\n  // consider undefined response as faulty\n  if (!response) {\n    return true;\n  }\n  return errorStatusCodes.has(response.status);\n}\nfunction parseCacheControl(header) {\n  var cc = {};\n  if (!header) return cc;\n\n  // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n  // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n  var parts = header.trim().split(/,/);\n  var _iterator = _createForOfIteratorHelper(parts),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n      var _part$split = part.split(/=/, 2),\n        _part$split2 = _slicedToArray(_part$split, 2),\n        k = _part$split2[0],\n        v = _part$split2[1];\n      cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, '');\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return cc;\n}\nfunction formatCacheControl(cc) {\n  var parts = [];\n  for (var k in cc) {\n    var v = cc[k];\n    parts.push(v === true ? k : k + '=' + v);\n  }\n  if (!parts.length) {\n    return undefined;\n  }\n  return parts.join(', ');\n}\nmodule.exports = /*#__PURE__*/function () {\n  function CachePolicy(req, res) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      shared = _ref.shared,\n      cacheHeuristic = _ref.cacheHeuristic,\n      immutableMinTimeToLive = _ref.immutableMinTimeToLive,\n      ignoreCargoCult = _ref.ignoreCargoCult,\n      _fromObject = _ref._fromObject;\n    _classCallCheck(this, CachePolicy);\n    if (_fromObject) {\n      this._fromObject(_fromObject);\n      return;\n    }\n    if (!res || !res.headers) {\n      throw Error('Response headers missing');\n    }\n    this._assertRequestHasHeaders(req);\n    this._responseTime = this.now();\n    this._isShared = shared !== false;\n    this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n    this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n    this._status = 'status' in res ? res.status : 200;\n    this._resHeaders = res.headers;\n    this._rescc = parseCacheControl(res.headers['cache-control']);\n    this._method = 'method' in req ? req.method : 'GET';\n    this._url = req.url;\n    this._host = req.headers.host;\n    this._noAuthorization = !req.headers.authorization;\n    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n    this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n    // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n    // so there's no point stricly adhering to the blindly copy&pasted directives.\n    if (ignoreCargoCult && 'pre-check' in this._rescc && 'post-check' in this._rescc) {\n      delete this._rescc['pre-check'];\n      delete this._rescc['post-check'];\n      delete this._rescc['no-cache'];\n      delete this._rescc['no-store'];\n      delete this._rescc['must-revalidate'];\n      this._resHeaders = Object.assign({}, this._resHeaders, {\n        'cache-control': formatCacheControl(this._rescc)\n      });\n      delete this._resHeaders.expires;\n      delete this._resHeaders.pragma;\n    }\n\n    // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n    // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n    if (res.headers['cache-control'] == null && /no-cache/.test(res.headers.pragma)) {\n      this._rescc['no-cache'] = true;\n    }\n  }\n  _createClass(CachePolicy, [{\n    key: \"now\",\n    value: function now() {\n      return Date.now();\n    }\n  }, {\n    key: \"storable\",\n    value: function storable() {\n      // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n      return !!(!this._reqcc['no-store'] && (\n      // A cache MUST NOT store a response to any request, unless:\n      // The request method is understood by the cache and defined as being cacheable, and\n      'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) &&\n      // the response status code is understood by the cache, and\n      understoodStatuses.has(this._status) &&\n      // the \"no-store\" cache directive does not appear in request or response header fields, and\n      !this._rescc['no-store'] && (\n      // the \"private\" response directive does not appear in the response, if the cache is shared, and\n      !this._isShared || !this._rescc.private) && (\n      // the Authorization header field does not appear in the request, if the cache is shared,\n      !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (\n      // the response either:\n      // contains an Expires header field, or\n      this._resHeaders.expires ||\n      // contains a max-age response directive, or\n      // contains a s-maxage response directive and the cache is shared, or\n      // contains a public response directive.\n      this._rescc['max-age'] || this._isShared && this._rescc['s-maxage'] || this._rescc.public ||\n      // has a status code that is defined as cacheable by default\n      statusCodeCacheableByDefault.has(this._status)));\n    }\n  }, {\n    key: \"_hasExplicitExpiration\",\n    value: function _hasExplicitExpiration() {\n      // 4.2.1 Calculating Freshness Lifetime\n      return this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires;\n    }\n  }, {\n    key: \"_assertRequestHasHeaders\",\n    value: function _assertRequestHasHeaders(req) {\n      if (!req || !req.headers) {\n        throw Error('Request headers missing');\n      }\n    }\n  }, {\n    key: \"satisfiesWithoutRevalidation\",\n    value: function satisfiesWithoutRevalidation(req) {\n      this._assertRequestHasHeaders(req);\n\n      // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n      // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n      // unless the stored response is successfully validated (Section 4.3), and\n      var requestCC = parseCacheControl(req.headers['cache-control']);\n      if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n        return false;\n      }\n      if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n        return false;\n      }\n      if (requestCC['min-fresh'] && this.timeToLive() < 1000 * requestCC['min-fresh']) {\n        return false;\n      }\n\n      // the stored response is either:\n      // fresh, or allowed to be served stale\n      if (this.stale()) {\n        var allowsStale = requestCC['max-stale'] && !this._rescc['must-revalidate'] && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n        if (!allowsStale) {\n          return false;\n        }\n      }\n      return this._requestMatches(req, false);\n    }\n  }, {\n    key: \"_requestMatches\",\n    value: function _requestMatches(req, allowHeadMethod) {\n      // The presented effective request URI and that of the stored response match, and\n      return (!this._url || this._url === req.url) && this._host === req.headers.host && (\n      // the request method associated with the stored response allows it to be used for the presented request, and\n      !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) &&\n      // selecting header fields nominated by the stored response (if any) match those presented, and\n      this._varyMatches(req);\n    }\n  }, {\n    key: \"_allowsStoringAuthenticated\",\n    value: function _allowsStoringAuthenticated() {\n      //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n      return this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage'];\n    }\n  }, {\n    key: \"_varyMatches\",\n    value: function _varyMatches(req) {\n      if (!this._resHeaders.vary) {\n        return true;\n      }\n\n      // A Vary header field-value of \"*\" always fails to match\n      if (this._resHeaders.vary === '*') {\n        return false;\n      }\n      var fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n      var _iterator2 = _createForOfIteratorHelper(fields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var name = _step2.value;\n          if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return true;\n    }\n  }, {\n    key: \"_copyWithoutHopByHopHeaders\",\n    value: function _copyWithoutHopByHopHeaders(inHeaders) {\n      var headers = {};\n      for (var name in inHeaders) {\n        if (hopByHopHeaders[name]) continue;\n        headers[name] = inHeaders[name];\n      }\n      // 9.1.  Connection\n      if (inHeaders.connection) {\n        var tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n        var _iterator3 = _createForOfIteratorHelper(tokens),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _name = _step3.value;\n            delete headers[_name];\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      if (headers.warning) {\n        var warnings = headers.warning.split(/,/).filter(function (warning) {\n          return !/^\\s*1[0-9][0-9]/.test(warning);\n        });\n        if (!warnings.length) {\n          delete headers.warning;\n        } else {\n          headers.warning = warnings.join(',').trim();\n        }\n      }\n      return headers;\n    }\n  }, {\n    key: \"responseHeaders\",\n    value: function responseHeaders() {\n      var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n      var age = this.age();\n\n      // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n      // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n      if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n        headers.warning = (headers.warning ? \"\".concat(headers.warning, \", \") : '') + '113 - \"rfc7234 5.5.4\"';\n      }\n      headers.age = \"\".concat(Math.round(age));\n      headers.date = new Date(this.now()).toUTCString();\n      return headers;\n    }\n\n    /**\n     * Value of the Date response header or current time if Date was invalid\n     * @return timestamp\n     */\n  }, {\n    key: \"date\",\n    value: function date() {\n      var serverDate = Date.parse(this._resHeaders.date);\n      if (isFinite(serverDate)) {\n        return serverDate;\n      }\n      return this._responseTime;\n    }\n\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     *\n     * @return Number\n     */\n  }, {\n    key: \"age\",\n    value: function age() {\n      var age = this._ageValue();\n      var residentTime = (this.now() - this._responseTime) / 1000;\n      return age + residentTime;\n    }\n  }, {\n    key: \"_ageValue\",\n    value: function _ageValue() {\n      return toNumberOrZero(this._resHeaders.age);\n    }\n\n    /**\n     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * @return Number\n     */\n  }, {\n    key: \"maxAge\",\n    value: function maxAge() {\n      if (!this.storable() || this._rescc['no-cache']) {\n        return 0;\n      }\n\n      // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n      // so this implementation requires explicit opt-in via public header\n      if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {\n        return 0;\n      }\n      if (this._resHeaders.vary === '*') {\n        return 0;\n      }\n      if (this._isShared) {\n        if (this._rescc['proxy-revalidate']) {\n          return 0;\n        }\n        // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n        if (this._rescc['s-maxage']) {\n          return toNumberOrZero(this._rescc['s-maxage']);\n        }\n      }\n\n      // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n      if (this._rescc['max-age']) {\n        return toNumberOrZero(this._rescc['max-age']);\n      }\n      var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n      var serverDate = this.date();\n      if (this._resHeaders.expires) {\n        var expires = Date.parse(this._resHeaders.expires);\n        // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n        if (Number.isNaN(expires) || expires < serverDate) {\n          return 0;\n        }\n        return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n      }\n      if (this._resHeaders['last-modified']) {\n        var lastModified = Date.parse(this._resHeaders['last-modified']);\n        if (isFinite(lastModified) && serverDate > lastModified) {\n          return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);\n        }\n      }\n      return defaultMinTtl;\n    }\n  }, {\n    key: \"timeToLive\",\n    value: function timeToLive() {\n      var age = this.maxAge() - this.age();\n      var staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n      var staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n      return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;\n    }\n  }, {\n    key: \"stale\",\n    value: function stale() {\n      return this.maxAge() <= this.age();\n    }\n  }, {\n    key: \"_useStaleIfError\",\n    value: function _useStaleIfError() {\n      return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n  }, {\n    key: \"useStaleWhileRevalidate\",\n    value: function useStaleWhileRevalidate() {\n      return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();\n    }\n  }, {\n    key: \"_fromObject\",\n    value: function _fromObject(obj) {\n      if (this._responseTime) throw Error('Reinitialized');\n      if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n      this._responseTime = obj.t;\n      this._isShared = obj.sh;\n      this._cacheHeuristic = obj.ch;\n      this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n      this._status = obj.st;\n      this._resHeaders = obj.resh;\n      this._rescc = obj.rescc;\n      this._method = obj.m;\n      this._url = obj.u;\n      this._host = obj.h;\n      this._noAuthorization = obj.a;\n      this._reqHeaders = obj.reqh;\n      this._reqcc = obj.reqcc;\n    }\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        v: 1,\n        t: this._responseTime,\n        sh: this._isShared,\n        ch: this._cacheHeuristic,\n        imm: this._immutableMinTtl,\n        st: this._status,\n        resh: this._resHeaders,\n        rescc: this._rescc,\n        m: this._method,\n        u: this._url,\n        h: this._host,\n        a: this._noAuthorization,\n        reqh: this._reqHeaders,\n        reqcc: this._reqcc\n      };\n    }\n\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     */\n  }, {\n    key: \"revalidationHeaders\",\n    value: function revalidationHeaders(incomingReq) {\n      this._assertRequestHasHeaders(incomingReq);\n      var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n      // This implementation does not understand range requests\n      delete headers['if-range'];\n      if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n        // revalidation allowed via HEAD\n        // not for the same resource, or wasn't allowed to be cached anyway\n        delete headers['if-none-match'];\n        delete headers['if-modified-since'];\n        return headers;\n      }\n\n      /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n      if (this._resHeaders.etag) {\n        headers['if-none-match'] = headers['if-none-match'] ? \"\".concat(headers['if-none-match'], \", \").concat(this._resHeaders.etag) : this._resHeaders.etag;\n      }\n\n      // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n      var forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';\n\n      /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n      Note: This implementation does not understand partial responses (206) */\n      if (forbidsWeakValidators) {\n        delete headers['if-modified-since'];\n        if (headers['if-none-match']) {\n          var etags = headers['if-none-match'].split(/,/).filter(function (etag) {\n            return !/^\\s*W\\//.test(etag);\n          });\n          if (!etags.length) {\n            delete headers['if-none-match'];\n          } else {\n            headers['if-none-match'] = etags.join(',').trim();\n          }\n        }\n      } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {\n        headers['if-modified-since'] = this._resHeaders['last-modified'];\n      }\n      return headers;\n    }\n\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @return {Object} {policy: CachePolicy, modified: Boolean}\n     */\n  }, {\n    key: \"revalidatedPolicy\",\n    value: function revalidatedPolicy(request, response) {\n      this._assertRequestHasHeaders(request);\n      if (this._useStaleIfError() && isErrorResponse(response)) {\n        // I consider the revalidation request unsuccessful\n        return {\n          modified: false,\n          matches: false,\n          policy: this\n        };\n      }\n      if (!response || !response.headers) {\n        throw Error('Response headers missing');\n      }\n\n      // These aren't going to be supported exactly, since one CachePolicy object\n      // doesn't know about all the other cached objects.\n      var matches = false;\n      if (response.status !== undefined && response.status != 304) {\n        matches = false;\n      } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n        // \"All of the stored responses with the same strong validator are selected.\n        // If none of the stored responses contain the same strong validator,\n        // then the cache MUST NOT use the new response to update any stored responses.\"\n        matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag;\n      } else if (this._resHeaders.etag && response.headers.etag) {\n        // \"If the new response contains a weak validator and that validator corresponds\n        // to one of the cache's stored responses,\n        // then the most recent of those matching stored responses is selected for update.\"\n        matches = this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag.replace(/^\\s*W\\//, '');\n      } else if (this._resHeaders['last-modified']) {\n        matches = this._resHeaders['last-modified'] === response.headers['last-modified'];\n      } else {\n        // If the new response does not include any form of validator (such as in the case where\n        // a client generates an If-Modified-Since request from a source other than the Last-Modified\n        // response header field), and there is only one stored response, and that stored response also\n        // lacks a validator, then that stored response is selected for update.\n        if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {\n          matches = true;\n        }\n      }\n      if (!matches) {\n        return {\n          policy: new this.constructor(request, response),\n          // Client receiving 304 without body, even if it's invalid/mismatched has no option\n          // but to reuse a cached body. We don't have a good way to tell clients to do\n          // error recovery in such case.\n          modified: response.status != 304,\n          matches: false\n        };\n      }\n\n      // use other header fields provided in the 304 (Not Modified) response to replace all instances\n      // of the corresponding header fields in the stored response.\n      var headers = {};\n      for (var k in this._resHeaders) {\n        headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n      }\n      var newResponse = Object.assign({}, response, {\n        status: this._status,\n        method: this._method,\n        headers: headers\n      });\n      return {\n        policy: new this.constructor(request, newResponse, {\n          shared: this._isShared,\n          cacheHeuristic: this._cacheHeuristic,\n          immutableMinTimeToLive: this._immutableMinTtl\n        }),\n        modified: false,\n        matches: true\n      };\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(obj) {\n      return new this(undefined, undefined, {\n        _fromObject: obj\n      });\n    }\n  }]);\n  return CachePolicy;\n}();","map":{"version":3,"names":["_classCallCheck","require","default","_createClass","_slicedToArray","_createForOfIteratorHelper","statusCodeCacheableByDefault","Set","understoodStatuses","errorStatusCodes","hopByHopHeaders","date","connection","te","trailer","upgrade","excludedFromRevalidationUpdate","toNumberOrZero","s","n","parseInt","isFinite","isErrorResponse","response","has","status","parseCacheControl","header","cc","parts","trim","split","_iterator","_step","done","part","value","_part$split","_part$split2","k","v","undefined","replace","err","e","f","formatCacheControl","push","length","join","module","exports","CachePolicy","req","res","_ref","arguments","shared","cacheHeuristic","immutableMinTimeToLive","ignoreCargoCult","_fromObject","headers","Error","_assertRequestHasHeaders","_responseTime","now","_isShared","_cacheHeuristic","_immutableMinTtl","_status","_resHeaders","_rescc","_method","method","_url","url","_host","host","_noAuthorization","authorization","_reqHeaders","vary","_reqcc","Object","assign","expires","pragma","test","key","Date","storable","_hasExplicitExpiration","private","_allowsStoringAuthenticated","public","satisfiesWithoutRevalidation","requestCC","age","timeToLive","stale","allowsStale","maxAge","_requestMatches","allowHeadMethod","_varyMatches","fields","toLowerCase","_iterator2","_step2","name","_copyWithoutHopByHopHeaders","inHeaders","tokens","_iterator3","_step3","warning","warnings","filter","responseHeaders","concat","Math","round","toUTCString","serverDate","parse","_ageValue","residentTime","immutable","defaultMinTtl","Number","isNaN","max","lastModified","staleIfErrorAge","staleWhileRevalidateAge","_useStaleIfError","useStaleWhileRevalidate","obj","t","sh","ch","imm","st","resh","rescc","m","u","h","a","reqh","reqcc","toObject","revalidationHeaders","incomingReq","etag","forbidsWeakValidators","etags","revalidatedPolicy","request","modified","matches","policy","constructor","newResponse","fromObject"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/http-cache-semantics/index.js"],"sourcesContent":["'use strict';\n// rfc7231 6.1\nconst statusCodeCacheableByDefault = new Set([\n    200,\n    203,\n    204,\n    206,\n    300,\n    301,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n// This implementation does not understand partial responses (206)\nconst understoodStatuses = new Set([\n    200,\n    203,\n    204,\n    300,\n    301,\n    302,\n    303,\n    307,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\nconst errorStatusCodes = new Set([\n    500,\n    502,\n    503, \n    504,\n]);\n\nconst hopByHopHeaders = {\n    date: true, // included, because we add Age update Date\n    connection: true,\n    'keep-alive': true,\n    'proxy-authenticate': true,\n    'proxy-authorization': true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n};\n\nconst excludedFromRevalidationUpdate = {\n    // Since the old body is reused, it doesn't make sense to change properties of the body\n    'content-length': true,\n    'content-encoding': true,\n    'transfer-encoding': true,\n    'content-range': true,\n};\n\nfunction toNumberOrZero(s) {\n    const n = parseInt(s, 10);\n    return isFinite(n) ? n : 0;\n}\n\n// RFC 5861\nfunction isErrorResponse(response) {\n    // consider undefined response as faulty\n    if(!response) {\n        return true\n    }\n    return errorStatusCodes.has(response.status);\n}\n\nfunction parseCacheControl(header) {\n    const cc = {};\n    if (!header) return cc;\n\n    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n    const parts = header.trim().split(/,/);\n    for (const part of parts) {\n        const [k, v] = part.split(/=/, 2);\n        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, '');\n    }\n\n    return cc;\n}\n\nfunction formatCacheControl(cc) {\n    let parts = [];\n    for (const k in cc) {\n        const v = cc[k];\n        parts.push(v === true ? k : k + '=' + v);\n    }\n    if (!parts.length) {\n        return undefined;\n    }\n    return parts.join(', ');\n}\n\nmodule.exports = class CachePolicy {\n    constructor(\n        req,\n        res,\n        {\n            shared,\n            cacheHeuristic,\n            immutableMinTimeToLive,\n            ignoreCargoCult,\n            _fromObject,\n        } = {}\n    ) {\n        if (_fromObject) {\n            this._fromObject(_fromObject);\n            return;\n        }\n\n        if (!res || !res.headers) {\n            throw Error('Response headers missing');\n        }\n        this._assertRequestHasHeaders(req);\n\n        this._responseTime = this.now();\n        this._isShared = shared !== false;\n        this._cacheHeuristic =\n            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n        this._immutableMinTtl =\n            undefined !== immutableMinTimeToLive\n                ? immutableMinTimeToLive\n                : 24 * 3600 * 1000;\n\n        this._status = 'status' in res ? res.status : 200;\n        this._resHeaders = res.headers;\n        this._rescc = parseCacheControl(res.headers['cache-control']);\n        this._method = 'method' in req ? req.method : 'GET';\n        this._url = req.url;\n        this._host = req.headers.host;\n        this._noAuthorization = !req.headers.authorization;\n        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n        this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n        // so there's no point stricly adhering to the blindly copy&pasted directives.\n        if (\n            ignoreCargoCult &&\n            'pre-check' in this._rescc &&\n            'post-check' in this._rescc\n        ) {\n            delete this._rescc['pre-check'];\n            delete this._rescc['post-check'];\n            delete this._rescc['no-cache'];\n            delete this._rescc['no-store'];\n            delete this._rescc['must-revalidate'];\n            this._resHeaders = Object.assign({}, this._resHeaders, {\n                'cache-control': formatCacheControl(this._rescc),\n            });\n            delete this._resHeaders.expires;\n            delete this._resHeaders.pragma;\n        }\n\n        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n        // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n        if (\n            res.headers['cache-control'] == null &&\n            /no-cache/.test(res.headers.pragma)\n        ) {\n            this._rescc['no-cache'] = true;\n        }\n    }\n\n    now() {\n        return Date.now();\n    }\n\n    storable() {\n        // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n        return !!(\n            !this._reqcc['no-store'] &&\n            // A cache MUST NOT store a response to any request, unless:\n            // The request method is understood by the cache and defined as being cacheable, and\n            ('GET' === this._method ||\n                'HEAD' === this._method ||\n                ('POST' === this._method && this._hasExplicitExpiration())) &&\n            // the response status code is understood by the cache, and\n            understoodStatuses.has(this._status) &&\n            // the \"no-store\" cache directive does not appear in request or response header fields, and\n            !this._rescc['no-store'] &&\n            // the \"private\" response directive does not appear in the response, if the cache is shared, and\n            (!this._isShared || !this._rescc.private) &&\n            // the Authorization header field does not appear in the request, if the cache is shared,\n            (!this._isShared ||\n                this._noAuthorization ||\n                this._allowsStoringAuthenticated()) &&\n            // the response either:\n            // contains an Expires header field, or\n            (this._resHeaders.expires ||\n                // contains a max-age response directive, or\n                // contains a s-maxage response directive and the cache is shared, or\n                // contains a public response directive.\n                this._rescc['max-age'] ||\n                (this._isShared && this._rescc['s-maxage']) ||\n                this._rescc.public ||\n                // has a status code that is defined as cacheable by default\n                statusCodeCacheableByDefault.has(this._status))\n        );\n    }\n\n    _hasExplicitExpiration() {\n        // 4.2.1 Calculating Freshness Lifetime\n        return (\n            (this._isShared && this._rescc['s-maxage']) ||\n            this._rescc['max-age'] ||\n            this._resHeaders.expires\n        );\n    }\n\n    _assertRequestHasHeaders(req) {\n        if (!req || !req.headers) {\n            throw Error('Request headers missing');\n        }\n    }\n\n    satisfiesWithoutRevalidation(req) {\n        this._assertRequestHasHeaders(req);\n\n        // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n        // unless the stored response is successfully validated (Section 4.3), and\n        const requestCC = parseCacheControl(req.headers['cache-control']);\n        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n            return false;\n        }\n\n        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {\n            return false;\n        }\n\n        if (\n            requestCC['min-fresh'] &&\n            this.timeToLive() < 1000 * requestCC['min-fresh']\n        ) {\n            return false;\n        }\n\n        // the stored response is either:\n        // fresh, or allowed to be served stale\n        if (this.stale()) {\n            const allowsStale =\n                requestCC['max-stale'] &&\n                !this._rescc['must-revalidate'] &&\n                (true === requestCC['max-stale'] ||\n                    requestCC['max-stale'] > this.age() - this.maxAge());\n            if (!allowsStale) {\n                return false;\n            }\n        }\n\n        return this._requestMatches(req, false);\n    }\n\n    _requestMatches(req, allowHeadMethod) {\n        // The presented effective request URI and that of the stored response match, and\n        return (\n            (!this._url || this._url === req.url) &&\n            this._host === req.headers.host &&\n            // the request method associated with the stored response allows it to be used for the presented request, and\n            (!req.method ||\n                this._method === req.method ||\n                (allowHeadMethod && 'HEAD' === req.method)) &&\n            // selecting header fields nominated by the stored response (if any) match those presented, and\n            this._varyMatches(req)\n        );\n    }\n\n    _allowsStoringAuthenticated() {\n        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n        return (\n            this._rescc['must-revalidate'] ||\n            this._rescc.public ||\n            this._rescc['s-maxage']\n        );\n    }\n\n    _varyMatches(req) {\n        if (!this._resHeaders.vary) {\n            return true;\n        }\n\n        // A Vary header field-value of \"*\" always fails to match\n        if (this._resHeaders.vary === '*') {\n            return false;\n        }\n\n        const fields = this._resHeaders.vary\n            .trim()\n            .toLowerCase()\n            .split(/\\s*,\\s*/);\n        for (const name of fields) {\n            if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n        return true;\n    }\n\n    _copyWithoutHopByHopHeaders(inHeaders) {\n        const headers = {};\n        for (const name in inHeaders) {\n            if (hopByHopHeaders[name]) continue;\n            headers[name] = inHeaders[name];\n        }\n        // 9.1.  Connection\n        if (inHeaders.connection) {\n            const tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n            for (const name of tokens) {\n                delete headers[name];\n            }\n        }\n        if (headers.warning) {\n            const warnings = headers.warning.split(/,/).filter(warning => {\n                return !/^\\s*1[0-9][0-9]/.test(warning);\n            });\n            if (!warnings.length) {\n                delete headers.warning;\n            } else {\n                headers.warning = warnings.join(',').trim();\n            }\n        }\n        return headers;\n    }\n\n    responseHeaders() {\n        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n        const age = this.age();\n\n        // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n        // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n        if (\n            age > 3600 * 24 &&\n            !this._hasExplicitExpiration() &&\n            this.maxAge() > 3600 * 24\n        ) {\n            headers.warning =\n                (headers.warning ? `${headers.warning}, ` : '') +\n                '113 - \"rfc7234 5.5.4\"';\n        }\n        headers.age = `${Math.round(age)}`;\n        headers.date = new Date(this.now()).toUTCString();\n        return headers;\n    }\n\n    /**\n     * Value of the Date response header or current time if Date was invalid\n     * @return timestamp\n     */\n    date() {\n        const serverDate = Date.parse(this._resHeaders.date);\n        if (isFinite(serverDate)) {\n            return serverDate;\n        }\n        return this._responseTime;\n    }\n\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     *\n     * @return Number\n     */\n    age() {\n        let age = this._ageValue();\n\n        const residentTime = (this.now() - this._responseTime) / 1000;\n        return age + residentTime;\n    }\n\n    _ageValue() {\n        return toNumberOrZero(this._resHeaders.age);\n    }\n\n    /**\n     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * @return Number\n     */\n    maxAge() {\n        if (!this.storable() || this._rescc['no-cache']) {\n            return 0;\n        }\n\n        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n        // so this implementation requires explicit opt-in via public header\n        if (\n            this._isShared &&\n            (this._resHeaders['set-cookie'] &&\n                !this._rescc.public &&\n                !this._rescc.immutable)\n        ) {\n            return 0;\n        }\n\n        if (this._resHeaders.vary === '*') {\n            return 0;\n        }\n\n        if (this._isShared) {\n            if (this._rescc['proxy-revalidate']) {\n                return 0;\n            }\n            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n            if (this._rescc['s-maxage']) {\n                return toNumberOrZero(this._rescc['s-maxage']);\n            }\n        }\n\n        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n        if (this._rescc['max-age']) {\n            return toNumberOrZero(this._rescc['max-age']);\n        }\n\n        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n\n        const serverDate = this.date();\n        if (this._resHeaders.expires) {\n            const expires = Date.parse(this._resHeaders.expires);\n            // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n            if (Number.isNaN(expires) || expires < serverDate) {\n                return 0;\n            }\n            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n        }\n\n        if (this._resHeaders['last-modified']) {\n            const lastModified = Date.parse(this._resHeaders['last-modified']);\n            if (isFinite(lastModified) && serverDate > lastModified) {\n                return Math.max(\n                    defaultMinTtl,\n                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic\n                );\n            }\n        }\n\n        return defaultMinTtl;\n    }\n\n    timeToLive() {\n        const age = this.maxAge() - this.age();\n        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;\n    }\n\n    stale() {\n        return this.maxAge() <= this.age();\n    }\n\n    _useStaleIfError() {\n        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n\n    useStaleWhileRevalidate() {\n        return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();\n    }\n\n    static fromObject(obj) {\n        return new this(undefined, undefined, { _fromObject: obj });\n    }\n\n    _fromObject(obj) {\n        if (this._responseTime) throw Error('Reinitialized');\n        if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n\n        this._responseTime = obj.t;\n        this._isShared = obj.sh;\n        this._cacheHeuristic = obj.ch;\n        this._immutableMinTtl =\n            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n        this._status = obj.st;\n        this._resHeaders = obj.resh;\n        this._rescc = obj.rescc;\n        this._method = obj.m;\n        this._url = obj.u;\n        this._host = obj.h;\n        this._noAuthorization = obj.a;\n        this._reqHeaders = obj.reqh;\n        this._reqcc = obj.reqcc;\n    }\n\n    toObject() {\n        return {\n            v: 1,\n            t: this._responseTime,\n            sh: this._isShared,\n            ch: this._cacheHeuristic,\n            imm: this._immutableMinTtl,\n            st: this._status,\n            resh: this._resHeaders,\n            rescc: this._rescc,\n            m: this._method,\n            u: this._url,\n            h: this._host,\n            a: this._noAuthorization,\n            reqh: this._reqHeaders,\n            reqcc: this._reqcc,\n        };\n    }\n\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     */\n    revalidationHeaders(incomingReq) {\n        this._assertRequestHasHeaders(incomingReq);\n        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n        // This implementation does not understand range requests\n        delete headers['if-range'];\n\n        if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n            // revalidation allowed via HEAD\n            // not for the same resource, or wasn't allowed to be cached anyway\n            delete headers['if-none-match'];\n            delete headers['if-modified-since'];\n            return headers;\n        }\n\n        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n        if (this._resHeaders.etag) {\n            headers['if-none-match'] = headers['if-none-match']\n                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`\n                : this._resHeaders.etag;\n        }\n\n        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n        const forbidsWeakValidators =\n            headers['accept-ranges'] ||\n            headers['if-match'] ||\n            headers['if-unmodified-since'] ||\n            (this._method && this._method != 'GET');\n\n        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n        Note: This implementation does not understand partial responses (206) */\n        if (forbidsWeakValidators) {\n            delete headers['if-modified-since'];\n\n            if (headers['if-none-match']) {\n                const etags = headers['if-none-match']\n                    .split(/,/)\n                    .filter(etag => {\n                        return !/^\\s*W\\//.test(etag);\n                    });\n                if (!etags.length) {\n                    delete headers['if-none-match'];\n                } else {\n                    headers['if-none-match'] = etags.join(',').trim();\n                }\n            }\n        } else if (\n            this._resHeaders['last-modified'] &&\n            !headers['if-modified-since']\n        ) {\n            headers['if-modified-since'] = this._resHeaders['last-modified'];\n        }\n\n        return headers;\n    }\n\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @return {Object} {policy: CachePolicy, modified: Boolean}\n     */\n    revalidatedPolicy(request, response) {\n        this._assertRequestHasHeaders(request);\n        if(this._useStaleIfError() && isErrorResponse(response)) {  // I consider the revalidation request unsuccessful\n          return {\n            modified: false,\n            matches: false,\n            policy: this,\n          };\n        }\n        if (!response || !response.headers) {\n            throw Error('Response headers missing');\n        }\n\n        // These aren't going to be supported exactly, since one CachePolicy object\n        // doesn't know about all the other cached objects.\n        let matches = false;\n        if (response.status !== undefined && response.status != 304) {\n            matches = false;\n        } else if (\n            response.headers.etag &&\n            !/^\\s*W\\//.test(response.headers.etag)\n        ) {\n            // \"All of the stored responses with the same strong validator are selected.\n            // If none of the stored responses contain the same strong validator,\n            // then the cache MUST NOT use the new response to update any stored responses.\"\n            matches =\n                this._resHeaders.etag &&\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                    response.headers.etag;\n        } else if (this._resHeaders.etag && response.headers.etag) {\n            // \"If the new response contains a weak validator and that validator corresponds\n            // to one of the cache's stored responses,\n            // then the most recent of those matching stored responses is selected for update.\"\n            matches =\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                response.headers.etag.replace(/^\\s*W\\//, '');\n        } else if (this._resHeaders['last-modified']) {\n            matches =\n                this._resHeaders['last-modified'] ===\n                response.headers['last-modified'];\n        } else {\n            // If the new response does not include any form of validator (such as in the case where\n            // a client generates an If-Modified-Since request from a source other than the Last-Modified\n            // response header field), and there is only one stored response, and that stored response also\n            // lacks a validator, then that stored response is selected for update.\n            if (\n                !this._resHeaders.etag &&\n                !this._resHeaders['last-modified'] &&\n                !response.headers.etag &&\n                !response.headers['last-modified']\n            ) {\n                matches = true;\n            }\n        }\n\n        if (!matches) {\n            return {\n                policy: new this.constructor(request, response),\n                // Client receiving 304 without body, even if it's invalid/mismatched has no option\n                // but to reuse a cached body. We don't have a good way to tell clients to do\n                // error recovery in such case.\n                modified: response.status != 304,\n                matches: false,\n            };\n        }\n\n        // use other header fields provided in the 304 (Not Modified) response to replace all instances\n        // of the corresponding header fields in the stored response.\n        const headers = {};\n        for (const k in this._resHeaders) {\n            headers[k] =\n                k in response.headers && !excludedFromRevalidationUpdate[k]\n                    ? response.headers[k]\n                    : this._resHeaders[k];\n        }\n\n        const newResponse = Object.assign({}, response, {\n            status: this._status,\n            method: this._method,\n            headers,\n        });\n        return {\n            policy: new this.constructor(request, newResponse, {\n                shared: this._isShared,\n                cacheHeuristic: this._cacheHeuristic,\n                immutableMinTimeToLive: this._immutableMinTtl,\n            }),\n            modified: false,\n            matches: true,\n        };\n    }\n};\n"],"mappings":"AAAA,YAAY;;AACZ;AAAA,IAAAA,eAAA,GAAAC,OAAA,4FAAAC,OAAA;AAAA,IAAAC,YAAA,GAAAF,OAAA,yFAAAC,OAAA;AAAA,IAAAE,cAAA,GAAAH,OAAA,2FAAAC,OAAA;AAAA,IAAAG,0BAAA,GAAAJ,OAAA,uGAAAC,OAAA;AACA,IAAMI,4BAA4B,GAAG,IAAIC,GAAG,CAAC,CACzC,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,CACN,CAAC;;AAEF;AACA,IAAMC,kBAAkB,GAAG,IAAID,GAAG,CAAC,CAC/B,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,CACN,CAAC;AAEF,IAAME,gBAAgB,GAAG,IAAIF,GAAG,CAAC,CAC7B,GAAG,EACH,GAAG,EACH,GAAG,EACH,GAAG,CACN,CAAC;AAEF,IAAMG,eAAe,GAAG;EACpBC,IAAI,EAAE,IAAI;EAAE;EACZC,UAAU,EAAE,IAAI;EAChB,YAAY,EAAE,IAAI;EAClB,oBAAoB,EAAE,IAAI;EAC1B,qBAAqB,EAAE,IAAI;EAC3BC,EAAE,EAAE,IAAI;EACRC,OAAO,EAAE,IAAI;EACb,mBAAmB,EAAE,IAAI;EACzBC,OAAO,EAAE;AACb,CAAC;AAED,IAAMC,8BAA8B,GAAG;EACnC;EACA,gBAAgB,EAAE,IAAI;EACtB,kBAAkB,EAAE,IAAI;EACxB,mBAAmB,EAAE,IAAI;EACzB,eAAe,EAAE;AACrB,CAAC;AAED,SAASC,cAAcA,CAACC,CAAC,EAAE;EACvB,IAAMC,CAAC,GAAGC,QAAQ,CAACF,CAAC,EAAE,EAAE,CAAC;EACzB,OAAOG,QAAQ,CAACF,CAAC,CAAC,GAAGA,CAAC,GAAG,CAAC;AAC9B;;AAEA;AACA,SAASG,eAAeA,CAACC,QAAQ,EAAE;EAC/B;EACA,IAAG,CAACA,QAAQ,EAAE;IACV,OAAO,IAAI;EACf;EACA,OAAOd,gBAAgB,CAACe,GAAG,CAACD,QAAQ,CAACE,MAAM,CAAC;AAChD;AAEA,SAASC,iBAAiBA,CAACC,MAAM,EAAE;EAC/B,IAAMC,EAAE,GAAG,CAAC,CAAC;EACb,IAAI,CAACD,MAAM,EAAE,OAAOC,EAAE;;EAEtB;EACA;EACA,IAAMC,KAAK,GAAGF,MAAM,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC;EAAC,IAAAC,SAAA,GAAA3B,0BAAA,CACpBwB,KAAK;IAAAI,KAAA;EAAA;IAAxB,KAAAD,SAAA,CAAAd,CAAA,MAAAe,KAAA,GAAAD,SAAA,CAAAb,CAAA,IAAAe,IAAA,GAA0B;MAAA,IAAfC,IAAI,GAAAF,KAAA,CAAAG,KAAA;MACX,IAAAC,WAAA,GAAeF,IAAI,CAACJ,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;QAAAO,YAAA,GAAAlC,cAAA,CAAAiC,WAAA;QAA1BE,CAAC,GAAAD,YAAA;QAAEE,CAAC,GAAAF,YAAA;MACXV,EAAE,CAACW,CAAC,CAACT,IAAI,CAAC,CAAC,CAAC,GAAGU,CAAC,KAAKC,SAAS,GAAG,IAAI,GAAGD,CAAC,CAACV,IAAI,CAAC,CAAC,CAACY,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAC1E;EAAC,SAAAC,GAAA;IAAAX,SAAA,CAAAY,CAAA,CAAAD,GAAA;EAAA;IAAAX,SAAA,CAAAa,CAAA;EAAA;EAED,OAAOjB,EAAE;AACb;AAEA,SAASkB,kBAAkBA,CAAClB,EAAE,EAAE;EAC5B,IAAIC,KAAK,GAAG,EAAE;EACd,KAAK,IAAMU,CAAC,IAAIX,EAAE,EAAE;IAChB,IAAMY,CAAC,GAAGZ,EAAE,CAACW,CAAC,CAAC;IACfV,KAAK,CAACkB,IAAI,CAACP,CAAC,KAAK,IAAI,GAAGD,CAAC,GAAGA,CAAC,GAAG,GAAG,GAAGC,CAAC,CAAC;EAC5C;EACA,IAAI,CAACX,KAAK,CAACmB,MAAM,EAAE;IACf,OAAOP,SAAS;EACpB;EACA,OAAOZ,KAAK,CAACoB,IAAI,CAAC,IAAI,CAAC;AAC3B;AAEAC,MAAM,CAACC,OAAO;EACV,SAAAC,YACIC,GAAG,EACHC,GAAG,EAQL;IAAA,IAAAC,IAAA,GAAAC,SAAA,CAAAR,MAAA,QAAAQ,SAAA,QAAAf,SAAA,GAAAe,SAAA,MADM,CAAC,CAAC;MALFC,MAAM,GAAAF,IAAA,CAANE,MAAM;MACNC,cAAc,GAAAH,IAAA,CAAdG,cAAc;MACdC,sBAAsB,GAAAJ,IAAA,CAAtBI,sBAAsB;MACtBC,eAAe,GAAAL,IAAA,CAAfK,eAAe;MACfC,WAAW,GAAAN,IAAA,CAAXM,WAAW;IAAA7D,eAAA,OAAAoD,WAAA;IAGf,IAAIS,WAAW,EAAE;MACb,IAAI,CAACA,WAAW,CAACA,WAAW,CAAC;MAC7B;IACJ;IAEA,IAAI,CAACP,GAAG,IAAI,CAACA,GAAG,CAACQ,OAAO,EAAE;MACtB,MAAMC,KAAK,CAAC,0BAA0B,CAAC;IAC3C;IACA,IAAI,CAACC,wBAAwB,CAACX,GAAG,CAAC;IAElC,IAAI,CAACY,aAAa,GAAG,IAAI,CAACC,GAAG,CAAC,CAAC;IAC/B,IAAI,CAACC,SAAS,GAAGV,MAAM,KAAK,KAAK;IACjC,IAAI,CAACW,eAAe,GAChB3B,SAAS,KAAKiB,cAAc,GAAGA,cAAc,GAAG,GAAG,CAAC,CAAC;IACzD,IAAI,CAACW,gBAAgB,GACjB5B,SAAS,KAAKkB,sBAAsB,GAC9BA,sBAAsB,GACtB,EAAE,GAAG,IAAI,GAAG,IAAI;IAE1B,IAAI,CAACW,OAAO,GAAG,QAAQ,IAAIhB,GAAG,GAAGA,GAAG,CAAC7B,MAAM,GAAG,GAAG;IACjD,IAAI,CAAC8C,WAAW,GAAGjB,GAAG,CAACQ,OAAO;IAC9B,IAAI,CAACU,MAAM,GAAG9C,iBAAiB,CAAC4B,GAAG,CAACQ,OAAO,CAAC,eAAe,CAAC,CAAC;IAC7D,IAAI,CAACW,OAAO,GAAG,QAAQ,IAAIpB,GAAG,GAAGA,GAAG,CAACqB,MAAM,GAAG,KAAK;IACnD,IAAI,CAACC,IAAI,GAAGtB,GAAG,CAACuB,GAAG;IACnB,IAAI,CAACC,KAAK,GAAGxB,GAAG,CAACS,OAAO,CAACgB,IAAI;IAC7B,IAAI,CAACC,gBAAgB,GAAG,CAAC1B,GAAG,CAACS,OAAO,CAACkB,aAAa;IAClD,IAAI,CAACC,WAAW,GAAG3B,GAAG,CAACQ,OAAO,CAACoB,IAAI,GAAG7B,GAAG,CAACS,OAAO,GAAG,IAAI,CAAC,CAAC;IAC1D,IAAI,CAACqB,MAAM,GAAGzD,iBAAiB,CAAC2B,GAAG,CAACS,OAAO,CAAC,eAAe,CAAC,CAAC;;IAE7D;IACA;IACA,IACIF,eAAe,IACf,WAAW,IAAI,IAAI,CAACY,MAAM,IAC1B,YAAY,IAAI,IAAI,CAACA,MAAM,EAC7B;MACE,OAAO,IAAI,CAACA,MAAM,CAAC,WAAW,CAAC;MAC/B,OAAO,IAAI,CAACA,MAAM,CAAC,YAAY,CAAC;MAChC,OAAO,IAAI,CAACA,MAAM,CAAC,UAAU,CAAC;MAC9B,OAAO,IAAI,CAACA,MAAM,CAAC,UAAU,CAAC;MAC9B,OAAO,IAAI,CAACA,MAAM,CAAC,iBAAiB,CAAC;MACrC,IAAI,CAACD,WAAW,GAAGa,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACd,WAAW,EAAE;QACnD,eAAe,EAAEzB,kBAAkB,CAAC,IAAI,CAAC0B,MAAM;MACnD,CAAC,CAAC;MACF,OAAO,IAAI,CAACD,WAAW,CAACe,OAAO;MAC/B,OAAO,IAAI,CAACf,WAAW,CAACgB,MAAM;IAClC;;IAEA;IACA;IACA,IACIjC,GAAG,CAACQ,OAAO,CAAC,eAAe,CAAC,IAAI,IAAI,IACpC,UAAU,CAAC0B,IAAI,CAAClC,GAAG,CAACQ,OAAO,CAACyB,MAAM,CAAC,EACrC;MACE,IAAI,CAACf,MAAM,CAAC,UAAU,CAAC,GAAG,IAAI;IAClC;EACJ;EAACrE,YAAA,CAAAiD,WAAA;IAAAqC,GAAA;IAAArD,KAAA,EAED,SAAA8B,IAAA,EAAM;MACF,OAAOwB,IAAI,CAACxB,GAAG,CAAC,CAAC;IACrB;EAAC;IAAAuB,GAAA;IAAArD,KAAA,EAED,SAAAuD,SAAA,EAAW;MACP;MACA,OAAO,CAAC,EACJ,CAAC,IAAI,CAACR,MAAM,CAAC,UAAU,CAAC;MACxB;MACA;MACC,KAAK,KAAK,IAAI,CAACV,OAAO,IACnB,MAAM,KAAK,IAAI,CAACA,OAAO,IACtB,MAAM,KAAK,IAAI,CAACA,OAAO,IAAI,IAAI,CAACmB,sBAAsB,CAAC,CAAE,CAAC;MAC/D;MACApF,kBAAkB,CAACgB,GAAG,CAAC,IAAI,CAAC8C,OAAO,CAAC;MACpC;MACA,CAAC,IAAI,CAACE,MAAM,CAAC,UAAU,CAAC;MACxB;MACC,CAAC,IAAI,CAACL,SAAS,IAAI,CAAC,IAAI,CAACK,MAAM,CAACqB,OAAO,CAAC;MACzC;MACC,CAAC,IAAI,CAAC1B,SAAS,IACZ,IAAI,CAACY,gBAAgB,IACrB,IAAI,CAACe,2BAA2B,CAAC,CAAC,CAAC;MACvC;MACA;MACC,IAAI,CAACvB,WAAW,CAACe,OAAO;MACrB;MACA;MACA;MACA,IAAI,CAACd,MAAM,CAAC,SAAS,CAAC,IACrB,IAAI,CAACL,SAAS,IAAI,IAAI,CAACK,MAAM,CAAC,UAAU,CAAE,IAC3C,IAAI,CAACA,MAAM,CAACuB,MAAM;MAClB;MACAzF,4BAA4B,CAACkB,GAAG,CAAC,IAAI,CAAC8C,OAAO,CAAC,CAAC,CACtD;IACL;EAAC;IAAAmB,GAAA;IAAArD,KAAA,EAED,SAAAwD,uBAAA,EAAyB;MACrB;MACA,OACK,IAAI,CAACzB,SAAS,IAAI,IAAI,CAACK,MAAM,CAAC,UAAU,CAAC,IAC1C,IAAI,CAACA,MAAM,CAAC,SAAS,CAAC,IACtB,IAAI,CAACD,WAAW,CAACe,OAAO;IAEhC;EAAC;IAAAG,GAAA;IAAArD,KAAA,EAED,SAAA4B,yBAAyBX,GAAG,EAAE;MAC1B,IAAI,CAACA,GAAG,IAAI,CAACA,GAAG,CAACS,OAAO,EAAE;QACtB,MAAMC,KAAK,CAAC,yBAAyB,CAAC;MAC1C;IACJ;EAAC;IAAA0B,GAAA;IAAArD,KAAA,EAED,SAAA4D,6BAA6B3C,GAAG,EAAE;MAC9B,IAAI,CAACW,wBAAwB,CAACX,GAAG,CAAC;;MAElC;MACA;MACA;MACA,IAAM4C,SAAS,GAAGvE,iBAAiB,CAAC2B,GAAG,CAACS,OAAO,CAAC,eAAe,CAAC,CAAC;MACjE,IAAImC,SAAS,CAAC,UAAU,CAAC,IAAI,UAAU,CAACT,IAAI,CAACnC,GAAG,CAACS,OAAO,CAACyB,MAAM,CAAC,EAAE;QAC9D,OAAO,KAAK;MAChB;MAEA,IAAIU,SAAS,CAAC,SAAS,CAAC,IAAI,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGD,SAAS,CAAC,SAAS,CAAC,EAAE;QAC3D,OAAO,KAAK;MAChB;MAEA,IACIA,SAAS,CAAC,WAAW,CAAC,IACtB,IAAI,CAACE,UAAU,CAAC,CAAC,GAAG,IAAI,GAAGF,SAAS,CAAC,WAAW,CAAC,EACnD;QACE,OAAO,KAAK;MAChB;;MAEA;MACA;MACA,IAAI,IAAI,CAACG,KAAK,CAAC,CAAC,EAAE;QACd,IAAMC,WAAW,GACbJ,SAAS,CAAC,WAAW,CAAC,IACtB,CAAC,IAAI,CAACzB,MAAM,CAAC,iBAAiB,CAAC,KAC9B,IAAI,KAAKyB,SAAS,CAAC,WAAW,CAAC,IAC5BA,SAAS,CAAC,WAAW,CAAC,GAAG,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACI,MAAM,CAAC,CAAC,CAAC;QAC5D,IAAI,CAACD,WAAW,EAAE;UACd,OAAO,KAAK;QAChB;MACJ;MAEA,OAAO,IAAI,CAACE,eAAe,CAAClD,GAAG,EAAE,KAAK,CAAC;IAC3C;EAAC;IAAAoC,GAAA;IAAArD,KAAA,EAED,SAAAmE,gBAAgBlD,GAAG,EAAEmD,eAAe,EAAE;MAClC;MACA,OACI,CAAC,CAAC,IAAI,CAAC7B,IAAI,IAAI,IAAI,CAACA,IAAI,KAAKtB,GAAG,CAACuB,GAAG,KACpC,IAAI,CAACC,KAAK,KAAKxB,GAAG,CAACS,OAAO,CAACgB,IAAI;MAC/B;MACC,CAACzB,GAAG,CAACqB,MAAM,IACR,IAAI,CAACD,OAAO,KAAKpB,GAAG,CAACqB,MAAM,IAC1B8B,eAAe,IAAI,MAAM,KAAKnD,GAAG,CAACqB,MAAO,CAAC;MAC/C;MACA,IAAI,CAAC+B,YAAY,CAACpD,GAAG,CAAC;IAE9B;EAAC;IAAAoC,GAAA;IAAArD,KAAA,EAED,SAAA0D,4BAAA,EAA8B;MAC1B;MACA,OACI,IAAI,CAACtB,MAAM,CAAC,iBAAiB,CAAC,IAC9B,IAAI,CAACA,MAAM,CAACuB,MAAM,IAClB,IAAI,CAACvB,MAAM,CAAC,UAAU,CAAC;IAE/B;EAAC;IAAAiB,GAAA;IAAArD,KAAA,EAED,SAAAqE,aAAapD,GAAG,EAAE;MACd,IAAI,CAAC,IAAI,CAACkB,WAAW,CAACW,IAAI,EAAE;QACxB,OAAO,IAAI;MACf;;MAEA;MACA,IAAI,IAAI,CAACX,WAAW,CAACW,IAAI,KAAK,GAAG,EAAE;QAC/B,OAAO,KAAK;MAChB;MAEA,IAAMwB,MAAM,GAAG,IAAI,CAACnC,WAAW,CAACW,IAAI,CAC/BpD,IAAI,CAAC,CAAC,CACN6E,WAAW,CAAC,CAAC,CACb5E,KAAK,CAAC,SAAS,CAAC;MAAC,IAAA6E,UAAA,GAAAvG,0BAAA,CACHqG,MAAM;QAAAG,MAAA;MAAA;QAAzB,KAAAD,UAAA,CAAA1F,CAAA,MAAA2F,MAAA,GAAAD,UAAA,CAAAzF,CAAA,IAAAe,IAAA,GAA2B;UAAA,IAAhB4E,IAAI,GAAAD,MAAA,CAAAzE,KAAA;UACX,IAAIiB,GAAG,CAACS,OAAO,CAACgD,IAAI,CAAC,KAAK,IAAI,CAAC7B,WAAW,CAAC6B,IAAI,CAAC,EAAE,OAAO,KAAK;QAClE;MAAC,SAAAnE,GAAA;QAAAiE,UAAA,CAAAhE,CAAA,CAAAD,GAAA;MAAA;QAAAiE,UAAA,CAAA/D,CAAA;MAAA;MACD,OAAO,IAAI;IACf;EAAC;IAAA4C,GAAA;IAAArD,KAAA,EAED,SAAA2E,4BAA4BC,SAAS,EAAE;MACnC,IAAMlD,OAAO,GAAG,CAAC,CAAC;MAClB,KAAK,IAAMgD,IAAI,IAAIE,SAAS,EAAE;QAC1B,IAAItG,eAAe,CAACoG,IAAI,CAAC,EAAE;QAC3BhD,OAAO,CAACgD,IAAI,CAAC,GAAGE,SAAS,CAACF,IAAI,CAAC;MACnC;MACA;MACA,IAAIE,SAAS,CAACpG,UAAU,EAAE;QACtB,IAAMqG,MAAM,GAAGD,SAAS,CAACpG,UAAU,CAACkB,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,SAAS,CAAC;QAAC,IAAAmF,UAAA,GAAA7G,0BAAA,CACzC4G,MAAM;UAAAE,MAAA;QAAA;UAAzB,KAAAD,UAAA,CAAAhG,CAAA,MAAAiG,MAAA,GAAAD,UAAA,CAAA/F,CAAA,IAAAe,IAAA,GAA2B;YAAA,IAAhB4E,KAAI,GAAAK,MAAA,CAAA/E,KAAA;YACX,OAAO0B,OAAO,CAACgD,KAAI,CAAC;UACxB;QAAC,SAAAnE,GAAA;UAAAuE,UAAA,CAAAtE,CAAA,CAAAD,GAAA;QAAA;UAAAuE,UAAA,CAAArE,CAAA;QAAA;MACL;MACA,IAAIiB,OAAO,CAACsD,OAAO,EAAE;QACjB,IAAMC,QAAQ,GAAGvD,OAAO,CAACsD,OAAO,CAACrF,KAAK,CAAC,GAAG,CAAC,CAACuF,MAAM,CAAC,UAAAF,OAAO,EAAI;UAC1D,OAAO,CAAC,iBAAiB,CAAC5B,IAAI,CAAC4B,OAAO,CAAC;QAC3C,CAAC,CAAC;QACF,IAAI,CAACC,QAAQ,CAACrE,MAAM,EAAE;UAClB,OAAOc,OAAO,CAACsD,OAAO;QAC1B,CAAC,MAAM;UACHtD,OAAO,CAACsD,OAAO,GAAGC,QAAQ,CAACpE,IAAI,CAAC,GAAG,CAAC,CAACnB,IAAI,CAAC,CAAC;QAC/C;MACJ;MACA,OAAOgC,OAAO;IAClB;EAAC;IAAA2B,GAAA;IAAArD,KAAA,EAED,SAAAmF,gBAAA,EAAkB;MACd,IAAMzD,OAAO,GAAG,IAAI,CAACiD,2BAA2B,CAAC,IAAI,CAACxC,WAAW,CAAC;MAClE,IAAM2B,GAAG,GAAG,IAAI,CAACA,GAAG,CAAC,CAAC;;MAEtB;MACA;MACA,IACIA,GAAG,GAAG,IAAI,GAAG,EAAE,IACf,CAAC,IAAI,CAACN,sBAAsB,CAAC,CAAC,IAC9B,IAAI,CAACU,MAAM,CAAC,CAAC,GAAG,IAAI,GAAG,EAAE,EAC3B;QACExC,OAAO,CAACsD,OAAO,GACX,CAACtD,OAAO,CAACsD,OAAO,MAAAI,MAAA,CAAM1D,OAAO,CAACsD,OAAO,UAAO,EAAE,IAC9C,uBAAuB;MAC/B;MACAtD,OAAO,CAACoC,GAAG,MAAAsB,MAAA,CAAMC,IAAI,CAACC,KAAK,CAACxB,GAAG,CAAC,CAAE;MAClCpC,OAAO,CAACnD,IAAI,GAAG,IAAI+E,IAAI,CAAC,IAAI,CAACxB,GAAG,CAAC,CAAC,CAAC,CAACyD,WAAW,CAAC,CAAC;MACjD,OAAO7D,OAAO;IAClB;;IAEA;AACJ;AACA;AACA;EAHI;IAAA2B,GAAA;IAAArD,KAAA,EAIA,SAAAzB,KAAA,EAAO;MACH,IAAMiH,UAAU,GAAGlC,IAAI,CAACmC,KAAK,CAAC,IAAI,CAACtD,WAAW,CAAC5D,IAAI,CAAC;MACpD,IAAIU,QAAQ,CAACuG,UAAU,CAAC,EAAE;QACtB,OAAOA,UAAU;MACrB;MACA,OAAO,IAAI,CAAC3D,aAAa;IAC7B;;IAEA;AACJ;AACA;AACA;AACA;AACA;EALI;IAAAwB,GAAA;IAAArD,KAAA,EAMA,SAAA8D,IAAA,EAAM;MACF,IAAIA,GAAG,GAAG,IAAI,CAAC4B,SAAS,CAAC,CAAC;MAE1B,IAAMC,YAAY,GAAG,CAAC,IAAI,CAAC7D,GAAG,CAAC,CAAC,GAAG,IAAI,CAACD,aAAa,IAAI,IAAI;MAC7D,OAAOiC,GAAG,GAAG6B,YAAY;IAC7B;EAAC;IAAAtC,GAAA;IAAArD,KAAA,EAED,SAAA0F,UAAA,EAAY;MACR,OAAO7G,cAAc,CAAC,IAAI,CAACsD,WAAW,CAAC2B,GAAG,CAAC;IAC/C;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EANI;IAAAT,GAAA;IAAArD,KAAA,EAOA,SAAAkE,OAAA,EAAS;MACL,IAAI,CAAC,IAAI,CAACX,QAAQ,CAAC,CAAC,IAAI,IAAI,CAACnB,MAAM,CAAC,UAAU,CAAC,EAAE;QAC7C,OAAO,CAAC;MACZ;;MAEA;MACA;MACA,IACI,IAAI,CAACL,SAAS,IACb,IAAI,CAACI,WAAW,CAAC,YAAY,CAAC,IAC3B,CAAC,IAAI,CAACC,MAAM,CAACuB,MAAM,IACnB,CAAC,IAAI,CAACvB,MAAM,CAACwD,SAAU,EAC7B;QACE,OAAO,CAAC;MACZ;MAEA,IAAI,IAAI,CAACzD,WAAW,CAACW,IAAI,KAAK,GAAG,EAAE;QAC/B,OAAO,CAAC;MACZ;MAEA,IAAI,IAAI,CAACf,SAAS,EAAE;QAChB,IAAI,IAAI,CAACK,MAAM,CAAC,kBAAkB,CAAC,EAAE;UACjC,OAAO,CAAC;QACZ;QACA;QACA,IAAI,IAAI,CAACA,MAAM,CAAC,UAAU,CAAC,EAAE;UACzB,OAAOvD,cAAc,CAAC,IAAI,CAACuD,MAAM,CAAC,UAAU,CAAC,CAAC;QAClD;MACJ;;MAEA;MACA,IAAI,IAAI,CAACA,MAAM,CAAC,SAAS,CAAC,EAAE;QACxB,OAAOvD,cAAc,CAAC,IAAI,CAACuD,MAAM,CAAC,SAAS,CAAC,CAAC;MACjD;MAEA,IAAMyD,aAAa,GAAG,IAAI,CAACzD,MAAM,CAACwD,SAAS,GAAG,IAAI,CAAC3D,gBAAgB,GAAG,CAAC;MAEvE,IAAMuD,UAAU,GAAG,IAAI,CAACjH,IAAI,CAAC,CAAC;MAC9B,IAAI,IAAI,CAAC4D,WAAW,CAACe,OAAO,EAAE;QAC1B,IAAMA,OAAO,GAAGI,IAAI,CAACmC,KAAK,CAAC,IAAI,CAACtD,WAAW,CAACe,OAAO,CAAC;QACpD;QACA,IAAI4C,MAAM,CAACC,KAAK,CAAC7C,OAAO,CAAC,IAAIA,OAAO,GAAGsC,UAAU,EAAE;UAC/C,OAAO,CAAC;QACZ;QACA,OAAOH,IAAI,CAACW,GAAG,CAACH,aAAa,EAAE,CAAC3C,OAAO,GAAGsC,UAAU,IAAI,IAAI,CAAC;MACjE;MAEA,IAAI,IAAI,CAACrD,WAAW,CAAC,eAAe,CAAC,EAAE;QACnC,IAAM8D,YAAY,GAAG3C,IAAI,CAACmC,KAAK,CAAC,IAAI,CAACtD,WAAW,CAAC,eAAe,CAAC,CAAC;QAClE,IAAIlD,QAAQ,CAACgH,YAAY,CAAC,IAAIT,UAAU,GAAGS,YAAY,EAAE;UACrD,OAAOZ,IAAI,CAACW,GAAG,CACXH,aAAa,EACZ,CAACL,UAAU,GAAGS,YAAY,IAAI,IAAI,GAAI,IAAI,CAACjE,eAChD,CAAC;QACL;MACJ;MAEA,OAAO6D,aAAa;IACxB;EAAC;IAAAxC,GAAA;IAAArD,KAAA,EAED,SAAA+D,WAAA,EAAa;MACT,IAAMD,GAAG,GAAG,IAAI,CAACI,MAAM,CAAC,CAAC,GAAG,IAAI,CAACJ,GAAG,CAAC,CAAC;MACtC,IAAMoC,eAAe,GAAGpC,GAAG,GAAGjF,cAAc,CAAC,IAAI,CAACuD,MAAM,CAAC,gBAAgB,CAAC,CAAC;MAC3E,IAAM+D,uBAAuB,GAAGrC,GAAG,GAAGjF,cAAc,CAAC,IAAI,CAACuD,MAAM,CAAC,wBAAwB,CAAC,CAAC;MAC3F,OAAOiD,IAAI,CAACW,GAAG,CAAC,CAAC,EAAElC,GAAG,EAAEoC,eAAe,EAAEC,uBAAuB,CAAC,GAAG,IAAI;IAC5E;EAAC;IAAA9C,GAAA;IAAArD,KAAA,EAED,SAAAgE,MAAA,EAAQ;MACJ,OAAO,IAAI,CAACE,MAAM,CAAC,CAAC,IAAI,IAAI,CAACJ,GAAG,CAAC,CAAC;IACtC;EAAC;IAAAT,GAAA;IAAArD,KAAA,EAED,SAAAoG,iBAAA,EAAmB;MACf,OAAO,IAAI,CAAClC,MAAM,CAAC,CAAC,GAAGrF,cAAc,CAAC,IAAI,CAACuD,MAAM,CAAC,gBAAgB,CAAC,CAAC,GAAG,IAAI,CAAC0B,GAAG,CAAC,CAAC;IACrF;EAAC;IAAAT,GAAA;IAAArD,KAAA,EAED,SAAAqG,wBAAA,EAA0B;MACtB,OAAO,IAAI,CAACnC,MAAM,CAAC,CAAC,GAAGrF,cAAc,CAAC,IAAI,CAACuD,MAAM,CAAC,wBAAwB,CAAC,CAAC,GAAG,IAAI,CAAC0B,GAAG,CAAC,CAAC;IAC7F;EAAC;IAAAT,GAAA;IAAArD,KAAA,EAMD,SAAAyB,YAAY6E,GAAG,EAAE;MACb,IAAI,IAAI,CAACzE,aAAa,EAAE,MAAMF,KAAK,CAAC,eAAe,CAAC;MACpD,IAAI,CAAC2E,GAAG,IAAIA,GAAG,CAAClG,CAAC,KAAK,CAAC,EAAE,MAAMuB,KAAK,CAAC,uBAAuB,CAAC;MAE7D,IAAI,CAACE,aAAa,GAAGyE,GAAG,CAACC,CAAC;MAC1B,IAAI,CAACxE,SAAS,GAAGuE,GAAG,CAACE,EAAE;MACvB,IAAI,CAACxE,eAAe,GAAGsE,GAAG,CAACG,EAAE;MAC7B,IAAI,CAACxE,gBAAgB,GACjBqE,GAAG,CAACI,GAAG,KAAKrG,SAAS,GAAGiG,GAAG,CAACI,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI;MACtD,IAAI,CAACxE,OAAO,GAAGoE,GAAG,CAACK,EAAE;MACrB,IAAI,CAACxE,WAAW,GAAGmE,GAAG,CAACM,IAAI;MAC3B,IAAI,CAACxE,MAAM,GAAGkE,GAAG,CAACO,KAAK;MACvB,IAAI,CAACxE,OAAO,GAAGiE,GAAG,CAACQ,CAAC;MACpB,IAAI,CAACvE,IAAI,GAAG+D,GAAG,CAACS,CAAC;MACjB,IAAI,CAACtE,KAAK,GAAG6D,GAAG,CAACU,CAAC;MAClB,IAAI,CAACrE,gBAAgB,GAAG2D,GAAG,CAACW,CAAC;MAC7B,IAAI,CAACpE,WAAW,GAAGyD,GAAG,CAACY,IAAI;MAC3B,IAAI,CAACnE,MAAM,GAAGuD,GAAG,CAACa,KAAK;IAC3B;EAAC;IAAA9D,GAAA;IAAArD,KAAA,EAED,SAAAoH,SAAA,EAAW;MACP,OAAO;QACHhH,CAAC,EAAE,CAAC;QACJmG,CAAC,EAAE,IAAI,CAAC1E,aAAa;QACrB2E,EAAE,EAAE,IAAI,CAACzE,SAAS;QAClB0E,EAAE,EAAE,IAAI,CAACzE,eAAe;QACxB0E,GAAG,EAAE,IAAI,CAACzE,gBAAgB;QAC1B0E,EAAE,EAAE,IAAI,CAACzE,OAAO;QAChB0E,IAAI,EAAE,IAAI,CAACzE,WAAW;QACtB0E,KAAK,EAAE,IAAI,CAACzE,MAAM;QAClB0E,CAAC,EAAE,IAAI,CAACzE,OAAO;QACf0E,CAAC,EAAE,IAAI,CAACxE,IAAI;QACZyE,CAAC,EAAE,IAAI,CAACvE,KAAK;QACbwE,CAAC,EAAE,IAAI,CAACtE,gBAAgB;QACxBuE,IAAI,EAAE,IAAI,CAACrE,WAAW;QACtBsE,KAAK,EAAE,IAAI,CAACpE;MAChB,CAAC;IACL;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EANI;IAAAM,GAAA;IAAArD,KAAA,EAOA,SAAAqH,oBAAoBC,WAAW,EAAE;MAC7B,IAAI,CAAC1F,wBAAwB,CAAC0F,WAAW,CAAC;MAC1C,IAAM5F,OAAO,GAAG,IAAI,CAACiD,2BAA2B,CAAC2C,WAAW,CAAC5F,OAAO,CAAC;;MAErE;MACA,OAAOA,OAAO,CAAC,UAAU,CAAC;MAE1B,IAAI,CAAC,IAAI,CAACyC,eAAe,CAACmD,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC/D,QAAQ,CAAC,CAAC,EAAE;QAC9D;QACA;QACA,OAAO7B,OAAO,CAAC,eAAe,CAAC;QAC/B,OAAOA,OAAO,CAAC,mBAAmB,CAAC;QACnC,OAAOA,OAAO;MAClB;;MAEA;MACA,IAAI,IAAI,CAACS,WAAW,CAACoF,IAAI,EAAE;QACvB7F,OAAO,CAAC,eAAe,CAAC,GAAGA,OAAO,CAAC,eAAe,CAAC,MAAA0D,MAAA,CAC1C1D,OAAO,CAAC,eAAe,CAAC,QAAA0D,MAAA,CAAK,IAAI,CAACjD,WAAW,CAACoF,IAAI,IACrD,IAAI,CAACpF,WAAW,CAACoF,IAAI;MAC/B;;MAEA;MACA,IAAMC,qBAAqB,GACvB9F,OAAO,CAAC,eAAe,CAAC,IACxBA,OAAO,CAAC,UAAU,CAAC,IACnBA,OAAO,CAAC,qBAAqB,CAAC,IAC7B,IAAI,CAACW,OAAO,IAAI,IAAI,CAACA,OAAO,IAAI,KAAM;;MAE3C;AACR;MACQ,IAAImF,qBAAqB,EAAE;QACvB,OAAO9F,OAAO,CAAC,mBAAmB,CAAC;QAEnC,IAAIA,OAAO,CAAC,eAAe,CAAC,EAAE;UAC1B,IAAM+F,KAAK,GAAG/F,OAAO,CAAC,eAAe,CAAC,CACjC/B,KAAK,CAAC,GAAG,CAAC,CACVuF,MAAM,CAAC,UAAAqC,IAAI,EAAI;YACZ,OAAO,CAAC,SAAS,CAACnE,IAAI,CAACmE,IAAI,CAAC;UAChC,CAAC,CAAC;UACN,IAAI,CAACE,KAAK,CAAC7G,MAAM,EAAE;YACf,OAAOc,OAAO,CAAC,eAAe,CAAC;UACnC,CAAC,MAAM;YACHA,OAAO,CAAC,eAAe,CAAC,GAAG+F,KAAK,CAAC5G,IAAI,CAAC,GAAG,CAAC,CAACnB,IAAI,CAAC,CAAC;UACrD;QACJ;MACJ,CAAC,MAAM,IACH,IAAI,CAACyC,WAAW,CAAC,eAAe,CAAC,IACjC,CAACT,OAAO,CAAC,mBAAmB,CAAC,EAC/B;QACEA,OAAO,CAAC,mBAAmB,CAAC,GAAG,IAAI,CAACS,WAAW,CAAC,eAAe,CAAC;MACpE;MAEA,OAAOT,OAAO;IAClB;;IAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EARI;IAAA2B,GAAA;IAAArD,KAAA,EASA,SAAA0H,kBAAkBC,OAAO,EAAExI,QAAQ,EAAE;MACjC,IAAI,CAACyC,wBAAwB,CAAC+F,OAAO,CAAC;MACtC,IAAG,IAAI,CAACvB,gBAAgB,CAAC,CAAC,IAAIlH,eAAe,CAACC,QAAQ,CAAC,EAAE;QAAG;QAC1D,OAAO;UACLyI,QAAQ,EAAE,KAAK;UACfC,OAAO,EAAE,KAAK;UACdC,MAAM,EAAE;QACV,CAAC;MACH;MACA,IAAI,CAAC3I,QAAQ,IAAI,CAACA,QAAQ,CAACuC,OAAO,EAAE;QAChC,MAAMC,KAAK,CAAC,0BAA0B,CAAC;MAC3C;;MAEA;MACA;MACA,IAAIkG,OAAO,GAAG,KAAK;MACnB,IAAI1I,QAAQ,CAACE,MAAM,KAAKgB,SAAS,IAAIlB,QAAQ,CAACE,MAAM,IAAI,GAAG,EAAE;QACzDwI,OAAO,GAAG,KAAK;MACnB,CAAC,MAAM,IACH1I,QAAQ,CAACuC,OAAO,CAAC6F,IAAI,IACrB,CAAC,SAAS,CAACnE,IAAI,CAACjE,QAAQ,CAACuC,OAAO,CAAC6F,IAAI,CAAC,EACxC;QACE;QACA;QACA;QACAM,OAAO,GACH,IAAI,CAAC1F,WAAW,CAACoF,IAAI,IACrB,IAAI,CAACpF,WAAW,CAACoF,IAAI,CAACjH,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,KACxCnB,QAAQ,CAACuC,OAAO,CAAC6F,IAAI;MACjC,CAAC,MAAM,IAAI,IAAI,CAACpF,WAAW,CAACoF,IAAI,IAAIpI,QAAQ,CAACuC,OAAO,CAAC6F,IAAI,EAAE;QACvD;QACA;QACA;QACAM,OAAO,GACH,IAAI,CAAC1F,WAAW,CAACoF,IAAI,CAACjH,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,KAC5CnB,QAAQ,CAACuC,OAAO,CAAC6F,IAAI,CAACjH,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;MACpD,CAAC,MAAM,IAAI,IAAI,CAAC6B,WAAW,CAAC,eAAe,CAAC,EAAE;QAC1C0F,OAAO,GACH,IAAI,CAAC1F,WAAW,CAAC,eAAe,CAAC,KACjChD,QAAQ,CAACuC,OAAO,CAAC,eAAe,CAAC;MACzC,CAAC,MAAM;QACH;QACA;QACA;QACA;QACA,IACI,CAAC,IAAI,CAACS,WAAW,CAACoF,IAAI,IACtB,CAAC,IAAI,CAACpF,WAAW,CAAC,eAAe,CAAC,IAClC,CAAChD,QAAQ,CAACuC,OAAO,CAAC6F,IAAI,IACtB,CAACpI,QAAQ,CAACuC,OAAO,CAAC,eAAe,CAAC,EACpC;UACEmG,OAAO,GAAG,IAAI;QAClB;MACJ;MAEA,IAAI,CAACA,OAAO,EAAE;QACV,OAAO;UACHC,MAAM,EAAE,IAAI,IAAI,CAACC,WAAW,CAACJ,OAAO,EAAExI,QAAQ,CAAC;UAC/C;UACA;UACA;UACAyI,QAAQ,EAAEzI,QAAQ,CAACE,MAAM,IAAI,GAAG;UAChCwI,OAAO,EAAE;QACb,CAAC;MACL;;MAEA;MACA;MACA,IAAMnG,OAAO,GAAG,CAAC,CAAC;MAClB,KAAK,IAAMvB,CAAC,IAAI,IAAI,CAACgC,WAAW,EAAE;QAC9BT,OAAO,CAACvB,CAAC,CAAC,GACNA,CAAC,IAAIhB,QAAQ,CAACuC,OAAO,IAAI,CAAC9C,8BAA8B,CAACuB,CAAC,CAAC,GACrDhB,QAAQ,CAACuC,OAAO,CAACvB,CAAC,CAAC,GACnB,IAAI,CAACgC,WAAW,CAAChC,CAAC,CAAC;MACjC;MAEA,IAAM6H,WAAW,GAAGhF,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE9D,QAAQ,EAAE;QAC5CE,MAAM,EAAE,IAAI,CAAC6C,OAAO;QACpBI,MAAM,EAAE,IAAI,CAACD,OAAO;QACpBX,OAAO,EAAPA;MACJ,CAAC,CAAC;MACF,OAAO;QACHoG,MAAM,EAAE,IAAI,IAAI,CAACC,WAAW,CAACJ,OAAO,EAAEK,WAAW,EAAE;UAC/C3G,MAAM,EAAE,IAAI,CAACU,SAAS;UACtBT,cAAc,EAAE,IAAI,CAACU,eAAe;UACpCT,sBAAsB,EAAE,IAAI,CAACU;QACjC,CAAC,CAAC;QACF2F,QAAQ,EAAE,KAAK;QACfC,OAAO,EAAE;MACb,CAAC;IACL;EAAC;IAAAxE,GAAA;IAAArD,KAAA,EA7MD,SAAAiI,WAAkB3B,GAAG,EAAE;MACnB,OAAO,IAAI,IAAI,CAACjG,SAAS,EAAEA,SAAS,EAAE;QAAEoB,WAAW,EAAE6E;MAAI,CAAC,CAAC;IAC/D;EAAC;EAAA,OAAAtF,WAAA;AAAA,GA4MJ"},"metadata":{},"sourceType":"script"}