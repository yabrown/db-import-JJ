{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instanceLookup = instanceLookup;\nexports.parseBrowserResponse = parseBrowserResponse;\nvar _dns = _interopRequireDefault(require(\"dns\"));\nvar _abortError = _interopRequireDefault(require(\"./errors/abort-error\"));\nvar _sender = require(\"./sender\");\nvar _withTimeout = require(\"./utils/with-timeout\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar SQL_SERVER_BROWSER_PORT = 1434;\nvar TIMEOUT = 2 * 1000;\nvar RETRIES = 3; // There are three bytes at the start of the response, whose purpose is unknown.\n\nvar MYSTERY_HEADER_LENGTH = 3;\n\n// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\nfunction instanceLookup(_x) {\n  return _instanceLookup.apply(this, arguments);\n}\nfunction _instanceLookup() {\n  _instanceLookup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {\n    var _options$lookup, _options$port;\n    var server, instanceName, timeout, retries, lookup, port, signal, response, i, message, foundPort;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          server = options.server;\n          if (!(typeof server !== 'string')) {\n            _context2.next = 3;\n            break;\n          }\n          throw new TypeError('Invalid arguments: \"server\" must be a string');\n        case 3:\n          instanceName = options.instanceName;\n          if (!(typeof instanceName !== 'string')) {\n            _context2.next = 6;\n            break;\n          }\n          throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n        case 6:\n          timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n          if (!(typeof timeout !== 'number')) {\n            _context2.next = 9;\n            break;\n          }\n          throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n        case 9:\n          retries = options.retries === undefined ? RETRIES : options.retries;\n          if (!(typeof retries !== 'number')) {\n            _context2.next = 12;\n            break;\n          }\n          throw new TypeError('Invalid arguments: \"retries\" must be a number');\n        case 12:\n          if (!(options.lookup !== undefined && typeof options.lookup !== 'function')) {\n            _context2.next = 14;\n            break;\n          }\n          throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n        case 14:\n          lookup = (_options$lookup = options.lookup) !== null && _options$lookup !== void 0 ? _options$lookup : _dns.default.lookup;\n          if (!(options.port !== undefined && typeof options.port !== 'number')) {\n            _context2.next = 17;\n            break;\n          }\n          throw new TypeError('Invalid arguments: \"port\" must be a number');\n        case 17:\n          port = (_options$port = options.port) !== null && _options$port !== void 0 ? _options$port : SQL_SERVER_BROWSER_PORT;\n          signal = options.signal;\n          if (!signal.aborted) {\n            _context2.next = 21;\n            break;\n          }\n          throw new _abortError.default();\n        case 21:\n          i = 0;\n        case 22:\n          if (!(i <= retries)) {\n            _context2.next = 37;\n            break;\n          }\n          _context2.prev = 23;\n          _context2.next = 26;\n          return (0, _withTimeout.withTimeout)(timeout, /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signal) {\n              var request;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    request = Buffer.from([0x02]);\n                    _context.next = 3;\n                    return (0, _sender.sendMessage)(options.server, port, lookup, signal, request);\n                  case 3:\n                    return _context.abrupt(\"return\", _context.sent);\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }));\n            return function (_x2) {\n              return _ref.apply(this, arguments);\n            };\n          }(), signal);\n        case 26:\n          response = _context2.sent;\n          _context2.next = 34;\n          break;\n        case 29:\n          _context2.prev = 29;\n          _context2.t0 = _context2[\"catch\"](23);\n          if (!(!signal.aborted && _context2.t0 instanceof Error && _context2.t0.name === 'TimeoutError')) {\n            _context2.next = 33;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 34);\n        case 33:\n          throw _context2.t0;\n        case 34:\n          i++;\n          _context2.next = 22;\n          break;\n        case 37:\n          if (response) {\n            _context2.next = 39;\n            break;\n          }\n          throw new Error('Failed to get response from SQL Server Browser on ' + server);\n        case 39:\n          message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n          foundPort = parseBrowserResponse(message, instanceName);\n          if (foundPort) {\n            _context2.next = 43;\n            break;\n          }\n          throw new Error('Port for ' + instanceName + ' not found in ' + options.server);\n        case 43:\n          return _context2.abrupt(\"return\", foundPort);\n        case 44:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[23, 29]]);\n  }));\n  return _instanceLookup.apply(this, arguments);\n}\nfunction parseBrowserResponse(response, instanceName) {\n  var getPort;\n  var instances = response.split(';;');\n  for (var i = 0, len = instances.length; i < len; i++) {\n    var instance = instances[i];\n    var parts = instance.split(';');\n    for (var p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n      var name = parts[p];\n      var value = parts[p + 1];\n      if (name === 'tcp' && getPort) {\n        var port = parseInt(value, 10);\n        return port;\n      }\n      if (name === 'InstanceName') {\n        if (value.toUpperCase() === instanceName.toUpperCase()) {\n          getPort = true;\n        } else {\n          getPort = false;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["_dns","_interopRequireDefault","require","_abortError","_sender","_withTimeout","SQL_SERVER_BROWSER_PORT","TIMEOUT","RETRIES","MYSTERY_HEADER_LENGTH","instanceLookup","_x","_instanceLookup","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","options","_options$lookup","_options$port","server","instanceName","timeout","retries","lookup","port","signal","response","i","message","foundPort","wrap","_callee2$","_context2","prev","next","TypeError","undefined","default","aborted","withTimeout","_ref","_callee","request","_callee$","_context","Buffer","from","sendMessage","abrupt","sent","stop","_x2","t0","Error","name","toString","parseBrowserResponse","getPort","instances","split","len","length","instance","parts","p","partsLen","value","parseInt","toUpperCase"],"sources":["../src/instance-lookup.ts"],"sourcesContent":["import dns from 'dns';\nimport { AbortSignal } from 'node-abort-controller';\n\nimport AbortError from './errors/abort-error';\nimport { sendMessage } from './sender';\nimport { withTimeout } from './utils/with-timeout';\n\nconst SQL_SERVER_BROWSER_PORT = 1434;\nconst TIMEOUT = 2 * 1000;\nconst RETRIES = 3;\n// There are three bytes at the start of the response, whose purpose is unknown.\nconst MYSTERY_HEADER_LENGTH = 3;\n\ntype LookupFunction = (hostname: string, options: dns.LookupAllOptions, callback: (err: NodeJS.ErrnoException | null, addresses: dns.LookupAddress[]) => void) => void;\n\n// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.\nexport async function instanceLookup(options: { server: string, instanceName: string, timeout?: number, retries?: number, port?: number, lookup?: LookupFunction, signal: AbortSignal }) {\n  const server = options.server;\n  if (typeof server !== 'string') {\n    throw new TypeError('Invalid arguments: \"server\" must be a string');\n  }\n\n  const instanceName = options.instanceName;\n  if (typeof instanceName !== 'string') {\n    throw new TypeError('Invalid arguments: \"instanceName\" must be a string');\n  }\n\n  const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;\n  if (typeof timeout !== 'number') {\n    throw new TypeError('Invalid arguments: \"timeout\" must be a number');\n  }\n\n  const retries = options.retries === undefined ? RETRIES : options.retries;\n  if (typeof retries !== 'number') {\n    throw new TypeError('Invalid arguments: \"retries\" must be a number');\n  }\n\n  if (options.lookup !== undefined && typeof options.lookup !== 'function') {\n    throw new TypeError('Invalid arguments: \"lookup\" must be a function');\n  }\n  const lookup = options.lookup ?? dns.lookup;\n\n  if (options.port !== undefined && typeof options.port !== 'number') {\n    throw new TypeError('Invalid arguments: \"port\" must be a number');\n  }\n  const port = options.port ?? SQL_SERVER_BROWSER_PORT;\n\n  const signal = options.signal;\n\n  if (signal.aborted) {\n    throw new AbortError();\n  }\n\n  let response;\n\n  for (let i = 0; i <= retries; i++) {\n    try {\n      response = await withTimeout(timeout, async (signal) => {\n        const request = Buffer.from([0x02]);\n        return await sendMessage(options.server, port, lookup, signal, request);\n      }, signal);\n    } catch (err) {\n      // If the current attempt timed out, continue with the next\n      if (!signal.aborted && err instanceof Error && err.name === 'TimeoutError') {\n        continue;\n      }\n\n      throw err;\n    }\n  }\n\n  if (!response) {\n    throw new Error('Failed to get response from SQL Server Browser on ' + server);\n  }\n\n  const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);\n  const foundPort = parseBrowserResponse(message, instanceName);\n\n  if (!foundPort) {\n    throw new Error('Port for ' + instanceName + ' not found in ' + options.server);\n  }\n\n  return foundPort;\n}\n\nexport function parseBrowserResponse(response: string, instanceName: string) {\n  let getPort;\n\n  const instances = response.split(';;');\n  for (let i = 0, len = instances.length; i < len; i++) {\n    const instance = instances[i];\n    const parts = instance.split(';');\n\n    for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {\n      const name = parts[p];\n      const value = parts[p + 1];\n\n      if (name === 'tcp' && getPort) {\n        const port = parseInt(value, 10);\n        return port;\n      }\n\n      if (name === 'InstanceName') {\n        if (value.toUpperCase() === instanceName.toUpperCase()) {\n          getPort = true;\n        } else {\n          getPort = false;\n        }\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}