{"ast":null,"code":"var _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar CacheSemantics = require('http-cache-semantics');\nvar Negotiator = require('negotiator');\nvar ssri = require('ssri');\n\n// HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\nvar preloadNegotiator = new Negotiator({\n  headers: {}\n});\npreloadNegotiator.charsets();\npreloadNegotiator.encodings();\npreloadNegotiator.languages();\npreloadNegotiator.mediaTypes();\n\n// options passed to http-cache-semantics constructor\nvar policyOptions = {\n  shared: false,\n  ignoreCargoCult: true\n};\n\n// a fake empty response, used when only testing the\n// request for storability\nvar emptyResponse = {\n  status: 200,\n  headers: {}\n};\n\n// returns a plain object representation of the Request\nvar requestObject = function requestObject(request) {\n  var _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {}\n  };\n  request.headers.forEach(function (value, key) {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\n\n// returns a plain object representation of the Response\nvar responseObject = function responseObject(response) {\n  var _obj = {\n    status: response.status,\n    headers: {}\n  };\n  response.headers.forEach(function (value, key) {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\nvar CachePolicy = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function CachePolicy(_ref) {\n    var entry = _ref.entry,\n      request = _ref.request,\n      response = _ref.response,\n      options = _ref.options;\n    _classCallCheck(this, CachePolicy);\n    this.entry = entry;\n    this.request = requestObject(request);\n    this.response = responseObject(response);\n    this.options = options;\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions);\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time;\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  _createClass(CachePolicy, [{\n    key: \"satisfies\",\n    value:\n    // returns true if the policy satisfies the request\n    function satisfies(request) {\n      var _req = requestObject(request);\n      if (this.request.headers.host !== _req.headers.host) return false;\n      var negotiatorA = new Negotiator(this.request);\n      var negotiatorB = new Negotiator(_req);\n      if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) return false;\n      if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) return false;\n      if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) return false;\n      if (this.options.integrity) return ssri.parse(this.options.integrity).match(this.entry.integrity);\n      return true;\n    }\n\n    // returns true if the request and response allow caching\n  }, {\n    key: \"storable\",\n    value: function storable() {\n      return this.policy.storable();\n    }\n\n    // NOTE: this is a hack to avoid parsing the cache-control\n    // header ourselves, it returns true if the response's\n    // cache-control contains must-revalidate\n  }, {\n    key: \"mustRevalidate\",\n    get: function get() {\n      return !!this.policy._rescc['must-revalidate'];\n    }\n\n    // returns true if the cached response requires revalidation\n    // for the given request\n  }, {\n    key: \"needsRevalidation\",\n    value: function needsRevalidation(request) {\n      var _req = requestObject(request);\n      // force method to GET because we only cache GETs\n      // but can serve a HEAD from a cached GET\n      _req.method = 'GET';\n      return !this.policy.satisfiesWithoutRevalidation(_req);\n    }\n  }, {\n    key: \"responseHeaders\",\n    value: function responseHeaders() {\n      return this.policy.responseHeaders();\n    }\n\n    // returns a new object containing the appropriate headers\n    // to send a revalidation request\n  }, {\n    key: \"revalidationHeaders\",\n    value: function revalidationHeaders(request) {\n      var _req = requestObject(request);\n      return this.policy.revalidationHeaders(_req);\n    }\n\n    // returns true if the request/response was revalidated\n    // successfully. returns false if a new response was received\n  }, {\n    key: \"revalidated\",\n    value: function revalidated(request, response) {\n      var _req = requestObject(request);\n      var _res = responseObject(response);\n      var policy = this.policy.revalidatedPolicy(_req, _res);\n      return !policy.modified;\n    }\n  }], [{\n    key: \"storable\",\n    value: function storable(request, options) {\n      // no cachePath means no caching\n      if (!options.cachePath) return false;\n\n      // user explicitly asked not to cache\n      if (options.cache === 'no-store') return false;\n\n      // we only cache GET and HEAD requests\n      if (!['GET', 'HEAD'].includes(request.method)) return false;\n\n      // otherwise, let http-cache-semantics make the decision\n      // based on the request's headers\n      var policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);\n      return policy.storable();\n    }\n  }]);\n  return CachePolicy;\n}();\nmodule.exports = CachePolicy;","map":{"version":3,"names":["CacheSemantics","require","Negotiator","ssri","preloadNegotiator","headers","charsets","encodings","languages","mediaTypes","policyOptions","shared","ignoreCargoCult","emptyResponse","status","requestObject","request","_obj","method","url","forEach","value","key","responseObject","response","CachePolicy","_ref","entry","options","_classCallCheck","policy","_responseTime","metadata","time","_createClass","satisfies","_req","host","negotiatorA","negotiatorB","JSON","stringify","integrity","parse","match","storable","get","_rescc","needsRevalidation","satisfiesWithoutRevalidation","responseHeaders","revalidationHeaders","revalidated","_res","revalidatedPolicy","modified","cachePath","cache","includes","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/make-fetch-happen/lib/cache/policy.js"],"sourcesContent":["const CacheSemantics = require('http-cache-semantics')\nconst Negotiator = require('negotiator')\nconst ssri = require('ssri')\n\n// HACK: negotiator lazy loads several of its own modules\n// as a micro optimization. we need to be sure that they're\n// in memory as soon as possible at startup so that we do\n// not try to lazy load them after the directory has been\n// retired during a self update of the npm CLI, we do this\n// by calling all of the methods that trigger a lazy load\n// on a fake instance.\nconst preloadNegotiator = new Negotiator({ headers: {} })\npreloadNegotiator.charsets()\npreloadNegotiator.encodings()\npreloadNegotiator.languages()\npreloadNegotiator.mediaTypes()\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true,\n}\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = { status: 200, headers: {} }\n\n// returns a plain object representation of the Request\nconst requestObject = (request) => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n  }\n\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\n// returns a plain object representation of the Response\nconst responseObject = (response) => {\n  const _obj = {\n    status: response.status,\n    headers: {},\n  }\n\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\nclass CachePolicy {\n  constructor ({ entry, request, response, options }) {\n    this.entry = entry\n    this.request = requestObject(request)\n    this.response = responseObject(response)\n    this.options = options\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions)\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable (request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath)\n      return false\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store')\n      return false\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method))\n      return false\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions)\n    return policy.storable()\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies (request) {\n    const _req = requestObject(request)\n    if (this.request.headers.host !== _req.headers.host)\n      return false\n\n    const negotiatorA = new Negotiator(this.request)\n    const negotiatorB = new Negotiator(_req)\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes()))\n      return false\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages()))\n      return false\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings()))\n      return false\n\n    if (this.options.integrity)\n      return ssri.parse(this.options.integrity).match(this.entry.integrity)\n\n    return true\n  }\n\n  // returns true if the request and response allow caching\n  storable () {\n    return this.policy.storable()\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate () {\n    return !!this.policy._rescc['must-revalidate']\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation (request) {\n    const _req = requestObject(request)\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET'\n    return !this.policy.satisfiesWithoutRevalidation(_req)\n  }\n\n  responseHeaders () {\n    return this.policy.responseHeaders()\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders (request) {\n    const _req = requestObject(request)\n    return this.policy.revalidationHeaders(_req)\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated (request, response) {\n    const _req = requestObject(request)\n    const _res = responseObject(response)\n    const policy = this.policy.revalidatedPolicy(_req, _res)\n    return !policy.modified\n  }\n}\n\nmodule.exports = CachePolicy\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}