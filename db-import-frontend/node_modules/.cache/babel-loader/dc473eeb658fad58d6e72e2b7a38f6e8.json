{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar ValidPhaseNames = new Set([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nvar HttpPipeline = /*#__PURE__*/function () {\n  function HttpPipeline(policies) {\n    _classCallCheck(this, HttpPipeline);\n    var _a;\n    this._policies = [];\n    this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];\n    this._orderedPolicies = undefined;\n  }\n  _createClass(HttpPipeline, [{\n    key: \"addPolicy\",\n    value: function addPolicy(policy) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (options.phase && options.afterPhase) {\n        throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n      }\n      if (options.phase && !ValidPhaseNames.has(options.phase)) {\n        throw new Error(\"Invalid phase name: \".concat(options.phase));\n      }\n      if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n        throw new Error(\"Invalid afterPhase name: \".concat(options.afterPhase));\n      }\n      this._policies.push({\n        policy: policy,\n        options: options\n      });\n      this._orderedPolicies = undefined;\n    }\n  }, {\n    key: \"removePolicy\",\n    value: function removePolicy(options) {\n      var removedPolicies = [];\n      this._policies = this._policies.filter(function (policyDescriptor) {\n        if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {\n          removedPolicies.push(policyDescriptor.policy);\n          return false;\n        } else {\n          return true;\n        }\n      });\n      this._orderedPolicies = undefined;\n      return removedPolicies;\n    }\n  }, {\n    key: \"sendRequest\",\n    value: function sendRequest(httpClient, request) {\n      var policies = this.getOrderedPolicies();\n      var pipeline = policies.reduceRight(function (next, policy) {\n        return function (req) {\n          return policy.sendRequest(req, next);\n        };\n      }, function (req) {\n        return httpClient.sendRequest(req);\n      });\n      return pipeline(request);\n    }\n  }, {\n    key: \"getOrderedPolicies\",\n    value: function getOrderedPolicies() {\n      if (!this._orderedPolicies) {\n        this._orderedPolicies = this.orderPolicies();\n      }\n      return this._orderedPolicies;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new HttpPipeline(this._policies);\n    }\n  }, {\n    key: \"orderPolicies\",\n    value: function orderPolicies() {\n      /**\n       * The goal of this method is to reliably order pipeline policies\n       * based on their declared requirements when they were added.\n       *\n       * Order is first determined by phase:\n       *\n       * 1. Serialize Phase\n       * 2. Policies not in a phase\n       * 3. Deserialize Phase\n       * 4. Retry Phase\n       * 5. Sign Phase\n       *\n       * Within each phase, policies are executed in the order\n       * they were added unless they were specified to execute\n       * before/after other policies or after a particular phase.\n       *\n       * To determine the final order, we will walk the policy list\n       * in phase order multiple times until all dependencies are\n       * satisfied.\n       *\n       * `afterPolicies` are the set of policies that must be\n       * executed before a given policy. This requirement is\n       * considered satisfied when each of the listed policies\n       * have been scheduled.\n       *\n       * `beforePolicies` are the set of policies that must be\n       * executed after a given policy. Since this dependency\n       * can be expressed by converting it into a equivalent\n       * `afterPolicies` declarations, they are normalized\n       * into that form for simplicity.\n       *\n       * An `afterPhase` dependency is considered satisfied when all\n       * policies in that phase have scheduled.\n       *\n       */\n      var result = [];\n      // Track all policies we know about.\n      var policyMap = new Map();\n      function createPhase(name) {\n        return {\n          name: name,\n          policies: new Set(),\n          hasRun: false,\n          hasAfterPolicies: false\n        };\n      }\n      // Track policies for each phase.\n      var serializePhase = createPhase(\"Serialize\");\n      var noPhase = createPhase(\"None\");\n      var deserializePhase = createPhase(\"Deserialize\");\n      var retryPhase = createPhase(\"Retry\");\n      var signPhase = createPhase(\"Sign\");\n      // a list of phases in order\n      var orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n      // Small helper function to map phase name to each Phase\n      function getPhase(phase) {\n        if (phase === \"Retry\") {\n          return retryPhase;\n        } else if (phase === \"Serialize\") {\n          return serializePhase;\n        } else if (phase === \"Deserialize\") {\n          return deserializePhase;\n        } else if (phase === \"Sign\") {\n          return signPhase;\n        } else {\n          return noPhase;\n        }\n      }\n      // First walk each policy and create a node to track metadata.\n      var _iterator = _createForOfIteratorHelper(this._policies),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var descriptor = _step.value;\n          var policy = descriptor.policy;\n          var options = descriptor.options;\n          var policyName = policy.name;\n          if (policyMap.has(policyName)) {\n            throw new Error(\"Duplicate policy names not allowed in pipeline\");\n          }\n          var node = {\n            policy: policy,\n            dependsOn: new Set(),\n            dependants: new Set()\n          };\n          if (options.afterPhase) {\n            node.afterPhase = getPhase(options.afterPhase);\n            node.afterPhase.hasAfterPolicies = true;\n          }\n          policyMap.set(policyName, node);\n          var phase = getPhase(options.phase);\n          phase.policies.add(node);\n        }\n        // Now that each policy has a node, connect dependency references.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this._policies),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _descriptor = _step2.value;\n          var _policy = _descriptor.policy,\n            _options = _descriptor.options;\n          var _policyName = _policy.name;\n          var _node = policyMap.get(_policyName);\n          if (!_node) {\n            throw new Error(\"Missing node for policy \".concat(_policyName));\n          }\n          if (_options.afterPolicies) {\n            var _iterator6 = _createForOfIteratorHelper(_options.afterPolicies),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var afterPolicyName = _step6.value;\n                var afterNode = policyMap.get(afterPolicyName);\n                if (afterNode) {\n                  // Linking in both directions helps later\n                  // when we want to notify dependants.\n                  _node.dependsOn.add(afterNode);\n                  afterNode.dependants.add(_node);\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n          if (_options.beforePolicies) {\n            var _iterator7 = _createForOfIteratorHelper(_options.beforePolicies),\n              _step7;\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var beforePolicyName = _step7.value;\n                var beforeNode = policyMap.get(beforePolicyName);\n                if (beforeNode) {\n                  // To execute before another node, make it\n                  // depend on the current node.\n                  beforeNode.dependsOn.add(_node);\n                  _node.dependants.add(beforeNode);\n                }\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      function walkPhase(phase) {\n        phase.hasRun = true;\n        // Sets iterate in insertion order\n        var _iterator3 = _createForOfIteratorHelper(phase.policies),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var node = _step3.value;\n            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n              // If this node is waiting on a phase to complete,\n              // we need to skip it for now.\n              // Even if the phase is empty, we should wait for it\n              // to be walked to avoid re-ordering policies.\n              continue;\n            }\n            if (node.dependsOn.size === 0) {\n              // If there's nothing else we're waiting for, we can\n              // add this policy to the result list.\n              result.push(node.policy);\n              // Notify anything that depends on this policy that\n              // the policy has been scheduled.\n              var _iterator4 = _createForOfIteratorHelper(node.dependants),\n                _step4;\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var dependant = _step4.value;\n                  dependant.dependsOn.delete(node);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n              policyMap.delete(node.policy.name);\n              phase.policies.delete(node);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      function walkPhases() {\n        var _iterator5 = _createForOfIteratorHelper(orderedPhases),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var phase = _step5.value;\n            walkPhase(phase);\n            // if the phase isn't complete\n            if (phase.policies.size > 0 && phase !== noPhase) {\n              if (!noPhase.hasRun) {\n                // Try running noPhase to see if that unblocks this phase next tick.\n                // This can happen if a phase that happens before noPhase\n                // is waiting on a noPhase policy to complete.\n                walkPhase(noPhase);\n              }\n              // Don't proceed to the next phase until this phase finishes.\n              return;\n            }\n            if (phase.hasAfterPolicies) {\n              // Run any policies unblocked by this phase\n              walkPhase(noPhase);\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n      // Iterate until we've put every node in the result list.\n      var iteration = 0;\n      while (policyMap.size > 0) {\n        iteration++;\n        var initialResultLength = result.length;\n        // Keep walking each phase in order until we can order every node.\n        walkPhases();\n        // The result list *should* get at least one larger each time\n        // after the first full pass.\n        // Otherwise, we're going to loop forever.\n        if (result.length <= initialResultLength && iteration > 1) {\n          throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n        }\n      }\n      return result;\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      return new HttpPipeline();\n    }\n  }]);\n  return HttpPipeline;\n}();\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline() {\n  return HttpPipeline.create();\n}","map":{"version":3,"names":["ValidPhaseNames","Set","HttpPipeline","policies","_classCallCheck","_policies","_a","slice","_orderedPolicies","undefined","_createClass","key","value","addPolicy","policy","options","arguments","length","phase","afterPhase","Error","has","concat","push","removePolicy","removedPolicies","filter","policyDescriptor","name","sendRequest","httpClient","request","getOrderedPolicies","pipeline","reduceRight","next","req","orderPolicies","clone","result","policyMap","Map","createPhase","hasRun","hasAfterPolicies","serializePhase","noPhase","deserializePhase","retryPhase","signPhase","orderedPhases","getPhase","_iterator","_createForOfIteratorHelper","_step","s","n","done","descriptor","policyName","node","dependsOn","dependants","set","add","err","e","f","_iterator2","_step2","get","afterPolicies","_iterator6","_step6","afterPolicyName","afterNode","beforePolicies","_iterator7","_step7","beforePolicyName","beforeNode","walkPhase","_iterator3","_step3","size","_iterator4","_step4","dependant","delete","walkPhases","_iterator5","_step5","iteration","initialResultLength","create","createEmptyPipeline"],"sources":["../../src/pipeline.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpClient, PipelineRequest, PipelineResponse, SendRequest } from \"./interfaces\";\n\n/**\n * Policies are executed in phases.\n * The execution order is:\n * 1. Serialize Phase\n * 2. Policies not in a phase\n * 3. Deserialize Phase\n * 4. Retry Phase\n * 5. Sign Phase\n */\nexport type PipelinePhase = \"Deserialize\" | \"Serialize\" | \"Retry\" | \"Sign\";\n\nconst ValidPhaseNames = new Set<PipelinePhase>([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n\n/**\n * Options when adding a policy to the pipeline.\n * Used to express dependencies on other policies.\n */\nexport interface AddPolicyOptions {\n  /**\n   * Policies that this policy must come before.\n   */\n  beforePolicies?: string[];\n  /**\n   * Policies that this policy must come after.\n   */\n  afterPolicies?: string[];\n  /**\n   * The phase that this policy must come after.\n   */\n  afterPhase?: PipelinePhase;\n  /**\n   * The phase this policy belongs to.\n   */\n  phase?: PipelinePhase;\n}\n\n/**\n * A pipeline policy manipulates a request as it travels through the pipeline.\n * It is conceptually a middleware that is allowed to modify the request before\n * it is made as well as the response when it is received.\n */\nexport interface PipelinePolicy {\n  /**\n   * The policy name. Must be a unique string in the pipeline.\n   */\n  name: string;\n  /**\n   * The main method to implement that manipulates a request/response.\n   * @param request - The request being performed.\n   * @param next - The next policy in the pipeline. Must be called to continue the pipeline.\n   */\n  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;\n}\n\n/**\n * Represents a pipeline for making a HTTP request to a URL.\n * Pipelines can have multiple policies to manage manipulating each request\n * before and after it is made to the server.\n */\nexport interface Pipeline {\n  /**\n   * Add a new policy to the pipeline.\n   * @param policy - A policy that manipulates a request.\n   * @param options - A set of options for when the policy should run.\n   */\n  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;\n  /**\n   * Remove a policy from the pipeline.\n   * @param options - Options that let you specify which policies to remove.\n   */\n  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];\n  /**\n   * Uses the pipeline to make a HTTP request.\n   * @param httpClient - The HttpClient that actually performs the request.\n   * @param request - The request to be made.\n   */\n  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;\n  /**\n   * Returns the current set of policies in the pipeline in the order in which\n   * they will be applied to the request. Later in the list is closer to when\n   * the request is performed.\n   */\n  getOrderedPolicies(): PipelinePolicy[];\n  /**\n   * Duplicates this pipeline to allow for modifying an existing one without mutating it.\n   */\n  clone(): Pipeline;\n}\n\ninterface PipelineDescriptor {\n  policy: PipelinePolicy;\n  options: AddPolicyOptions;\n}\n\ninterface PolicyGraphNode {\n  policy: PipelinePolicy;\n  dependsOn: Set<PolicyGraphNode>;\n  dependants: Set<PolicyGraphNode>;\n  afterPhase?: Phase;\n}\n\ninterface Phase {\n  name: PipelinePhase | \"None\";\n  policies: Set<PolicyGraphNode>;\n  hasRun: boolean;\n  hasAfterPolicies: boolean;\n}\n\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline implements Pipeline {\n  private _policies: PipelineDescriptor[] = [];\n  private _orderedPolicies?: PipelinePolicy[];\n\n  private constructor(policies?: PipelineDescriptor[]) {\n    this._policies = policies?.slice(0) ?? [];\n    this._orderedPolicies = undefined;\n  }\n\n  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options,\n    });\n    this._orderedPolicies = undefined;\n  }\n\n  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {\n    const removedPolicies: PipelinePolicy[] = [];\n\n    this._policies = this._policies.filter((policyDescriptor) => {\n      if (\n        (options.name && policyDescriptor.policy.name === options.name) ||\n        (options.phase && policyDescriptor.options.phase === options.phase)\n      ) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n\n    return removedPolicies;\n  }\n\n  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {\n    const policies = this.getOrderedPolicies();\n\n    const pipeline = policies.reduceRight<SendRequest>(\n      (next, policy) => {\n        return (req: PipelineRequest) => {\n          return policy.sendRequest(req, next);\n        };\n      },\n      (req: PipelineRequest) => httpClient.sendRequest(req)\n    );\n\n    return pipeline(request);\n  }\n\n  public getOrderedPolicies(): PipelinePolicy[] {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n\n  public clone(): Pipeline {\n    return new HttpPipeline(this._policies);\n  }\n\n  public static create(): Pipeline {\n    return new HttpPipeline();\n  }\n\n  private orderPolicies(): PipelinePolicy[] {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result: PipelinePolicy[] = [];\n\n    // Track all policies we know about.\n    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();\n\n    function createPhase(name: PipelinePhase | \"None\"): Phase {\n      return {\n        name,\n        policies: new Set<PolicyGraphNode>(),\n        hasRun: false,\n        hasAfterPolicies: false,\n      };\n    }\n\n    // Track policies for each phase.\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\");\n\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n\n    // Small helper function to map phase name to each Phase\n    function getPhase(phase: PipelinePhase | undefined): Phase {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    }\n\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node: PolicyGraphNode = {\n        policy,\n        dependsOn: new Set<PolicyGraphNode>(),\n        dependants: new Set<PolicyGraphNode>(),\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    }\n\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const { policy, options } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase: Phase): void {\n      phase.hasRun = true;\n      // Sets iterate in insertion order\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n\n    function walkPhases(): void {\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        // if the phase isn't complete\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    }\n\n    // Iterate until we've put every node in the result list.\n    let iteration = 0;\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline(): Pipeline {\n  return HttpPipeline.create();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}