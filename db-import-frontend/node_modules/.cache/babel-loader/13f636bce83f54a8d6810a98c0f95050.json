{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _toConsumableArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nvar util = require(\"util\");\nvar _ = require(\"lodash\");\nvar uuidv4 = require(\"uuid\").v4;\nvar Utils = require(\"../../utils\");\nvar deprecations = require(\"../../utils/deprecations\");\nvar SqlString = require(\"../../sql-string\");\nvar DataTypes = require(\"../../data-types\");\nvar Model = require(\"../../model\");\nvar Association = require(\"../../associations/base\");\nvar BelongsTo = require(\"../../associations/belongs-to\");\nvar BelongsToMany = require(\"../../associations/belongs-to-many\");\nvar HasMany = require(\"../../associations/has-many\");\nvar Op = require(\"../../operators\");\nvar sequelizeError = require(\"../../errors\");\nvar IndexHints = require(\"../../index-hints\");\nvar QueryGenerator = /*#__PURE__*/function () {\n  function QueryGenerator(options) {\n    _classCallCheck(this, QueryGenerator);\n    if (!options.sequelize) throw new Error(\"QueryGenerator initialized without options.sequelize\");\n    if (!options._dialect) throw new Error(\"QueryGenerator initialized without options._dialect\");\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n    this._initQuoteIdentifier();\n  }\n  _createClass(QueryGenerator, [{\n    key: \"extractTableDetails\",\n    value: function extractTableDetails(tableName, options) {\n      options = options || {};\n      tableName = tableName || {};\n      return {\n        schema: tableName.schema || options.schema || this.options.schema || \"public\",\n        tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n        delimiter: tableName.delimiter || options.delimiter || \".\"\n      };\n    }\n  }, {\n    key: \"addSchema\",\n    value: function addSchema(param) {\n      if (!param._schema) return param.tableName || param;\n      var self = this;\n      return {\n        tableName: param.tableName || param,\n        table: param.tableName || param,\n        name: param.name || param,\n        schema: param._schema,\n        delimiter: param._schemaDelimiter || \".\",\n        toString: function toString() {\n          return self.quoteTable(this);\n        }\n      };\n    }\n  }, {\n    key: \"dropSchema\",\n    value: function dropSchema(tableName, options) {\n      return this.dropTableQuery(tableName, options);\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema, schemaDelimiter) {\n      var table = this.quoteTable(this.addSchema({\n        tableName: tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      }));\n      return \"DESCRIBE \".concat(table, \";\");\n    }\n  }, {\n    key: \"dropTableQuery\",\n    value: function dropTableQuery(tableName) {\n      return \"DROP TABLE IF EXISTS \".concat(this.quoteTable(tableName), \";\");\n    }\n  }, {\n    key: \"renameTableQuery\",\n    value: function renameTableQuery(before, after) {\n      return \"ALTER TABLE \".concat(this.quoteTable(before), \" RENAME TO \").concat(this.quoteTable(after), \";\");\n    }\n  }, {\n    key: \"populateInsertQueryReturnIntoBinds\",\n    value: function populateInsertQueryReturnIntoBinds() {}\n  }, {\n    key: \"insertQuery\",\n    value: function insertQuery(table, valueHash, modelAttributes, options) {\n      var _this = this;\n      options = options || {};\n      _.defaults(options, this.options);\n      var modelAttributeMap = {};\n      var bind = options.bind || [];\n      var fields = [];\n      var returningModelAttributes = [];\n      var returnTypes = [];\n      var values = [];\n      var quotedTable = this.quoteTable(table);\n      var bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n      var returnAttributes = [];\n      var query;\n      var valueQuery = \"\";\n      var emptyQuery = \"\";\n      var outputFragment = \"\";\n      var returningFragment = \"\";\n      var identityWrapperRequired = false;\n      var tmpTable = \"\";\n      if (modelAttributes) {\n        _.each(modelAttributes, function (attribute, key) {\n          modelAttributeMap[key] = attribute;\n          if (attribute.field) {\n            modelAttributeMap[attribute.field] = attribute;\n          }\n        });\n      }\n      if (this._dialect.supports[\"DEFAULT VALUES\"]) {\n        emptyQuery += \" DEFAULT VALUES\";\n      } else if (this._dialect.supports[\"VALUES ()\"]) {\n        emptyQuery += \" VALUES ()\";\n      }\n      if ((this._dialect.supports.returnValues || this._dialect.supports.returnIntoValues) && options.returning) {\n        var returnValues = this.generateReturnValues(modelAttributes, options);\n        returningModelAttributes.push.apply(returningModelAttributes, _toConsumableArray(returnValues.returnFields));\n        if (this._dialect.supports.returnIntoValues) {\n          returnTypes.push.apply(returnTypes, _toConsumableArray(returnValues.returnTypes));\n        }\n        returningFragment = returnValues.returningFragment;\n        tmpTable = returnValues.tmpTable || \"\";\n        outputFragment = returnValues.outputFragment || \"\";\n      }\n      if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n        options.bindParam = false;\n      }\n      if (this._dialect.supports.EXCEPTION && options.exception) {\n        options.bindParam = false;\n      }\n      valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n      for (var key in valueHash) {\n        if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n          var value = valueHash[key];\n          fields.push(this.quoteIdentifier(key));\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {\n            if (!this._dialect.supports.autoIncrement.defaultValue) {\n              fields.splice(-1, 1);\n            } else if (this._dialect.supports.DEFAULT) {\n              values.push(\"DEFAULT\");\n            } else {\n              values.push(this.escape(null));\n            }\n          } else {\n            if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n              identityWrapperRequired = true;\n            }\n            if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n              values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n                context: \"INSERT\"\n              }));\n            } else {\n              values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n                context: \"INSERT\"\n              }, bindParam));\n            }\n          }\n        }\n      }\n      var onDuplicateKeyUpdate = \"\";\n      if (!_.isEmpty(options.conflictWhere) && !this._dialect.supports.inserts.onConflictWhere) {\n        throw new Error(\"missing dialect support for conflictWhere option\");\n      }\n      if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n        if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n          var conflictKeys = options.upsertKeys.map(function (attr) {\n            return _this.quoteIdentifier(attr);\n          });\n          var updateKeys = options.updateOnDuplicate.map(function (attr) {\n            return \"\".concat(_this.quoteIdentifier(attr), \"=EXCLUDED.\").concat(_this.quoteIdentifier(attr));\n          });\n          var fragments = [\"ON CONFLICT\", \"(\", conflictKeys.join(\",\"), \")\"];\n          if (!_.isEmpty(options.conflictWhere)) {\n            fragments.push(this.whereQuery(options.conflictWhere, options));\n          }\n          if (_.isEmpty(updateKeys)) {\n            fragments.push(\"DO NOTHING\");\n          } else {\n            fragments.push(\"DO UPDATE SET\", updateKeys.join(\",\"));\n          }\n          onDuplicateKeyUpdate = \" \".concat(Utils.joinSQLFragments(fragments));\n        } else {\n          var valueKeys = options.updateOnDuplicate.map(function (attr) {\n            return \"\".concat(_this.quoteIdentifier(attr), \"=VALUES(\").concat(_this.quoteIdentifier(attr), \")\");\n          });\n          if (_.isEmpty(valueKeys) && options.upsertKeys) {\n            valueKeys.push.apply(valueKeys, _toConsumableArray(options.upsertKeys.map(function (attr) {\n              return \"\".concat(_this.quoteIdentifier(attr), \"=\").concat(_this.quoteIdentifier(attr));\n            })));\n          }\n          if (_.isEmpty(valueKeys)) {\n            throw new Error(\"No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.\");\n          }\n          onDuplicateKeyUpdate += \"\".concat(this._dialect.supports.inserts.updateOnDuplicate, \" \").concat(valueKeys.join(\",\"));\n        }\n      }\n      var replacements = {\n        ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\",\n        onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\",\n        attributes: fields.join(\",\"),\n        output: outputFragment,\n        values: values.join(\",\"),\n        tmpTable: tmpTable\n      };\n      valueQuery = \"\".concat(tmpTable, \"INSERT\").concat(replacements.ignoreDuplicates, \" INTO \").concat(quotedTable, \" (\").concat(replacements.attributes, \")\").concat(replacements.output, \" VALUES (\").concat(replacements.values, \")\").concat(onDuplicateKeyUpdate).concat(replacements.onConflictDoNothing).concat(valueQuery);\n      emptyQuery = \"\".concat(tmpTable, \"INSERT\").concat(replacements.ignoreDuplicates, \" INTO \").concat(quotedTable).concat(replacements.output).concat(onDuplicateKeyUpdate).concat(replacements.onConflictDoNothing).concat(emptyQuery);\n      if (this._dialect.supports.EXCEPTION && options.exception) {\n        var dropFunction = \"DROP FUNCTION IF EXISTS pg_temp.testfunc()\";\n        if (returningModelAttributes.length === 0) {\n          returningModelAttributes.push(\"*\");\n        }\n        var delimiter = \"$func_\".concat(uuidv4().replace(/-/g, \"\"), \"$\");\n        var selectQuery = \"SELECT (testfunc.response).\".concat(returningModelAttributes.join(\", (testfunc.response).\"), \", testfunc.sequelize_caught_exception FROM pg_temp.testfunc();\");\n        options.exception = \"WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;\";\n        valueQuery = \"CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response \".concat(quotedTable, \", OUT sequelize_caught_exception text) RETURNS RECORD AS \").concat(delimiter, \" BEGIN \").concat(valueQuery, \" RETURNING * INTO response; EXCEPTION \").concat(options.exception, \" END \").concat(delimiter, \" LANGUAGE plpgsql; \").concat(selectQuery, \" \").concat(dropFunction);\n      } else {\n        valueQuery += returningFragment;\n        emptyQuery += returningFragment;\n      }\n      if (this._dialect.supports.returnIntoValues && options.returning) {\n        this.populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, bind.length, returnAttributes, options);\n      }\n      query = \"\".concat(replacements.attributes.length ? valueQuery : emptyQuery).concat(returnAttributes.join(\",\"), \";\");\n      if (this._dialect.supports.finalTable) {\n        query = \"SELECT * FROM FINAL TABLE(\".concat(replacements.attributes.length ? valueQuery : emptyQuery, \");\");\n      }\n      if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n        query = \"SET IDENTITY_INSERT \".concat(quotedTable, \" ON; \").concat(query, \" SET IDENTITY_INSERT \").concat(quotedTable, \" OFF;\");\n      }\n      var result = {\n        query: query\n      };\n      if (options.bindParam !== false) {\n        result.bind = bind;\n      }\n      return result;\n    }\n  }, {\n    key: \"bulkInsertQuery\",\n    value: function bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n      var _this2 = this;\n      options = options || {};\n      fieldMappedAttributes = fieldMappedAttributes || {};\n      var tuples = [];\n      var serials = {};\n      var allAttributes = [];\n      var onDuplicateKeyUpdate = \"\";\n      var _iterator2 = _createForOfIteratorHelper(fieldValueHashes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var fieldValueHash = _step2.value;\n          _.forOwn(fieldValueHash, function (value, key) {\n            if (!allAttributes.includes(key)) {\n              allAttributes.push(key);\n            }\n            if (fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true) {\n              serials[key] = true;\n            }\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(fieldValueHashes),\n        _step3;\n      try {\n        var _loop = function _loop() {\n          var fieldValueHash = _step3.value;\n          var values = allAttributes.map(function (key) {\n            if (_this2._dialect.supports.bulkDefault && serials[key] === true) {\n              return fieldValueHash[key] != null ? fieldValueHash[key] : \"DEFAULT\";\n            }\n            return _this2.escape(fieldValueHash[key], fieldMappedAttributes[key], {\n              context: \"INSERT\"\n            });\n          });\n          tuples.push(\"(\".concat(values.join(\",\"), \")\"));\n        };\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n        if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n          var conflictKeys = options.upsertKeys.map(function (attr) {\n            return _this2.quoteIdentifier(attr);\n          });\n          var updateKeys = options.updateOnDuplicate.map(function (attr) {\n            return \"\".concat(_this2.quoteIdentifier(attr), \"=EXCLUDED.\").concat(_this2.quoteIdentifier(attr));\n          });\n          var whereClause = false;\n          if (options.conflictWhere) {\n            if (!this._dialect.supports.inserts.onConflictWhere) {\n              throw new Error(\"conflictWhere not supported for dialect \".concat(this._dialect.name));\n            }\n            whereClause = this.whereQuery(options.conflictWhere, options);\n          }\n          onDuplicateKeyUpdate = [\"ON CONFLICT\", \"(\", conflictKeys.join(\",\"), \")\", whereClause, \"DO UPDATE SET\", updateKeys.join(\",\")];\n        } else {\n          if (options.conflictWhere) {\n            throw new Error(\"conflictWhere not supported for dialect \".concat(this._dialect.name));\n          }\n          var valueKeys = options.updateOnDuplicate.map(function (attr) {\n            return \"\".concat(_this2.quoteIdentifier(attr), \"=VALUES(\").concat(_this2.quoteIdentifier(attr), \")\");\n          });\n          onDuplicateKeyUpdate = \"\".concat(this._dialect.supports.inserts.updateOnDuplicate, \" \").concat(valueKeys.join(\",\"));\n        }\n      }\n      var ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\";\n      var attributes = allAttributes.map(function (attr) {\n        return _this2.quoteIdentifier(attr);\n      }).join(\",\");\n      var onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\";\n      var returning = \"\";\n      if (this._dialect.supports.returnValues && options.returning) {\n        var returnValues = this.generateReturnValues(fieldMappedAttributes, options);\n        returning += returnValues.returningFragment;\n      }\n      return Utils.joinSQLFragments([\"INSERT\", ignoreDuplicates, \"INTO\", this.quoteTable(tableName), \"(\".concat(attributes, \")\"), \"VALUES\", tuples.join(\",\"), onDuplicateKeyUpdate, onConflictDoNothing, returning, \";\"]);\n    }\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery(tableName, attrValueHash, where, options, attributes) {\n      options = options || {};\n      _.defaults(options, this.options);\n      attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n      var values = [];\n      var bind = [];\n      var modelAttributeMap = {};\n      var outputFragment = \"\";\n      var tmpTable = \"\";\n      var suffix = \"\";\n      if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n        options.bindParam = false;\n      }\n      var bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n      if (this._dialect.supports[\"LIMIT ON UPDATE\"] && options.limit) {\n        if (![\"mssql\", \"db2\", \"oracle\"].includes(this.dialect)) {\n          suffix = \" LIMIT \".concat(this.escape(options.limit), \" \");\n        } else if (this.dialect === \"oracle\") {\n          if (where && (where.length && where.length > 0 || Object.keys(where).length > 0)) {\n            suffix += \" AND \";\n          } else {\n            suffix += \" WHERE \";\n          }\n          suffix += \"rownum <= \".concat(this.escape(options.limit), \" \");\n        }\n      }\n      if (this._dialect.supports.returnValues && options.returning) {\n        var returnValues = this.generateReturnValues(attributes, options);\n        suffix += returnValues.returningFragment;\n        tmpTable = returnValues.tmpTable || \"\";\n        outputFragment = returnValues.outputFragment || \"\";\n        if (!this._dialect.supports.returnValues.output && options.returning) {\n          options.mapToModel = true;\n        }\n      }\n      if (attributes) {\n        _.each(attributes, function (attribute, key) {\n          modelAttributeMap[key] = attribute;\n          if (attribute.field) {\n            modelAttributeMap[attribute.field] = attribute;\n          }\n        });\n      }\n      for (var key in attrValueHash) {\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !this._dialect.supports.autoIncrement.update) {\n          continue;\n        }\n        var value = attrValueHash[key];\n        if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n          values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n            context: \"UPDATE\"\n          })));\n        } else {\n          values.push(\"\".concat(this.quoteIdentifier(key), \"=\").concat(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n            context: \"UPDATE\"\n          }, bindParam)));\n        }\n      }\n      var whereOptions = __spreadProps(__spreadValues({}, options), {\n        bindParam: bindParam\n      });\n      if (values.length === 0) {\n        return \"\";\n      }\n      var query = \"\".concat(tmpTable, \"UPDATE \").concat(this.quoteTable(tableName), \" SET \").concat(values.join(\",\")).concat(outputFragment, \" \").concat(this.whereQuery(where, whereOptions)).concat(suffix).trim();\n      var result = {\n        query: query\n      };\n      if (options.bindParam !== false) {\n        result.bind = bind;\n      }\n      return result;\n    }\n  }, {\n    key: \"arithmeticQuery\",\n    value: function arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n      options = options || {};\n      _.defaults(options, {\n        returning: true\n      });\n      extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);\n      var outputFragment = \"\";\n      var returningFragment = \"\";\n      if (this._dialect.supports.returnValues && options.returning) {\n        var returnValues = this.generateReturnValues(null, options);\n        outputFragment = returnValues.outputFragment;\n        returningFragment = returnValues.returningFragment;\n      }\n      var updateSetSqlFragments = [];\n      for (var field in incrementAmountsByField) {\n        var incrementAmount = incrementAmountsByField[field];\n        var quotedField = this.quoteIdentifier(field);\n        var escapedAmount = this.escape(incrementAmount);\n        updateSetSqlFragments.push(\"\".concat(quotedField, \"=\").concat(quotedField).concat(operator, \" \").concat(escapedAmount));\n      }\n      for (var _field in extraAttributesToBeUpdated) {\n        var newValue = extraAttributesToBeUpdated[_field];\n        var _quotedField = this.quoteIdentifier(_field);\n        var escapedValue = this.escape(newValue);\n        updateSetSqlFragments.push(\"\".concat(_quotedField, \"=\").concat(escapedValue));\n      }\n      return Utils.joinSQLFragments([\"UPDATE\", this.quoteTable(tableName), \"SET\", updateSetSqlFragments.join(\",\"), outputFragment, this.whereQuery(where), returningFragment]);\n    }\n  }, {\n    key: \"addIndexQuery\",\n    value: function addIndexQuery(tableName, attributes, options, rawTablename) {\n      var _this3 = this;\n      options = options || {};\n      if (!Array.isArray(attributes)) {\n        options = attributes;\n        attributes = void 0;\n      } else {\n        options.fields = attributes;\n      }\n      options.prefix = options.prefix || rawTablename || tableName;\n      if (options.prefix && typeof options.prefix === \"string\") {\n        options.prefix = options.prefix.replace(/\\./g, \"_\");\n        options.prefix = options.prefix.replace(/(\"|')/g, \"\");\n      }\n      var fieldsSql = options.fields.map(function (field) {\n        if (field instanceof Utils.SequelizeMethod) {\n          return _this3.handleSequelizeMethod(field);\n        }\n        if (typeof field === \"string\") {\n          field = {\n            name: field\n          };\n        }\n        var result = \"\";\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n        if (!field.name) {\n          throw new Error(\"The following index field has no name: \".concat(util.inspect(field)));\n        }\n        result += _this3.quoteIdentifier(field.name);\n        if (_this3._dialect.supports.index.collate && field.collate) {\n          result += \" COLLATE \".concat(_this3.quoteIdentifier(field.collate));\n        }\n        if (_this3._dialect.supports.index.operator) {\n          var operator = field.operator || options.operator;\n          if (operator) {\n            result += \" \".concat(operator);\n          }\n        }\n        if (_this3._dialect.supports.index.length && field.length) {\n          result += \"(\".concat(field.length, \")\");\n        }\n        if (field.order) {\n          result += \" \".concat(field.order);\n        }\n        return result;\n      });\n      if (!options.name) {\n        options = Utils.nameIndex(options, options.prefix);\n      }\n      options = Model._conformIndex(options);\n      if (!this._dialect.supports.index.type) {\n        delete options.type;\n      }\n      if (options.where) {\n        options.where = this.whereQuery(options.where);\n      }\n      if (typeof tableName === \"string\") {\n        tableName = this.quoteIdentifiers(tableName);\n      } else {\n        tableName = this.quoteTable(tableName);\n      }\n      var concurrently = this._dialect.supports.index.concurrently && options.concurrently ? \"CONCURRENTLY\" : void 0;\n      var ind;\n      if (this._dialect.supports.indexViaAlter) {\n        ind = [\"ALTER TABLE\", tableName, concurrently, \"ADD\"];\n      } else {\n        ind = [\"CREATE\"];\n      }\n      ind = ind.concat(options.unique ? \"UNIQUE\" : \"\", options.type, \"INDEX\", !this._dialect.supports.indexViaAlter ? concurrently : void 0, this.quoteIdentifiers(options.name), this._dialect.supports.index.using === 1 && options.using ? \"USING \".concat(options.using) : \"\", !this._dialect.supports.indexViaAlter ? \"ON \".concat(tableName) : void 0, this._dialect.supports.index.using === 2 && options.using ? \"USING \".concat(options.using) : \"\", \"(\".concat(fieldsSql.join(\", \"), \")\"), this._dialect.supports.index.parser && options.parser ? \"WITH PARSER \".concat(options.parser) : void 0, this._dialect.supports.index.where && options.where ? options.where : void 0);\n      return _.compact(ind).join(\" \");\n    }\n  }, {\n    key: \"addConstraintQuery\",\n    value: function addConstraintQuery(tableName, options) {\n      if (typeof tableName === \"string\") {\n        tableName = this.quoteIdentifiers(tableName);\n      } else {\n        tableName = this.quoteTable(tableName);\n      }\n      return Utils.joinSQLFragments([\"ALTER TABLE\", tableName, \"ADD\", this.getConstraintSnippet(tableName, options || {}), \";\"]);\n    }\n  }, {\n    key: \"getConstraintSnippet\",\n    value: function getConstraintSnippet(tableName, options) {\n      var _this4 = this;\n      var constraintSnippet, constraintName;\n      var fieldsSql = options.fields.map(function (field) {\n        if (typeof field === \"string\") {\n          return _this4.quoteIdentifier(field);\n        }\n        if (field instanceof Utils.SequelizeMethod) {\n          return _this4.handleSequelizeMethod(field);\n        }\n        if (field.attribute) {\n          field.name = field.attribute;\n        }\n        if (!field.name) {\n          throw new Error(\"The following index field has no name: \".concat(field));\n        }\n        return _this4.quoteIdentifier(field.name);\n      });\n      var fieldsSqlQuotedString = fieldsSql.join(\", \");\n      var fieldsSqlString = fieldsSql.join(\"_\");\n      switch (options.type.toUpperCase()) {\n        case \"UNIQUE\":\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_uk\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" UNIQUE (\").concat(fieldsSqlQuotedString, \")\");\n          break;\n        case \"CHECK\":\n          options.where = this.whereItemsQuery(options.where);\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_ck\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" CHECK (\").concat(options.where, \")\");\n          break;\n        case \"DEFAULT\":\n          if (options.defaultValue === void 0) {\n            throw new Error(\"Default value must be specified for DEFAULT CONSTRAINT\");\n          }\n          if (this._dialect.name !== \"mssql\") {\n            throw new Error(\"Default constraints are supported only for MSSQL dialect.\");\n          }\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_df\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" DEFAULT (\").concat(this.escape(options.defaultValue), \") FOR \").concat(fieldsSql[0]);\n          break;\n        case \"PRIMARY KEY\":\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_pk\"));\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" PRIMARY KEY (\").concat(fieldsSqlQuotedString, \")\");\n          break;\n        case \"FOREIGN KEY\":\n          var references = options.references;\n          if (!references || !references.table || !(references.field || references.fields)) {\n            throw new Error(\"references object with table and field must be specified\");\n          }\n          constraintName = this.quoteIdentifier(options.name || \"\".concat(tableName, \"_\").concat(fieldsSqlString, \"_\").concat(references.table, \"_fk\"));\n          var quotedReferences = typeof references.field !== \"undefined\" ? this.quoteIdentifier(references.field) : references.fields.map(function (f) {\n            return _this4.quoteIdentifier(f);\n          }).join(\", \");\n          var referencesSnippet = \"\".concat(this.quoteTable(references.table), \" (\").concat(quotedReferences, \")\");\n          constraintSnippet = \"CONSTRAINT \".concat(constraintName, \" \");\n          constraintSnippet += \"FOREIGN KEY (\".concat(fieldsSqlQuotedString, \") REFERENCES \").concat(referencesSnippet);\n          if (options.onUpdate) {\n            constraintSnippet += \" ON UPDATE \".concat(options.onUpdate.toUpperCase());\n          }\n          if (options.onDelete) {\n            constraintSnippet += \" ON DELETE \".concat(options.onDelete.toUpperCase());\n          }\n          break;\n        default:\n          throw new Error(\"\".concat(options.type, \" is invalid.\"));\n      }\n      if (options.deferrable && [\"UNIQUE\", \"PRIMARY KEY\", \"FOREIGN KEY\"].includes(options.type.toUpperCase())) {\n        constraintSnippet += \" \".concat(this.deferConstraintsQuery(options));\n      }\n      return constraintSnippet;\n    }\n  }, {\n    key: \"removeConstraintQuery\",\n    value: function removeConstraintQuery(tableName, constraintName) {\n      if (typeof tableName === \"string\") {\n        tableName = this.quoteIdentifiers(tableName);\n      } else {\n        tableName = this.quoteTable(tableName);\n      }\n      return Utils.joinSQLFragments([\"ALTER TABLE\", tableName, \"DROP CONSTRAINT\", this.quoteIdentifiers(constraintName)]);\n    }\n  }, {\n    key: \"quote\",\n    value: function quote(collection, parent, connector) {\n      var _this5 = this;\n      var validOrderOptions = [\"ASC\", \"DESC\", \"ASC NULLS LAST\", \"DESC NULLS LAST\", \"ASC NULLS FIRST\", \"DESC NULLS FIRST\", \"NULLS FIRST\", \"NULLS LAST\"];\n      connector = connector || \".\";\n      if (typeof collection === \"string\") {\n        return this.quoteIdentifiers(collection);\n      }\n      if (Array.isArray(collection)) {\n        collection.forEach(function (item2, index) {\n          var previous = collection[index - 1];\n          var previousAssociation;\n          var previousModel;\n          if (!previous && parent !== void 0) {\n            previousModel = parent;\n          } else if (previous && previous instanceof Association) {\n            previousAssociation = previous;\n            previousModel = previous.target;\n          }\n          if (previousModel && previousModel.prototype instanceof Model) {\n            var model;\n            var as;\n            if (typeof item2 === \"function\" && item2.prototype instanceof Model) {\n              model = item2;\n            } else if (_.isPlainObject(item2) && item2.model && item2.model.prototype instanceof Model) {\n              model = item2.model;\n              as = item2.as;\n            }\n            if (model) {\n              if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n                item2 = new Association(previousModel, model, {\n                  as: model.name\n                });\n              } else {\n                item2 = previousModel.getAssociationForAlias(model, as);\n                if (!item2) {\n                  item2 = previousModel.getAssociationForAlias(model, model.name);\n                }\n              }\n              if (!(item2 instanceof Association)) {\n                throw new Error(util.format(\"Unable to find a valid association for model, '%s'\", model.name));\n              }\n            }\n          }\n          if (typeof item2 === \"string\") {\n            var orderIndex = validOrderOptions.indexOf(item2.toUpperCase());\n            if (index > 0 && orderIndex !== -1) {\n              item2 = _this5.sequelize.literal(\" \".concat(validOrderOptions[orderIndex]));\n            } else if (previousModel && previousModel.prototype instanceof Model) {\n              if (previousModel.associations !== void 0 && previousModel.associations[item2]) {\n                item2 = previousModel.associations[item2];\n              } else if (previousModel.rawAttributes !== void 0 && previousModel.rawAttributes[item2] && item2 !== previousModel.rawAttributes[item2].field) {\n                item2 = previousModel.rawAttributes[item2].field;\n              } else if (item2.includes(\".\") && previousModel.rawAttributes !== void 0) {\n                var itemSplit = item2.split(\".\");\n                if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                  var identifier = _this5.quoteIdentifiers(\"\".concat(previousModel.name, \".\").concat(previousModel.rawAttributes[itemSplit[0]].field));\n                  var path = itemSplit.slice(1);\n                  item2 = _this5.jsonPathExtractionQuery(identifier, path);\n                  item2 = _this5.sequelize.literal(item2);\n                }\n              }\n            }\n          }\n          collection[index] = item2;\n        }, this);\n        var collectionLength = collection.length;\n        var tableNames = [];\n        var item;\n        var i = 0;\n        for (i = 0; i < collectionLength - 1; i++) {\n          item = collection[i];\n          if (typeof item === \"string\" || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n            break;\n          } else if (item instanceof Association) {\n            tableNames[i] = item.as;\n          }\n        }\n        var sql = \"\";\n        if (i > 0) {\n          sql += \"\".concat(this.quoteIdentifier(tableNames.join(connector)), \".\");\n        } else if (typeof collection[0] === \"string\" && parent) {\n          sql += \"\".concat(this.quoteIdentifier(parent.name), \".\");\n        }\n        collection.slice(i).forEach(function (collectionItem) {\n          sql += _this5.quote(collectionItem, parent, connector);\n        }, this);\n        return sql;\n      }\n      if (collection._modelAttribute) {\n        return \"\".concat(this.quoteTable(collection.Model.name), \".\").concat(this.quoteIdentifier(collection.fieldName));\n      }\n      if (collection instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(collection);\n      }\n      if (_.isPlainObject(collection) && collection.raw) {\n        throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n      }\n      throw new Error(\"Unknown structure passed to order / group: \".concat(util.inspect(collection)));\n    }\n  }, {\n    key: \"_initQuoteIdentifier\",\n    value: function _initQuoteIdentifier() {\n      this._quoteIdentifier = this.quoteIdentifier;\n      this.quoteIdentifier = function (identifier, force) {\n        if (identifier === \"*\") return identifier;\n        return this._quoteIdentifier(identifier, force);\n      };\n    }\n  }, {\n    key: \"quoteIdentifier\",\n    value: function quoteIdentifier(identifier, force) {\n      throw new Error(\"quoteIdentifier for Dialect \\\"\".concat(this.dialect, \"\\\" is not implemented\"));\n    }\n  }, {\n    key: \"quoteIdentifiers\",\n    value: function quoteIdentifiers(identifiers) {\n      if (identifiers.includes(\".\")) {\n        identifiers = identifiers.split(\".\");\n        var head = identifiers.slice(0, identifiers.length - 1).join(\"->\");\n        var tail = identifiers[identifiers.length - 1];\n        return \"\".concat(this.quoteIdentifier(head), \".\").concat(this.quoteIdentifier(tail));\n      }\n      return this.quoteIdentifier(identifiers);\n    }\n  }, {\n    key: \"quoteAttribute\",\n    value: function quoteAttribute(attribute, model) {\n      if (model && attribute in model.rawAttributes) {\n        return this.quoteIdentifier(attribute);\n      }\n      return this.quoteIdentifiers(attribute);\n    }\n  }, {\n    key: \"getAliasToken\",\n    value: function getAliasToken() {\n      return \"AS\";\n    }\n  }, {\n    key: \"quoteTable\",\n    value: function quoteTable(param, alias) {\n      var table = \"\";\n      if (alias === true) {\n        alias = param.as || param.name || param;\n      }\n      if (_.isObject(param)) {\n        if (this._dialect.supports.schemas) {\n          if (param.schema) {\n            table += \"\".concat(this.quoteIdentifier(param.schema), \".\");\n          }\n          table += this.quoteIdentifier(param.tableName);\n        } else {\n          if (param.schema) {\n            table += param.schema + (param.delimiter || \".\");\n          }\n          table += param.tableName;\n          table = this.quoteIdentifier(table);\n        }\n      } else {\n        table = this.quoteIdentifier(param);\n      }\n      if (alias) {\n        table += \" \".concat(this.getAliasToken(), \" \").concat(this.quoteIdentifier(alias));\n      }\n      return table;\n    }\n  }, {\n    key: \"escape\",\n    value: function escape(value, field, options) {\n      var _this6 = this;\n      options = options || {};\n      if (value !== null && value !== void 0) {\n        if (value instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(value);\n        }\n        if (field && field.type) {\n          this.validate(value, field, options);\n          if (field.type.stringify) {\n            var simpleEscape = function simpleEscape(escVal) {\n              return SqlString.escape(escVal, _this6.options.timezone, _this6.dialect);\n            };\n            value = field.type.stringify(value, {\n              escape: simpleEscape,\n              field: field,\n              timezone: this.options.timezone,\n              operation: options.operation\n            });\n            if (field.type.escape === false) {\n              return value;\n            }\n          }\n        }\n      }\n      return SqlString.escape(value, this.options.timezone, this.dialect);\n    }\n  }, {\n    key: \"bindParam\",\n    value: function bindParam(bind) {\n      return function (value) {\n        bind.push(value);\n        return \"$\".concat(bind.length);\n      };\n    }\n  }, {\n    key: \"format\",\n    value: function format(value, field, options, bindParam) {\n      options = options || {};\n      if (value !== null && value !== void 0) {\n        if (value instanceof Utils.SequelizeMethod) {\n          throw new Error(\"Cannot pass SequelizeMethod as a bind parameter - use escape instead\");\n        }\n        if (field && field.type) {\n          this.validate(value, field, options);\n          if (field.type.bindParam) {\n            return field.type.bindParam(value, {\n              escape: _.identity,\n              field: field,\n              timezone: this.options.timezone,\n              operation: options.operation,\n              bindParam: bindParam\n            });\n          }\n        }\n      }\n      return bindParam(value);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(value, field, options) {\n      if (this.typeValidation && field.type.validate && value) {\n        try {\n          if (options.isList && Array.isArray(value)) {\n            var _iterator4 = _createForOfIteratorHelper(value),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var item = _step4.value;\n                field.type.validate(item, options);\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          } else {\n            field.type.validate(value, options);\n          }\n        } catch (error) {\n          if (error instanceof sequelizeError.ValidationError) {\n            error.errors.push(new sequelizeError.ValidationErrorItem(error.message, \"Validation error\", field.fieldName, value, null, \"\".concat(field.type.key, \" validator\")));\n          }\n          throw error;\n        }\n      }\n    }\n  }, {\n    key: \"isIdentifierQuoted\",\n    value: function isIdentifierQuoted(identifier) {\n      return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n    }\n  }, {\n    key: \"jsonPathExtractionQuery\",\n    value: function jsonPathExtractionQuery(column, path, isJson) {\n      var paths = _.toPath(path);\n      var pathStr;\n      var quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n      switch (this.dialect) {\n        case \"mysql\":\n        case \"mariadb\":\n        case \"sqlite\":\n          if (this.dialect === \"mysql\") {\n            paths = paths.map(function (subPath) {\n              return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n            });\n          }\n          pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, function (__, digit) {\n            return \"[\".concat(digit, \"]\");\n          }));\n          if (this.dialect === \"sqlite\") {\n            return \"json_extract(\".concat(quotedColumn, \",\").concat(pathStr, \")\");\n          }\n          return \"json_unquote(json_extract(\".concat(quotedColumn, \",\").concat(pathStr, \"))\");\n        case \"postgres\":\n          var join = isJson ? \"#>\" : \"#>>\";\n          pathStr = this.escape(\"{\".concat(paths.join(\",\"), \"}\"));\n          return \"(\".concat(quotedColumn).concat(join).concat(pathStr, \")\");\n        default:\n          throw new Error(\"Unsupported \".concat(this.dialect, \" for JSON operations\"));\n      }\n    }\n  }, {\n    key: \"selectQuery\",\n    value: function selectQuery(tableName, options, model) {\n      var _this7 = this;\n      options = options || {};\n      var limit = options.limit;\n      var mainQueryItems = [];\n      var subQueryItems = [];\n      var subQuery = options.subQuery === void 0 ? limit && options.hasMultiAssociation : options.subQuery;\n      var attributes = {\n        main: options.attributes && options.attributes.slice(),\n        subQuery: null\n      };\n      var mainTable = {\n        name: tableName,\n        quotedName: null,\n        as: null,\n        model: model\n      };\n      var topLevelInfo = {\n        names: mainTable,\n        options: options,\n        subQuery: subQuery\n      };\n      var mainJoinQueries = [];\n      var subJoinQueries = [];\n      var query;\n      if (this.options.minifyAliases && !options.aliasesMapping) {\n        options.aliasesMapping = /* @__PURE__ */new Map();\n        options.aliasesByTable = {};\n        options.includeAliases = /* @__PURE__ */new Map();\n      }\n      if (options.tableAs) {\n        mainTable.as = this.quoteIdentifier(options.tableAs);\n      } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n        mainTable.as = this.quoteIdentifier(mainTable.model.name);\n      }\n      mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(function (t) {\n        return Array.isArray(t) ? _this7.quoteTable(t[0], t[1]) : _this7.quoteTable(t, true);\n      }).join(\", \");\n      if (subQuery && attributes.main) {\n        var _iterator5 = _createForOfIteratorHelper(mainTable.model.primaryKeyAttributes),\n          _step5;\n        try {\n          var _loop2 = function _loop2() {\n            var keyAtt = _step5.value;\n            if (!attributes.main.some(function (attr) {\n              return keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1];\n            })) {\n              attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n            }\n          };\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            _loop2();\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n      attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n      attributes.main = attributes.main || (options.include ? [\"\".concat(mainTable.as, \".*\")] : [\"*\"]);\n      if (subQuery || options.groupedLimit) {\n        attributes.subQuery = attributes.main;\n        attributes.main = [\"\".concat(mainTable.as || mainTable.quotedName, \".*\")];\n      }\n      if (options.include) {\n        var _iterator6 = _createForOfIteratorHelper(options.include),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var include = _step6.value;\n            if (include.separate) {\n              continue;\n            }\n            var joinQueries = this.generateInclude(include, {\n              externalAs: mainTable.as,\n              internalAs: mainTable.as\n            }, topLevelInfo);\n            subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n            mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n            if (joinQueries.attributes.main.length > 0) {\n              attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n            }\n            if (joinQueries.attributes.subQuery.length > 0) {\n              attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n      if (subQuery) {\n        subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n        subQueryItems.push(subJoinQueries.join(\"\"));\n      } else {\n        if (options.groupedLimit) {\n          if (!mainTable.as) {\n            mainTable.as = mainTable.quotedName;\n          }\n          var where = __spreadValues({}, options.where);\n          var groupedLimitOrder,\n            whereKey,\n            _include,\n            groupedTableName = mainTable.as;\n          if (typeof options.groupedLimit.on === \"string\") {\n            whereKey = options.groupedLimit.on;\n          } else if (options.groupedLimit.on instanceof HasMany) {\n            whereKey = options.groupedLimit.on.foreignKeyField;\n          }\n          if (options.groupedLimit.on instanceof BelongsToMany) {\n            groupedTableName = options.groupedLimit.on.manyFromSource.as;\n            var groupedLimitOptions = Model._validateIncludedElements({\n              include: [{\n                association: options.groupedLimit.on.manyFromSource,\n                duplicating: false,\n                required: true,\n                where: __spreadValues(_defineProperty({}, Op.placeholder, true), options.groupedLimit.through && options.groupedLimit.through.where)\n              }],\n              model: model\n            });\n            options.hasJoin = true;\n            options.hasMultiAssociation = true;\n            options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n            options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n            _include = groupedLimitOptions.include;\n            if (Array.isArray(options.order)) {\n              options.order.forEach(function (order, i) {\n                if (Array.isArray(order)) {\n                  order = order[0];\n                }\n                var alias = \"subquery_order_\".concat(i);\n                options.attributes.push([order, alias]);\n                alias = _this7.sequelize.literal(_this7.quote(alias));\n                if (Array.isArray(options.order[i])) {\n                  options.order[i][0] = alias;\n                } else {\n                  options.order[i] = alias;\n                }\n              });\n              groupedLimitOrder = options.order;\n            }\n          } else {\n            groupedLimitOrder = options.order;\n            if (!this._dialect.supports.topLevelOrderByRequired) {\n              delete options.order;\n            }\n            where[Op.placeholder] = true;\n          }\n          var baseQuery = \"SELECT * FROM (\".concat(this.selectQuery(tableName, {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            aliasesMapping: options.aliasesMapping,\n            aliasesByTable: options.aliasesByTable,\n            where: where,\n            include: _include,\n            model: model\n          }, model).replace(/;$/, \"\"), \") \").concat(this.getAliasToken(), \" sub\");\n          var placeHolder = this.whereItemQuery(Op.placeholder, true, {\n            model: model\n          });\n          var splicePos = baseQuery.indexOf(placeHolder);\n          mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, \"(\".concat(options.groupedLimit.values.map(function (value) {\n            var groupWhere;\n            if (whereKey) {\n              groupWhere = _defineProperty({}, whereKey, value);\n            }\n            if (_include) {\n              groupWhere = _defineProperty({}, options.groupedLimit.on.foreignIdentifierField, value);\n            }\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, _this7.getWhereConditions(groupWhere, groupedTableName));\n          }).join(this._dialect.supports[\"UNION ALL\"] ? \" UNION ALL \" : \" UNION \"), \")\"), mainTable.as));\n        } else {\n          mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n        }\n        mainQueryItems.push(mainJoinQueries.join(\"\"));\n      }\n      if (Object.prototype.hasOwnProperty.call(options, \"where\") && !options.groupedLimit) {\n        options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n        if (options.where) {\n          if (subQuery) {\n            subQueryItems.push(\" WHERE \".concat(options.where));\n          } else {\n            mainQueryItems.push(\" WHERE \".concat(options.where));\n            mainQueryItems.forEach(function (value, key) {\n              if (value.startsWith(\"SELECT\")) {\n                mainQueryItems[key] = _this7.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n              }\n            });\n          }\n        }\n      }\n      if (options.group) {\n        options.group = Array.isArray(options.group) ? options.group.map(function (t) {\n          return _this7.aliasGrouping(t, model, mainTable.as, options);\n        }).join(\", \") : this.aliasGrouping(options.group, model, mainTable.as, options);\n        if (subQuery && options.group) {\n          subQueryItems.push(\" GROUP BY \".concat(options.group));\n        } else if (options.group) {\n          mainQueryItems.push(\" GROUP BY \".concat(options.group));\n        }\n      }\n      if (Object.prototype.hasOwnProperty.call(options, \"having\")) {\n        options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n        if (options.having) {\n          if (subQuery) {\n            subQueryItems.push(\" HAVING \".concat(options.having));\n          } else {\n            mainQueryItems.push(\" HAVING \".concat(options.having));\n          }\n        }\n      }\n      if (options.order) {\n        var orders = this.getQueryOrders(options, model, subQuery);\n        if (orders.mainQueryOrder.length) {\n          mainQueryItems.push(\" ORDER BY \".concat(orders.mainQueryOrder.join(\", \")));\n        }\n        if (orders.subQueryOrder.length) {\n          subQueryItems.push(\" ORDER BY \".concat(orders.subQueryOrder.join(\", \")));\n        }\n      }\n      var limitOrder = this.addLimitAndOffset(options, mainTable.model);\n      if (limitOrder && !options.groupedLimit) {\n        if (subQuery) {\n          subQueryItems.push(limitOrder);\n        } else {\n          mainQueryItems.push(limitOrder);\n        }\n      }\n      if (subQuery) {\n        this._throwOnEmptyAttributes(attributes.main, {\n          modelName: model && model.name,\n          as: mainTable.as\n        });\n        query = \"SELECT \".concat(attributes.main.join(\", \"), \" FROM (\").concat(subQueryItems.join(\"\"), \") \").concat(this.getAliasToken(), \" \").concat(mainTable.as).concat(mainJoinQueries.join(\"\")).concat(mainQueryItems.join(\"\"));\n      } else {\n        query = mainQueryItems.join(\"\");\n      }\n      if (options.lock && this._dialect.supports.lock) {\n        var lock = options.lock;\n        if (typeof options.lock === \"object\") {\n          lock = options.lock.level;\n        }\n        if (this._dialect.supports.lockKey && [\"KEY SHARE\", \"NO KEY UPDATE\"].includes(lock)) {\n          query += \" FOR \".concat(lock);\n        } else if (lock === \"SHARE\") {\n          query += \" \".concat(this._dialect.supports.forShare);\n        } else {\n          query += \" FOR UPDATE\";\n        }\n        if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n          query += \" OF \".concat(this.quoteTable(options.lock.of.name));\n        }\n        if (this._dialect.supports.skipLocked && options.skipLocked) {\n          query += \" SKIP LOCKED\";\n        }\n      }\n      return \"\".concat(query, \";\");\n    }\n  }, {\n    key: \"aliasGrouping\",\n    value: function aliasGrouping(field, model, tableName, options) {\n      var src = Array.isArray(field) ? field[0] : field;\n      return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n    }\n  }, {\n    key: \"escapeAttributes\",\n    value: function escapeAttributes(attributes, options, mainTableAs) {\n      var _this8 = this;\n      return attributes && attributes.map(function (attr) {\n        var addTable = true;\n        if (attr instanceof Utils.SequelizeMethod) {\n          return _this8.handleSequelizeMethod(attr);\n        }\n        if (Array.isArray(attr)) {\n          if (attr.length !== 2) {\n            throw new Error(\"\".concat(JSON.stringify(attr), \" is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']\"));\n          }\n          attr = attr.slice();\n          if (attr[0] instanceof Utils.SequelizeMethod) {\n            attr[0] = _this8.handleSequelizeMethod(attr[0]);\n            addTable = false;\n          } else if (_this8.options.attributeBehavior === \"escape\" || !attr[0].includes(\"(\") && !attr[0].includes(\")\")) {\n            attr[0] = _this8.quoteIdentifier(attr[0]);\n          } else if (_this8.options.attributeBehavior !== \"unsafe-legacy\") {\n            throw new Error(\"Attributes cannot include parentheses in Sequelize 6:\\nIn order to fix the vulnerability CVE-2023-22578, we had to remove support for treating attributes as raw SQL if they included parentheses.\\nSequelize 7 escapes all attributes, even if they include parentheses.\\nFor Sequelize 6, because we're introducing this change in a minor release, we've opted for throwing an error instead of silently escaping the attribute as a way to warn you about this change.\\n\\nHere is what you can do to fix this error:\\n- Wrap the attribute in a literal() call. This will make Sequelize treat it as raw SQL.\\n- Set the \\\"attributeBehavior\\\" sequelize option to \\\"escape\\\" to make Sequelize escape the attribute, like in Sequelize v7. We highly recommend this option.\\n- Set the \\\"attributeBehavior\\\" sequelize option to \\\"unsafe-legacy\\\" to make Sequelize escape the attribute, like in Sequelize v5.\\n\\nWe sincerely apologize for the inconvenience this may cause you. You can find more information on the following threads:\\nhttps://github.com/sequelize/sequelize/security/advisories/GHSA-f598-mfpv-gmfx\\nhttps://github.com/sequelize/sequelize/discussions/15694\");\n          }\n          var alias = attr[1];\n          if (_this8.options.minifyAliases) {\n            alias = _this8._getMinifiedAlias(alias, mainTableAs, options);\n          }\n          attr = [attr[0], _this8.quoteIdentifier(alias)].join(\" AS \");\n        } else {\n          attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"') ? _this8.quoteAttribute(attr, options.model) : _this8.escape(attr);\n        }\n        if (!_.isEmpty(options.include) && (!attr.includes(\".\") || options.dotNotation) && addTable) {\n          attr = \"\".concat(mainTableAs, \".\").concat(attr);\n        }\n        return attr;\n      });\n    }\n  }, {\n    key: \"generateInclude\",\n    value: function generateInclude(include, parentTableName, topLevelInfo) {\n      var _this9 = this;\n      var joinQueries = {\n        mainQuery: [],\n        subQuery: []\n      };\n      var mainChildIncludes = [];\n      var subChildIncludes = [];\n      var requiredMismatch = false;\n      var includeAs = {\n        internalAs: include.as,\n        externalAs: include.as\n      };\n      var attributes = {\n        main: [],\n        subQuery: []\n      };\n      var joinQuery;\n      topLevelInfo.options.keysEscaped = true;\n      if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n        includeAs.internalAs = \"\".concat(parentTableName.internalAs, \"->\").concat(include.as);\n        includeAs.externalAs = \"\".concat(parentTableName.externalAs, \".\").concat(include.as);\n      }\n      if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n        include.model._expandAttributes(include);\n        Utils.mapFinderOptions(include, include.model);\n        var includeAttributes = include.attributes.map(function (attr) {\n          var attrAs = attr;\n          var verbatim = false;\n          if (Array.isArray(attr) && attr.length === 2) {\n            if (attr[0] instanceof Utils.SequelizeMethod && (attr[0] instanceof Utils.Literal || attr[0] instanceof Utils.Cast || attr[0] instanceof Utils.Fn)) {\n              verbatim = true;\n            }\n            attr = attr.map(function (attr2) {\n              return attr2 instanceof Utils.SequelizeMethod ? _this9.handleSequelizeMethod(attr2) : attr2;\n            });\n            attrAs = attr[1];\n            attr = attr[0];\n          }\n          if (attr instanceof Utils.Literal) {\n            return attr.val;\n          }\n          if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n            throw new Error(\"Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. This means the attribute will not be added to the returned instance\");\n          }\n          var prefix;\n          if (verbatim === true) {\n            prefix = attr;\n          } else if (/#>>|->>/.test(attr)) {\n            prefix = \"(\".concat(_this9.quoteIdentifier(includeAs.internalAs), \".\").concat(attr.replace(/\\(|\\)/g, \"\"), \")\");\n          } else if (/json_extract\\(/.test(attr)) {\n            prefix = attr.replace(/json_extract\\(/i, \"json_extract(\".concat(_this9.quoteIdentifier(includeAs.internalAs), \".\"));\n          } else if (/json_value\\(/.test(attr)) {\n            prefix = attr.replace(/json_value\\(/i, \"json_value(\".concat(_this9.quoteIdentifier(includeAs.internalAs), \".\"));\n          } else {\n            prefix = \"\".concat(_this9.quoteIdentifier(includeAs.internalAs), \".\").concat(_this9.quoteIdentifier(attr));\n          }\n          var alias = \"\".concat(includeAs.externalAs, \".\").concat(attrAs);\n          if (_this9.options.minifyAliases) {\n            alias = _this9._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n          }\n          return Utils.joinSQLFragments([prefix, \"AS\", _this9.quoteIdentifier(alias, true)]);\n        });\n        if (include.subQuery && topLevelInfo.subQuery) {\n          var _iterator7 = _createForOfIteratorHelper(includeAttributes),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var attr = _step7.value;\n              attributes.subQuery.push(attr);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        } else {\n          var _iterator8 = _createForOfIteratorHelper(includeAttributes),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _attr = _step8.value;\n              attributes.main.push(_attr);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      }\n      if (include.through) {\n        joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n      } else {\n        this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n        joinQuery = this.generateJoin(include, topLevelInfo);\n      }\n      if (joinQuery.attributes.main.length > 0) {\n        attributes.main = attributes.main.concat(joinQuery.attributes.main);\n      }\n      if (joinQuery.attributes.subQuery.length > 0) {\n        attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n      }\n      if (include.include) {\n        var _iterator9 = _createForOfIteratorHelper(include.include),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var childInclude = _step9.value;\n            if (childInclude.separate || childInclude._pseudo) {\n              continue;\n            }\n            var childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n            if (include.required === false && childInclude.required === true) {\n              requiredMismatch = true;\n            }\n            if (childInclude.subQuery && topLevelInfo.subQuery) {\n              subChildIncludes.push(childJoinQueries.subQuery);\n            }\n            if (childJoinQueries.mainQuery) {\n              mainChildIncludes.push(childJoinQueries.mainQuery);\n            }\n            if (childJoinQueries.attributes.main.length > 0) {\n              attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n            }\n            if (childJoinQueries.attributes.subQuery.length > 0) {\n              attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n      if (include.subQuery && topLevelInfo.subQuery) {\n        if (requiredMismatch && subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(\" \".concat(joinQuery.join, \" ( \").concat(joinQuery.body).concat(subChildIncludes.join(\"\"), \" ) ON \").concat(joinQuery.condition));\n        } else {\n          joinQueries.subQuery.push(\" \".concat(joinQuery.join, \" \").concat(joinQuery.body, \" ON \").concat(joinQuery.condition));\n          if (subChildIncludes.length > 0) {\n            joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n          }\n        }\n        joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n      } else {\n        if (requiredMismatch && mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(\" \".concat(joinQuery.join, \" ( \").concat(joinQuery.body).concat(mainChildIncludes.join(\"\"), \" ) ON \").concat(joinQuery.condition));\n        } else {\n          joinQueries.mainQuery.push(\" \".concat(joinQuery.join, \" \").concat(joinQuery.body, \" ON \").concat(joinQuery.condition));\n          if (mainChildIncludes.length > 0) {\n            joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n          }\n        }\n        joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n      }\n      return {\n        mainQuery: joinQueries.mainQuery.join(\"\"),\n        subQuery: joinQueries.subQuery.join(\"\"),\n        attributes: attributes\n      };\n    }\n  }, {\n    key: \"_getMinifiedAlias\",\n    value: function _getMinifiedAlias(alias, tableName, options) {\n      if (options.aliasesByTable[\"\".concat(tableName).concat(alias)]) {\n        return options.aliasesByTable[\"\".concat(tableName).concat(alias)];\n      }\n      if (alias.match(/subquery_order_[0-9]/)) {\n        return alias;\n      }\n      var minifiedAlias = \"_\".concat(options.aliasesMapping.size);\n      options.aliasesMapping.set(minifiedAlias, alias);\n      options.aliasesByTable[\"\".concat(tableName).concat(alias)] = minifiedAlias;\n      return minifiedAlias;\n    }\n  }, {\n    key: \"_getAliasForField\",\n    value: function _getAliasForField(tableName, field, options) {\n      if (this.options.minifyAliases) {\n        if (options.aliasesByTable[\"\".concat(tableName).concat(field)]) {\n          return options.aliasesByTable[\"\".concat(tableName).concat(field)];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"generateJoin\",\n    value: function generateJoin(include, topLevelInfo) {\n      var association = include.association;\n      var parent = include.parent;\n      var parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n      var $parent;\n      var joinWhere;\n      var left = association.source;\n      var attrLeft = association instanceof BelongsTo ? association.identifier : association.sourceKeyAttribute || left.primaryKeyAttribute;\n      var fieldLeft = association instanceof BelongsTo ? association.identifierField : left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n      var asLeft;\n      var right = include.model;\n      var tableRight = right.getTableName();\n      var fieldRight = association instanceof BelongsTo ? right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field : association.identifierField;\n      var asRight = include.as;\n      while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n        if (asLeft) {\n          asLeft = \"\".concat($parent.as, \"->\").concat(asLeft);\n        } else {\n          asLeft = $parent.as;\n        }\n      }\n      if (!asLeft) asLeft = parent.as || parent.model.name;else asRight = \"\".concat(asLeft, \"->\").concat(asRight);\n      var joinOn = \"\".concat(this.quoteTable(asLeft), \".\").concat(this.quoteIdentifier(fieldLeft));\n      var subqueryAttributes = [];\n      if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n        if (parentIsTop) {\n          var tableName = this.quoteTable(parent.as || parent.model.name);\n          joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || \"\".concat(tableName, \".\").concat(this.quoteIdentifier(attrLeft));\n          if (topLevelInfo.subQuery) {\n            var dbIdentifier = \"\".concat(tableName, \".\").concat(this.quoteIdentifier(fieldLeft));\n            subqueryAttributes.push(dbIdentifier !== joinOn ? \"\".concat(dbIdentifier, \" AS \").concat(this.quoteIdentifier(attrLeft)) : dbIdentifier);\n          }\n        } else {\n          var joinSource = \"\".concat(asLeft.replace(/->/g, \".\"), \".\").concat(attrLeft);\n          joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n        }\n      }\n      joinOn += \" = \".concat(this.quoteIdentifier(asRight), \".\").concat(this.quoteIdentifier(fieldRight));\n      if (include.on) {\n        joinOn = this.whereItemsQuery(include.on, {\n          prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n          model: include.model\n        });\n      }\n      if (include.where) {\n        joinWhere = this.whereItemsQuery(include.where, {\n          prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n          model: include.model\n        });\n        if (joinWhere) {\n          if (include.or) {\n            joinOn += \" OR \".concat(joinWhere);\n          } else {\n            joinOn += \" AND \".concat(joinWhere);\n          }\n        }\n      }\n      this.aliasAs(asRight, topLevelInfo);\n      return {\n        join: include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\",\n        body: this.quoteTable(tableRight, asRight),\n        condition: joinOn,\n        attributes: {\n          main: [],\n          subQuery: subqueryAttributes\n        }\n      };\n    }\n  }, {\n    key: \"generateReturnValues\",\n    value: function generateReturnValues(modelAttributes, options) {\n      var _this10 = this;\n      var returnFields = [];\n      var returnTypes = [];\n      var outputFragment = \"\";\n      var returningFragment = \"\";\n      var tmpTable = \"\";\n      if (Array.isArray(options.returning)) {\n        returnFields.push.apply(returnFields, _toConsumableArray(options.returning.map(function (field) {\n          return _this10.quoteIdentifier(field);\n        })));\n      } else if (modelAttributes) {\n        _.each(modelAttributes, function (attribute) {\n          if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n            returnFields.push(_this10.quoteIdentifier(attribute.field));\n            returnTypes.push(attribute.type);\n          }\n        });\n      }\n      if (_.isEmpty(returnFields)) {\n        returnFields.push(\"*\");\n      }\n      if (this._dialect.supports.returnValues.returning) {\n        returningFragment = \" RETURNING \".concat(returnFields.join(\",\"));\n      } else if (this._dialect.supports.returnIntoValues) {\n        returningFragment = \" RETURNING \".concat(returnFields.join(\",\"), \" INTO \");\n      } else if (this._dialect.supports.returnValues.output) {\n        outputFragment = \" OUTPUT \".concat(returnFields.map(function (field) {\n          return \"INSERTED.\".concat(field);\n        }).join(\",\"));\n        if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n          var tmpColumns = returnFields.map(function (field, i) {\n            return \"\".concat(field, \" \").concat(returnTypes[i].toSql());\n          });\n          tmpTable = \"DECLARE @tmp TABLE (\".concat(tmpColumns.join(\",\"), \"); \");\n          outputFragment += \" INTO @tmp\";\n          returningFragment = \"; SELECT * FROM @tmp\";\n        }\n      }\n      return {\n        outputFragment: outputFragment,\n        returnFields: returnFields,\n        returnTypes: returnTypes,\n        returningFragment: returningFragment,\n        tmpTable: tmpTable\n      };\n    }\n  }, {\n    key: \"generateThroughJoin\",\n    value: function generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n      var _this11 = this;\n      var through = include.through;\n      var throughTable = through.model.getTableName();\n      var throughAs = \"\".concat(includeAs.internalAs, \"->\").concat(through.as);\n      var externalThroughAs = \"\".concat(includeAs.externalAs, \".\").concat(through.as);\n      var throughAttributes = through.attributes.map(function (attr) {\n        var alias = \"\".concat(externalThroughAs, \".\").concat(Array.isArray(attr) ? attr[1] : attr);\n        if (_this11.options.minifyAliases) {\n          alias = _this11._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n        }\n        return Utils.joinSQLFragments([\"\".concat(_this11.quoteIdentifier(throughAs), \".\").concat(_this11.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)), \"AS\", _this11.quoteIdentifier(alias)]);\n      });\n      var association = include.association;\n      var parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n      var tableSource = parentTableName;\n      var identSource = association.identifierField;\n      var tableTarget = includeAs.internalAs;\n      var identTarget = association.foreignIdentifierField;\n      var attrTarget = association.targetKeyField;\n      var joinType = include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\";\n      var joinBody;\n      var joinCondition;\n      var attributes = {\n        main: [],\n        subQuery: []\n      };\n      var attrSource = association.sourceKey;\n      var sourceJoinOn;\n      var targetJoinOn;\n      var throughWhere;\n      var targetWhere;\n      if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n        var _iterator10 = _createForOfIteratorHelper(throughAttributes),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var attr = _step10.value;\n            attributes.main.push(attr);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n      if (!topLevelInfo.subQuery) {\n        attrSource = association.sourceKeyField;\n      }\n      if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n        attrSource = association.sourceKeyField;\n      }\n      if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n        var joinSource = this._getAliasForField(tableSource, \"\".concat(tableSource, \".\").concat(attrSource), topLevelInfo.options) || \"\".concat(tableSource, \".\").concat(attrSource);\n        sourceJoinOn = \"\".concat(this.quoteIdentifier(joinSource), \" = \");\n      } else {\n        var aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n        sourceJoinOn = \"\".concat(this.quoteTable(tableSource), \".\").concat(this.quoteIdentifier(aliasedSource), \" = \");\n      }\n      sourceJoinOn += \"\".concat(this.quoteIdentifier(throughAs), \".\").concat(this.quoteIdentifier(identSource));\n      targetJoinOn = \"\".concat(this.quoteIdentifier(tableTarget), \".\").concat(this.quoteIdentifier(attrTarget), \" = \");\n      targetJoinOn += \"\".concat(this.quoteIdentifier(throughAs), \".\").concat(this.quoteIdentifier(identTarget));\n      if (through.where) {\n        throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n      }\n      this.aliasAs(includeAs.internalAs, topLevelInfo);\n      joinBody = \"( \".concat(this.quoteTable(throughTable, throughAs), \" INNER JOIN \").concat(this.quoteTable(include.model.getTableName(), includeAs.internalAs), \" ON \").concat(targetJoinOn);\n      if (throughWhere) {\n        joinBody += \" AND \".concat(throughWhere);\n      }\n      joinBody += \")\";\n      joinCondition = sourceJoinOn;\n      if (include.where || include.through.where) {\n        if (include.where) {\n          targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n          if (targetWhere) {\n            joinCondition += \" AND \".concat(targetWhere);\n          }\n        }\n      }\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      return {\n        join: joinType,\n        body: joinBody,\n        condition: joinCondition,\n        attributes: attributes\n      };\n    }\n  }, {\n    key: \"aliasAs\",\n    value: function aliasAs(as, topLevelInfo) {\n      if (this.options.minifyAliases && as.length >= 64) {\n        var alias = \"%\".concat(topLevelInfo.options.includeAliases.size);\n        topLevelInfo.options.includeAliases.set(alias, as);\n      }\n    }\n  }, {\n    key: \"_generateSubQueryFilter\",\n    value: function _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n      if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n        return;\n      }\n      if (!topLevelInfo.options.where) {\n        topLevelInfo.options.where = {};\n      }\n      var parent = include;\n      var child = include;\n      var nestedIncludes = this._getRequiredClosure(include).include;\n      var query;\n      while (parent = parent.parent) {\n        if (parent.parent && !parent.required) {\n          return;\n        }\n        if (parent.subQueryFilter) {\n          return;\n        }\n        nestedIncludes = [__spreadProps(__spreadValues({}, child), {\n          include: nestedIncludes,\n          attributes: []\n        })];\n        child = parent;\n      }\n      var topInclude = nestedIncludes[0];\n      var topParent = topInclude.parent;\n      var topAssociation = topInclude.association;\n      topInclude.association = void 0;\n      if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n        query = this.selectQuery(topInclude.through.model.getTableName(), {\n          attributes: [topInclude.through.model.primaryKeyField],\n          include: Model._validateIncludedElements({\n            model: topInclude.through.model,\n            include: [{\n              association: topAssociation.toTarget,\n              required: true,\n              where: topInclude.where,\n              include: topInclude.include\n            }]\n          }).include,\n          model: topInclude.through.model,\n          where: _defineProperty({}, Op.and, [this.sequelize.literal([\"\".concat(this.quoteTable(topParent.model.name), \".\").concat(this.quoteIdentifier(topParent.model.primaryKeyField)), \"\".concat(this.quoteIdentifier(topInclude.through.model.name), \".\").concat(this.quoteIdentifier(topAssociation.identifierField))].join(\" = \")), topInclude.through.where]),\n          limit: 1,\n          includeIgnoreAttributes: false\n        }, topInclude.through.model);\n      } else {\n        var isBelongsTo = topAssociation.associationType === \"BelongsTo\";\n        var sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n        var targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n        var join = [\"\".concat(this.quoteIdentifier(topInclude.as), \".\").concat(this.quoteIdentifier(targetField)), \"\".concat(this.quoteTable(topParent.as || topParent.model.name), \".\").concat(this.quoteIdentifier(sourceField))].join(\" = \");\n        query = this.selectQuery(topInclude.model.getTableName(), {\n          attributes: [targetField],\n          include: Model._validateIncludedElements(topInclude).include,\n          model: topInclude.model,\n          where: _defineProperty({}, Op.and, [topInclude.where, _defineProperty({}, Op.join, this.sequelize.literal(join))]),\n          limit: 1,\n          tableAs: topInclude.as,\n          includeIgnoreAttributes: false\n        }, topInclude.model);\n      }\n      if (!topLevelInfo.options.where[Op.and]) {\n        topLevelInfo.options.where[Op.and] = [];\n      }\n      topLevelInfo.options.where[\"__\".concat(includeAs.internalAs)] = this.sequelize.literal([\"(\", query.replace(/;$/, \"\"), \")\", \"IS NOT NULL\"].join(\" \"));\n    }\n  }, {\n    key: \"_getRequiredClosure\",\n    value: function _getRequiredClosure(include) {\n      var _this12 = this;\n      var copy = __spreadProps(__spreadValues({}, include), {\n        attributes: [],\n        include: []\n      });\n      if (Array.isArray(include.include)) {\n        copy.include = include.include.filter(function (i) {\n          return i.required;\n        }).map(function (inc) {\n          return _this12._getRequiredClosure(inc);\n        });\n      }\n      return copy;\n    }\n  }, {\n    key: \"getQueryOrders\",\n    value: function getQueryOrders(options, model, subQuery) {\n      var _this13 = this;\n      var mainQueryOrder = [];\n      var subQueryOrder = [];\n      if (Array.isArray(options.order)) {\n        var _iterator11 = _createForOfIteratorHelper(options.order),\n          _step11;\n        try {\n          var _loop3 = function _loop3() {\n            var order = _step11.value;\n            if (!Array.isArray(order)) {\n              order = [order];\n            }\n            if (subQuery && Array.isArray(order) && order[0] && !(order[0] instanceof Association) && !(typeof order[0] === \"function\" && order[0].prototype instanceof Model) && !(typeof order[0].model === \"function\" && order[0].model.prototype instanceof Model) && !(typeof order[0] === \"string\" && model && model.associations !== void 0 && model.associations[order[0]])) {\n              var field = model.rawAttributes[order[0]] ? model.rawAttributes[order[0]].field : order[0];\n              var subQueryAlias = _this13._getAliasForField(_this13.quoteIdentifier(model.name), field, options);\n              var parent = null;\n              var orderToQuote = [];\n              if (subQueryAlias === null) {\n                orderToQuote = order;\n                parent = model;\n              } else {\n                orderToQuote = [subQueryAlias, order.length > 1 ? order[1] : \"ASC\"];\n                parent = null;\n              }\n              subQueryOrder.push(_this13.quote(orderToQuote, parent, \"->\"));\n            }\n            if (options.attributes && model) {\n              var aliasedAttribute = options.attributes.find(function (attr) {\n                return Array.isArray(attr) && attr[1] && (attr[0] === order[0] || attr[1] === order[0]);\n              });\n              if (aliasedAttribute) {\n                var modelName = _this13.quoteIdentifier(model.name);\n                var alias = _this13._getAliasForField(modelName, aliasedAttribute[1], options);\n                order[0] = new Utils.Col(alias || aliasedAttribute[1]);\n              }\n            }\n            mainQueryOrder.push(_this13.quote(order, model, \"->\"));\n          };\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            _loop3();\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      } else if (options.order instanceof Utils.SequelizeMethod) {\n        var sql = this.quote(options.order, model, \"->\");\n        if (subQuery) {\n          subQueryOrder.push(sql);\n        }\n        mainQueryOrder.push(sql);\n      } else {\n        throw new Error(\"Order must be type of array or instance of a valid sequelize method.\");\n      }\n      return {\n        mainQueryOrder: mainQueryOrder,\n        subQueryOrder: subQueryOrder\n      };\n    }\n  }, {\n    key: \"_throwOnEmptyAttributes\",\n    value: function _throwOnEmptyAttributes(attributes) {\n      var extraInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (attributes.length > 0) return;\n      var asPart = extraInfo.as && \"as \".concat(extraInfo.as) || \"\";\n      var namePart = extraInfo.modelName && \"for model '\".concat(extraInfo.modelName, \"'\") || \"\";\n      var message = \"Attempted a SELECT query \".concat(namePart, \" \").concat(asPart, \" without selecting any columns\");\n      throw new sequelizeError.QueryError(message.replace(/ +/g, \" \"));\n    }\n  }, {\n    key: \"selectFromTableFragment\",\n    value: function selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n      var _this14 = this;\n      this._throwOnEmptyAttributes(attributes, {\n        modelName: model && model.name,\n        as: mainTableAs\n      });\n      var fragment = \"SELECT \".concat(attributes.join(\", \"), \" FROM \").concat(tables);\n      if (mainTableAs) {\n        fragment += \" \".concat(this.getAliasToken(), \" \").concat(mainTableAs);\n      }\n      if (options.indexHints && this._dialect.supports.indexHints) {\n        var _iterator12 = _createForOfIteratorHelper(options.indexHints),\n          _step12;\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var hint = _step12.value;\n            if (IndexHints[hint.type]) {\n              fragment += \" \".concat(IndexHints[hint.type], \" INDEX (\").concat(hint.values.map(function (indexName) {\n                return _this14.quoteIdentifiers(indexName);\n              }).join(\",\"), \")\");\n            }\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n      return fragment;\n    }\n  }, {\n    key: \"addLimitAndOffset\",\n    value: function addLimitAndOffset(options) {\n      var fragment = \"\";\n      if (options.offset != null && options.limit == null) {\n        fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + 1e13;\n      } else if (options.limit != null) {\n        if (options.offset != null) {\n          fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + this.escape(options.limit);\n        } else {\n          fragment += \" LIMIT \" + this.escape(options.limit);\n        }\n      }\n      return fragment;\n    }\n  }, {\n    key: \"handleSequelizeMethod\",\n    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n      var _this15 = this;\n      var result;\n      if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n        smth.comparator = this.OperatorMap[smth.comparator];\n      }\n      if (smth instanceof Utils.Where) {\n        var value = smth.logic;\n        var key;\n        if (smth.attribute instanceof Utils.SequelizeMethod) {\n          key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n        } else {\n          key = \"\".concat(this.quoteTable(smth.attribute.Model.name), \".\").concat(this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName));\n        }\n        if (value && value instanceof Utils.SequelizeMethod) {\n          value = this.getWhereConditions(value, tableName, factory, options, prepend);\n          if (value === \"NULL\") {\n            if (smth.comparator === \"=\") {\n              smth.comparator = \"IS\";\n            }\n            if (smth.comparator === \"!=\") {\n              smth.comparator = \"IS NOT\";\n            }\n          }\n          return [key, value].join(\" \".concat(smth.comparator, \" \"));\n        }\n        if (_.isPlainObject(value)) {\n          return this.whereItemQuery(smth.attribute, value, {\n            model: factory\n          });\n        }\n        if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {\n          value = \"\".concat(this.escape(value[0]), \" AND \").concat(this.escape(value[1]));\n        } else if (typeof value === \"boolean\") {\n          value = this.booleanValue(value);\n        } else {\n          value = this.escape(value);\n        }\n        if (value === \"NULL\") {\n          if (smth.comparator === \"=\") {\n            smth.comparator = \"IS\";\n          }\n          if (smth.comparator === \"!=\") {\n            smth.comparator = \"IS NOT\";\n          }\n        }\n        return [key, value].join(\" \".concat(smth.comparator, \" \"));\n      }\n      if (smth instanceof Utils.Literal) {\n        return smth.val;\n      }\n      if (smth instanceof Utils.Cast) {\n        if (smth.val instanceof Utils.SequelizeMethod) {\n          result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        } else if (_.isPlainObject(smth.val)) {\n          result = this.whereItemsQuery(smth.val);\n        } else {\n          result = this.escape(smth.val);\n        }\n        return \"CAST(\".concat(result, \" AS \").concat(smth.type.toUpperCase(), \")\");\n      }\n      if (smth instanceof Utils.Fn) {\n        return \"\".concat(smth.fn, \"(\").concat(smth.args.map(function (arg) {\n          if (arg instanceof Utils.SequelizeMethod) {\n            return _this15.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n          }\n          if (_.isPlainObject(arg)) {\n            return _this15.whereItemsQuery(arg);\n          }\n          return _this15.escape(typeof arg === \"string\" ? arg.replace(/\\$/g, \"$$$\") : arg);\n        }).join(\", \"), \")\");\n      }\n      if (smth instanceof Utils.Col) {\n        if (Array.isArray(smth.col) && !factory) {\n          throw new Error(\"Cannot call Sequelize.col() with array outside of order / group clause\");\n        }\n        if (smth.col.startsWith(\"*\")) {\n          return \"*\";\n        }\n        return this.quote(smth.col, factory);\n      }\n      return smth.toString(this, factory);\n    }\n  }, {\n    key: \"whereQuery\",\n    value: function whereQuery(where, options) {\n      var query = this.whereItemsQuery(where, options);\n      if (query && query.length) {\n        return \"WHERE \".concat(query);\n      }\n      return \"\";\n    }\n  }, {\n    key: \"whereItemsQuery\",\n    value: function whereItemsQuery(where, options, binding) {\n      var _this16 = this;\n      if (where === null || where === void 0 || Utils.getComplexSize(where) === 0) {\n        return \"\";\n      }\n      if (typeof where === \"string\") {\n        throw new Error(\"Support for `{where: 'raw query'}` has been removed.\");\n      }\n      var items = [];\n      binding = binding || \"AND\";\n      if (binding[0] !== \" \") binding = \" \".concat(binding, \" \");\n      if (_.isPlainObject(where)) {\n        Utils.getComplexKeys(where).forEach(function (prop) {\n          var item = where[prop];\n          items.push(_this16.whereItemQuery(prop, item, options));\n        });\n      } else {\n        items.push(this.whereItemQuery(void 0, where, options));\n      }\n      return items.length && items.filter(function (item) {\n        return item && item.length;\n      }).join(binding) || \"\";\n    }\n  }, {\n    key: \"whereItemQuery\",\n    value: function whereItemQuery(key, value) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (value === void 0) {\n        throw new Error(\"WHERE parameter \\\"\".concat(key, \"\\\" has invalid \\\"undefined\\\" value\"));\n      }\n      if (typeof key === \"string\" && key.includes(\".\") && options.model) {\n        var keyParts = key.split(\".\");\n        if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n          var tmp = {};\n          var field2 = options.model.rawAttributes[keyParts[0]];\n          _.set(tmp, keyParts.slice(1), value);\n          return this.whereItemQuery(field2.field || keyParts[0], tmp, __spreadValues({\n            field: field2\n          }, options));\n        }\n      }\n      var field = this._findField(key, options);\n      var fieldType = field && field.type || options.type;\n      var isPlainObject = _.isPlainObject(value);\n      var isArray = !isPlainObject && Array.isArray(value);\n      key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n      if (isPlainObject) {\n        value = this._replaceAliases(value);\n      }\n      var valueKeys = isPlainObject && Utils.getComplexKeys(value);\n      if (key === void 0) {\n        if (typeof value === \"string\") {\n          return value;\n        }\n        if (isPlainObject && valueKeys.length === 1) {\n          return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n        }\n      }\n      if (value === null) {\n        var opValue2 = options.bindParam ? \"NULL\" : this.escape(value, field);\n        return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.is], options.prefix);\n      }\n      if (!value) {\n        var _opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n        return this._joinKeyValue(key, _opValue, this.OperatorMap[Op.eq], options.prefix);\n      }\n      if (value instanceof Utils.SequelizeMethod && !(key !== void 0 && value instanceof Utils.Fn)) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (key === void 0 && isArray) {\n        if (Utils.canTreatArrayAsAnd(value)) {\n          key = Op.and;\n        } else {\n          throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n        }\n      }\n      if (key === Op.or || key === Op.and || key === Op.not) {\n        return this._whereGroupBind(key, value, options);\n      }\n      if (value[Op.or]) {\n        return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n      }\n      if (value[Op.and]) {\n        return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n      }\n      if (isArray && fieldType instanceof DataTypes.ARRAY) {\n        var _opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n        return this._joinKeyValue(key, _opValue2, this.OperatorMap[Op.eq], options.prefix);\n      }\n      if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n        return this._whereJSON(key, value, options);\n      }\n      if (isPlainObject && valueKeys.length > 1) {\n        return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n      }\n      if (isArray) {\n        return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n      }\n      if (isPlainObject) {\n        if (this.OperatorMap[valueKeys[0]]) {\n          return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n        }\n        return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n      }\n      if (key === Op.placeholder) {\n        var _opValue3 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n        return this._joinKeyValue(this.OperatorMap[key], _opValue3, this.OperatorMap[Op.eq], options.prefix);\n      }\n      var opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n  }, {\n    key: \"_findField\",\n    value: function _findField(key, options) {\n      if (options.field) {\n        return options.field;\n      }\n      if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n        return options.model.rawAttributes[key];\n      }\n      if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n        return options.model.fieldRawAttributesMap[key];\n      }\n    }\n  }, {\n    key: \"_whereGroupBind\",\n    value: function _whereGroupBind(key, value, options) {\n      var _this17 = this;\n      var binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n      var outerBinding = key === Op.not ? \"NOT \" : \"\";\n      if (Array.isArray(value)) {\n        value = value.map(function (item) {\n          var itemQuery = _this17.whereItemsQuery(item, options, _this17.OperatorMap[Op.and]);\n          if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n            itemQuery = \"(\".concat(itemQuery, \")\");\n          }\n          return itemQuery;\n        }).filter(function (item) {\n          return item && item.length;\n        });\n        value = value.length && value.join(binding);\n      } else {\n        value = this.whereItemsQuery(value, options, binding);\n      }\n      if ((key === Op.or || key === Op.not) && !value) {\n        return \"0 = 1\";\n      }\n      return value ? \"\".concat(outerBinding, \"(\").concat(value, \")\") : void 0;\n    }\n  }, {\n    key: \"_whereBind\",\n    value: function _whereBind(binding, key, value, options) {\n      var _this18 = this;\n      if (_.isPlainObject(value)) {\n        value = Utils.getComplexKeys(value).map(function (prop) {\n          var item = value[prop];\n          return _this18.whereItemQuery(key, _defineProperty({}, prop, item), options);\n        });\n      } else {\n        value = value.map(function (item) {\n          return _this18.whereItemQuery(key, item, options);\n        });\n      }\n      value = value.filter(function (item) {\n        return item && item.length;\n      });\n      return value.length ? \"(\".concat(value.join(binding), \")\") : void 0;\n    }\n  }, {\n    key: \"_whereJSON\",\n    value: function _whereJSON(key, value, options) {\n      var _this19 = this;\n      var items = [];\n      var baseKey = this.quoteIdentifier(key);\n      if (options.prefix) {\n        if (options.prefix instanceof Utils.Literal) {\n          baseKey = \"\".concat(this.handleSequelizeMethod(options.prefix), \".\").concat(baseKey);\n        } else {\n          baseKey = \"\".concat(this.quoteTable(options.prefix), \".\").concat(baseKey);\n        }\n      }\n      Utils.getOperators(value).forEach(function (op) {\n        var where = _defineProperty({}, op, value[op]);\n        items.push(_this19.whereItemQuery(key, where, __spreadProps(__spreadValues({}, options), {\n          json: false\n        })));\n      });\n      _.forOwn(value, function (item, prop) {\n        _this19._traverseJSON(items, baseKey, prop, item, [prop]);\n      });\n      var result = items.join(this.OperatorMap[Op.and]);\n      return items.length > 1 ? \"(\".concat(result, \")\") : result;\n    }\n  }, {\n    key: \"_traverseJSON\",\n    value: function _traverseJSON(items, baseKey, prop, item, path) {\n      var _this20 = this;\n      var cast;\n      if (path[path.length - 1].includes(\"::\")) {\n        var tmp = path[path.length - 1].split(\"::\");\n        cast = tmp[1];\n        path[path.length - 1] = tmp[0];\n      }\n      var pathKey = this.jsonPathExtractionQuery(baseKey, path);\n      if (_.isPlainObject(item)) {\n        Utils.getOperators(item).forEach(function (op) {\n          var value = _this20._toJSONValue(item[op]);\n          var isJson = false;\n          if (typeof value === \"string\" && op === Op.contains) {\n            try {\n              JSON.stringify(value);\n              isJson = true;\n            } catch (e) {}\n          }\n          pathKey = _this20.jsonPathExtractionQuery(baseKey, path, isJson);\n          items.push(_this20.whereItemQuery(_this20._castKey(pathKey, value, cast), _defineProperty({}, op, value)));\n        });\n        _.forOwn(item, function (value, itemProp) {\n          _this20._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n        });\n        return;\n      }\n      item = this._toJSONValue(item);\n      items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), _defineProperty({}, Op.eq, item)));\n    }\n  }, {\n    key: \"_toJSONValue\",\n    value: function _toJSONValue(value) {\n      return value;\n    }\n  }, {\n    key: \"_castKey\",\n    value: function _castKey(key, value, cast, json) {\n      cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n      if (cast) {\n        return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n      }\n      return new Utils.Literal(key);\n    }\n  }, {\n    key: \"_getJsonCast\",\n    value: function _getJsonCast(value) {\n      if (typeof value === \"number\") {\n        return \"double precision\";\n      }\n      if (value instanceof Date) {\n        return \"timestamptz\";\n      }\n      if (typeof value === \"boolean\") {\n        return \"boolean\";\n      }\n      return;\n    }\n  }, {\n    key: \"_joinKeyValue\",\n    value: function _joinKeyValue(key, value, comparator, prefix) {\n      if (!key) {\n        return value;\n      }\n      if (comparator === void 0) {\n        throw new Error(\"\".concat(key, \" and \").concat(value, \" has no comparator\"));\n      }\n      key = this._getSafeKey(key, prefix);\n      return [key, value].join(\" \".concat(comparator, \" \"));\n    }\n  }, {\n    key: \"_getSafeKey\",\n    value: function _getSafeKey(key, prefix) {\n      var _this21 = this;\n      if (key instanceof Utils.SequelizeMethod) {\n        key = this.handleSequelizeMethod(key);\n        return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n      }\n      if (Utils.isColString(key)) {\n        key = key.substr(1, key.length - 2).split(\".\");\n        if (key.length > 2) {\n          key = [key.slice(0, -1).join(\"->\"), key[key.length - 1]];\n        }\n        return key.map(function (identifier) {\n          return _this21.quoteIdentifier(identifier);\n        }).join(\".\");\n      }\n      return this._prefixKey(this.quoteIdentifier(key), prefix);\n    }\n  }, {\n    key: \"_prefixKey\",\n    value: function _prefixKey(key, prefix) {\n      if (prefix) {\n        if (prefix instanceof Utils.Literal) {\n          return [this.handleSequelizeMethod(prefix), key].join(\".\");\n        }\n        return [this.quoteTable(prefix), key].join(\".\");\n      }\n      return key;\n    }\n  }, {\n    key: \"_whereParseSingleValueObject\",\n    value: function _whereParseSingleValueObject(key, field, prop, value, options) {\n      var _this22 = this;\n      if (prop === Op.not) {\n        if (Array.isArray(value)) {\n          prop = Op.notIn;\n        } else if (value !== null && value !== true && value !== false) {\n          prop = Op.ne;\n        }\n      }\n      var comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n      switch (prop) {\n        case Op.in:\n        case Op.notIn:\n          if (value instanceof Utils.Literal) {\n            return this._joinKeyValue(key, value.val, comparator, options.prefix);\n          }\n          if (value.length) {\n            return this._joinKeyValue(key, \"(\".concat(value.map(function (item) {\n              return _this22.escape(item, field);\n            }).join(\", \"), \")\"), comparator, options.prefix);\n          }\n          if (comparator === this.OperatorMap[Op.in]) {\n            return this._joinKeyValue(key, \"(NULL)\", comparator, options.prefix);\n          }\n          return \"\";\n        case Op.any:\n        case Op.all:\n          comparator = \"\".concat(this.OperatorMap[Op.eq], \" \").concat(comparator);\n          if (value[Op.values]) {\n            return this._joinKeyValue(key, \"(VALUES \".concat(value[Op.values].map(function (item) {\n              return \"(\".concat(_this22.escape(item), \")\");\n            }).join(\", \"), \")\"), comparator, options.prefix);\n          }\n          return this._joinKeyValue(key, \"(\".concat(this.escape(value, field), \")\"), comparator, options.prefix);\n        case Op.between:\n        case Op.notBetween:\n          return this._joinKeyValue(key, \"\".concat(this.escape(value[0], field), \" AND \").concat(this.escape(value[1], field)), comparator, options.prefix);\n        case Op.raw:\n          throw new Error(\"The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.\");\n        case Op.col:\n          comparator = this.OperatorMap[Op.eq];\n          value = value.split(\".\");\n          if (value.length > 2) {\n            value = [value.slice(0, -1).join(\"->\"), value[value.length - 1]];\n          }\n          return this._joinKeyValue(key, value.map(function (identifier) {\n            return _this22.quoteIdentifier(identifier);\n          }).join(\".\"), comparator, options.prefix);\n        case Op.startsWith:\n        case Op.endsWith:\n        case Op.substring:\n          comparator = this.OperatorMap[Op.like];\n          if (value instanceof Utils.Literal) {\n            value = value.val;\n          }\n          var pattern = \"\".concat(value, \"%\");\n          if (prop === Op.endsWith) pattern = \"%\".concat(value);\n          if (prop === Op.substring) pattern = \"%\".concat(value, \"%\");\n          return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);\n      }\n      var escapeOptions = {\n        acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n      };\n      if (_.isPlainObject(value)) {\n        if (value[Op.col]) {\n          return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n        }\n        if (value[Op.any]) {\n          escapeOptions.isList = true;\n          return this._joinKeyValue(key, \"(\".concat(this.escape(value[Op.any], field, escapeOptions), \")\"), \"\".concat(comparator, \" \").concat(this.OperatorMap[Op.any]), options.prefix);\n        }\n        if (value[Op.all]) {\n          escapeOptions.isList = true;\n          return this._joinKeyValue(key, \"(\".concat(this.escape(value[Op.all], field, escapeOptions), \")\"), \"\".concat(comparator, \" \").concat(this.OperatorMap[Op.all]), options.prefix);\n        }\n      }\n      if (value === null && comparator === this.OperatorMap[Op.eq]) {\n        return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n      }\n      if (value === null && comparator === this.OperatorMap[Op.ne]) {\n        return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n      }\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n    }\n  }, {\n    key: \"getWhereConditions\",\n    value: function getWhereConditions(smth, tableName, factory, options, prepend) {\n      var where = {};\n      if (Array.isArray(tableName)) {\n        tableName = tableName[0];\n        if (Array.isArray(tableName)) {\n          tableName = tableName[1];\n        }\n      }\n      options = options || {};\n      if (prepend === void 0) {\n        prepend = true;\n      }\n      if (smth && smth instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n      }\n      if (_.isPlainObject(smth)) {\n        return this.whereItemsQuery(smth, {\n          model: factory,\n          prefix: prepend && tableName,\n          type: options.type\n        });\n      }\n      if (typeof smth === \"number\" || typeof smth === \"bigint\") {\n        var primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n        if (primaryKeys.length > 0) {\n          primaryKeys = primaryKeys[0];\n        } else {\n          primaryKeys = \"id\";\n        }\n        where[primaryKeys] = smth;\n        return this.whereItemsQuery(where, {\n          model: factory,\n          prefix: prepend && tableName\n        });\n      }\n      if (typeof smth === \"string\") {\n        return this.whereItemsQuery(smth, {\n          model: factory,\n          prefix: prepend && tableName\n        });\n      }\n      if (Buffer.isBuffer(smth)) {\n        return this.escape(smth);\n      }\n      if (Array.isArray(smth)) {\n        if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return \"1=1\";\n        if (Utils.canTreatArrayAsAnd(smth)) {\n          var _smth = _defineProperty({}, Op.and, smth);\n          return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n        }\n        throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n      }\n      if (smth == null) {\n        return this.whereItemsQuery(smth, {\n          model: factory,\n          prefix: prepend && tableName\n        });\n      }\n      throw new Error(\"Unsupported where option value: \".concat(util.inspect(smth), \". Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option.\"));\n    }\n  }, {\n    key: \"parseConditionObject\",\n    value: function parseConditionObject(conditions, path) {\n      var _this23 = this;\n      path = path || [];\n      return _.reduce(conditions, function (result, value, key) {\n        if (_.isObject(value)) {\n          return result.concat(_this23.parseConditionObject(value, path.concat(key)));\n        }\n        result.push({\n          path: path.concat(key),\n          value: value\n        });\n        return result;\n      }, []);\n    }\n  }, {\n    key: \"booleanValue\",\n    value: function booleanValue(value) {\n      return value;\n    }\n  }, {\n    key: \"authTestQuery\",\n    value: function authTestQuery() {\n      return \"SELECT 1+1 AS result\";\n    }\n  }]);\n  return QueryGenerator;\n}();\nObject.assign(QueryGenerator.prototype, require(\"./query-generator/operators\"));\nObject.assign(QueryGenerator.prototype, require(\"./query-generator/transaction\"));\nmodule.exports = QueryGenerator;","map":{"version":3,"names":["util","require","_","uuidv4","v4","Utils","deprecations","SqlString","DataTypes","Model","Association","BelongsTo","BelongsToMany","HasMany","Op","sequelizeError","IndexHints","QueryGenerator","options","_classCallCheck","sequelize","Error","_dialect","dialect","name","_initQuoteIdentifier","_createClass","key","value","extractTableDetails","tableName","schema","isPlainObject","delimiter","addSchema","param","_schema","self","table","_schemaDelimiter","toString","quoteTable","dropSchema","dropTableQuery","describeTableQuery","schemaDelimiter","concat","renameTableQuery","before","after","populateInsertQueryReturnIntoBinds","insertQuery","valueHash","modelAttributes","_this","defaults","modelAttributeMap","bind","fields","returningModelAttributes","returnTypes","values","quotedTable","bindParam","returnAttributes","query","valueQuery","emptyQuery","outputFragment","returningFragment","identityWrapperRequired","tmpTable","each","attribute","field","supports","returnValues","returnIntoValues","returning","generateReturnValues","push","apply","_toConsumableArray","returnFields","get","searchPath","EXCEPTION","exception","removeNullValuesFromHash","omitNull","Object","prototype","hasOwnProperty","call","quoteIdentifier","autoIncrement","defaultValue","splice","DEFAULT","escape","SequelizeMethod","context","format","onDuplicateKeyUpdate","isEmpty","conflictWhere","inserts","onConflictWhere","updateOnDuplicate","conflictKeys","upsertKeys","map","attr","updateKeys","fragments","join","whereQuery","joinSQLFragments","valueKeys","replacements","ignoreDuplicates","onConflictDoNothing","attributes","output","dropFunction","length","replace","selectQuery","finalTable","identityInsert","result","bulkInsertQuery","fieldValueHashes","fieldMappedAttributes","_this2","tuples","serials","allAttributes","_iterator2","_createForOfIteratorHelper","_step2","s","n","done","fieldValueHash","forOwn","includes","err","e","f","_iterator3","_step3","_loop","bulkDefault","whereClause","updateQuery","attrValueHash","where","suffix","limit","keys","mapToModel","update","whereOptions","__spreadProps","__spreadValues","trim","arithmeticQuery","operator","incrementAmountsByField","extraAttributesToBeUpdated","updateSetSqlFragments","incrementAmount","quotedField","escapedAmount","newValue","escapedValue","addIndexQuery","rawTablename","_this3","Array","isArray","prefix","fieldsSql","handleSequelizeMethod","inspect","index","collate","order","nameIndex","_conformIndex","type","quoteIdentifiers","concurrently","ind","indexViaAlter","unique","using","parser","compact","addConstraintQuery","getConstraintSnippet","_this4","constraintSnippet","constraintName","fieldsSqlQuotedString","fieldsSqlString","toUpperCase","whereItemsQuery","references","quotedReferences","referencesSnippet","onUpdate","onDelete","deferrable","deferConstraintsQuery","removeConstraintQuery","quote","collection","parent","connector","_this5","validOrderOptions","forEach","item2","previous","previousAssociation","previousModel","target","model","as","through","getAssociationForAlias","orderIndex","indexOf","literal","associations","rawAttributes","itemSplit","split","JSON","identifier","path","slice","jsonPathExtractionQuery","collectionLength","tableNames","item","i","_modelAttribute","sql","collectionItem","fieldName","raw","_quoteIdentifier","force","identifiers","head","tail","quoteAttribute","getAliasToken","alias","isObject","schemas","_this6","validate","stringify","simpleEscape","escVal","timezone","operation","identity","typeValidation","isList","_iterator4","_step4","error","ValidationError","errors","ValidationErrorItem","message","isIdentifierQuoted","test","column","isJson","paths","toPath","pathStr","quotedColumn","subPath","addTicks","__","digit","_this7","mainQueryItems","subQueryItems","subQuery","hasMultiAssociation","main","mainTable","quotedName","topLevelInfo","names","mainJoinQueries","subJoinQueries","minifyAliases","aliasesMapping","Map","aliasesByTable","includeAliases","tableAs","t","_iterator5","primaryKeyAttributes","_step5","_loop2","keyAtt","some","escapeAttributes","include","groupedLimit","_iterator6","_step6","separate","joinQueries","generateInclude","externalAs","internalAs","mainQuery","uniq","selectFromTableFragment","groupedLimitOrder","whereKey","groupedTableName","on","foreignKeyField","manyFromSource","groupedLimitOptions","_validateIncludedElements","association","duplicating","required","_defineProperty","placeholder","hasJoin","includeMap","assign","includeNames","topLevelOrderByRequired","baseQuery","offset","placeHolder","whereItemQuery","splicePos","groupWhere","foreignIdentifierField","spliceStr","getWhereConditions","startsWith","group","aliasGrouping","having","orders","getQueryOrders","mainQueryOrder","subQueryOrder","limitOrder","addLimitAndOffset","_throwOnEmptyAttributes","modelName","lock","level","lockKey","forShare","lockOf","of","skipLocked","src","_getAliasForField","mainTableAs","_this8","addTable","attributeBehavior","_getMinifiedAlias","TICK_CHAR","dotNotation","parentTableName","_this9","mainChildIncludes","subChildIncludes","requiredMismatch","includeAs","joinQuery","keysEscaped","includeIgnoreAttributes","_expandAttributes","mapFinderOptions","includeAttributes","attrAs","verbatim","Literal","Cast","Fn","attr2","val","_iterator7","_step7","_iterator8","_step8","generateThroughJoin","_generateSubQueryFilter","generateJoin","_iterator9","_step9","childInclude","_pseudo","childJoinQueries","body","condition","match","minifiedAlias","size","set","parentIsTop","$parent","joinWhere","left","source","attrLeft","sourceKeyAttribute","primaryKeyAttribute","fieldLeft","identifierField","asLeft","right","tableRight","getTableName","fieldRight","targetIdentifier","asRight","joinOn","subqueryAttributes","dbIdentifier","joinSource","or","aliasAs","_this10","VIRTUAL","hasTrigger","tmpTableTrigger","tmpColumns","toSql","_this11","throughTable","throughAs","externalThroughAs","throughAttributes","tableSource","identSource","tableTarget","identTarget","attrTarget","targetKeyField","joinType","joinBody","joinCondition","attrSource","sourceKey","sourceJoinOn","targetJoinOn","throughWhere","targetWhere","_iterator10","_step10","sourceKeyField","mainModel","aliasedSource","subQueryFilter","child","nestedIncludes","_getRequiredClosure","topInclude","topParent","topAssociation","primaryKeyField","toTarget","and","isBelongsTo","associationType","sourceField","targetField","_this12","copy","filter","inc","_this13","_iterator11","_step11","_loop3","subQueryAlias","orderToQuote","aliasedAttribute","find","Col","extraInfo","arguments","undefined","asPart","namePart","QueryError","tables","_this14","fragment","indexHints","_iterator12","_step12","hint","indexName","smth","factory","prepend","_this15","OperatorMap","comparator","Where","logic","between","notBetween","booleanValue","fn","args","arg","col","binding","_this16","getComplexSize","items","getComplexKeys","prop","keyParts","tmp","field2","_findField","fieldType","OperatorsAliasMap","_replaceAliases","opValue2","_joinKeyValue","is","eq","canTreatArrayAsAnd","not","_whereGroupBind","_whereBind","ARRAY","json","_whereJSON","_whereParseSingleValueObject","in","opValue","fieldRawAttributesMap","_this17","outerBinding","itemQuery","_this18","_this19","baseKey","getOperators","op","_traverseJSON","_this20","cast","pathKey","_toJSONValue","contains","_castKey","itemProp","_getJsonCast","Date","_getSafeKey","_this21","_prefixKey","isColString","substr","_this22","notIn","ne","any","all","endsWith","substring","like","pattern","escapeOptions","acceptStrings","primaryKeys","Buffer","isBuffer","_smth","parseConditionObject","conditions","_this23","reduce","authTestQuery","module","exports"],"sources":["../../../src/dialects/abstract/query-generator.js"],"sourcesContent":["'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst uuidv4 = require('uuid').v4;\n\nconst Utils = require('../../utils');\nconst deprecations = require('../../utils/deprecations');\nconst SqlString = require('../../sql-string');\nconst DataTypes = require('../../data-types');\nconst Model = require('../../model');\nconst Association = require('../../associations/base');\nconst BelongsTo = require('../../associations/belongs-to');\nconst BelongsToMany = require('../../associations/belongs-to-many');\nconst HasMany = require('../../associations/has-many');\nconst Op = require('../../operators');\nconst sequelizeError = require('../../errors');\nconst IndexHints = require('../../index-hints');\n\n\n/**\n * Abstract Query Generator\n *\n * @private\n */\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize) throw new Error('QueryGenerator initialized without options.sequelize');\n    if (!options._dialect) throw new Error('QueryGenerator initialized without options._dialect');\n\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n\n    // dialect name\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n\n    // wrap quoteIdentifier with common logic\n    this._initQuoteIdentifier();\n  }\n\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || this.options.schema || 'public',\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || '.'\n    };\n  }\n\n  addSchema(param) {\n    if (!param._schema) return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || '.',\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `DESCRIBE ${table};`;\n  }\n\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n\n  /**\n   * Helper method for populating the returning into bind information\n   * that is needed by some dialects (currently Oracle)\n   *\n   * @private\n   */\n  populateInsertQueryReturnIntoBinds() {\n    // noop by default\n  }\n\n  /**\n   * Returns an insert into command\n   *\n   * @param {string} table\n   * @param {object} valueHash       attribute value pairs\n   * @param {object} modelAttributes\n   * @param {object} [options]\n   *\n   * @private\n   */\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    const modelAttributeMap = {};\n    const bind = options.bind || [];\n    const fields = [];\n    const returningModelAttributes = [];\n    const returnTypes = [];\n    const values = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n    const returnAttributes = [];\n    let query;\n    let valueQuery = '';\n    let emptyQuery = '';\n    let outputFragment = '';\n    let returningFragment = '';\n    let identityWrapperRequired = false;\n    let tmpTable = ''; //tmpTable declaration for trigger\n\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    if (this._dialect.supports['DEFAULT VALUES']) {\n      emptyQuery += ' DEFAULT VALUES';\n    } else if (this._dialect.supports['VALUES ()']) {\n      emptyQuery += ' VALUES ()';\n    }\n\n    if ((this._dialect.supports.returnValues || this._dialect.supports.returnIntoValues) && options.returning) {\n      const returnValues = this.generateReturnValues(modelAttributes, options);\n\n      returningModelAttributes.push(...returnValues.returnFields);\n      // Storing the returnTypes for dialects that need to have returning into bind information for outbinds\n      if (this._dialect.supports.returnIntoValues) {\n        returnTypes.push(...returnValues.returnTypes);\n      }\n      returningFragment = returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || '';\n      outputFragment = returnValues.outputFragment || '';\n    }\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      // Not currently supported with bind parameters (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n\n        // SERIALS' can't be NULL in postgresql, use DEFAULT where supported\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push('DEFAULT');\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'INSERT' }, bindParam));\n          }\n        }\n      }\n    }\n\n    let onDuplicateKeyUpdate = '';\n\n    if (\n      !_.isEmpty(options.conflictWhere)\n      && !this._dialect.supports.inserts.onConflictWhere\n    ) {\n      throw new Error('missing dialect support for conflictWhere option');\n    }\n\n    // `options.updateOnDuplicate` is the list of field names to update if a duplicate key is hit during the insert.  It\n    // contains just the field names.  This option is _usually_ explicitly set by the corresponding query-interface\n    // upsert function.\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n\n        const fragments = [\n          'ON CONFLICT',\n          '(',\n          conflictKeys.join(','),\n          ')'\n        ];\n\n        if (!_.isEmpty(options.conflictWhere)) {\n          fragments.push(this.whereQuery(options.conflictWhere, options));\n        }\n\n        // if update keys are provided, then apply them here.  if there are no updateKeys provided, then do not try to\n        // do an update.  Instead, fall back to DO NOTHING.\n        if (_.isEmpty(updateKeys)) {\n          fragments.push('DO NOTHING');\n        } else {\n          fragments.push('DO UPDATE SET', updateKeys.join(','));\n        }\n\n        onDuplicateKeyUpdate = ` ${Utils.joinSQLFragments(fragments)}`;\n\n      } else {\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        // the rough equivalent to ON CONFLICT DO NOTHING in mysql, etc is ON DUPLICATE KEY UPDATE id = id\n        // So, if no update values were provided, fall back to the identifier columns provided in the upsertKeys array.\n        // This will be the primary key in most cases, but it could be some other constraint.\n        if (_.isEmpty(valueKeys) && options.upsertKeys) {\n          valueKeys.push(...options.upsertKeys.map(attr => `${this.quoteIdentifier(attr)}=${this.quoteIdentifier(attr)}`));\n        }\n\n        // edge case... but if for some reason there were no valueKeys, and there were also no upsertKeys... then we\n        // can no longer build the requested query without a syntax error.  Let's throw something more graceful here\n        // so the devs know what the problem is.\n        if (_.isEmpty(valueKeys)) {\n          throw new Error('No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.');\n        }\n        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '',\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '',\n      attributes: fields.join(','),\n      output: outputFragment,\n      values: values.join(','),\n      tmpTable\n    };\n\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;\n\n    // Mostly for internal use, so we expect the user to know what he's doing!\n    // pg_temp functions are private per connection, so we never risk this function interfering with another one.\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      const dropFunction = 'DROP FUNCTION IF EXISTS pg_temp.testfunc()';\n\n      if (returningModelAttributes.length === 0) {\n        returningModelAttributes.push('*');\n      }\n\n      const delimiter = `$func_${uuidv4().replace(/-/g, '')}$`;\n      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(', (testfunc.response).')}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;\n\n      options.exception = 'WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;';\n      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;\n    } else {\n      valueQuery += returningFragment;\n      emptyQuery += returningFragment;\n    }\n\n    if (this._dialect.supports.returnIntoValues && options.returning) {\n      // Populating the returnAttributes array and performing operations needed for output binds of insertQuery\n      this.populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, bind.length, returnAttributes, options);\n    }\n\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery}${returnAttributes.join(',')};`;\n    if (this._dialect.supports.finalTable) {\n      query = `SELECT * FROM FINAL TABLE(${ replacements.attributes.length ? valueQuery : emptyQuery });`;\n    }\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {object} fieldValueHashes\n   * @param {object} options\n   * @param {object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = '';\n\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (\n          fieldMappedAttributes[key]\n          && fieldMappedAttributes[key].autoIncrement === true\n        ) {\n          serials[key] = true;\n        }\n      });\n    }\n\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map(key => {\n        if (\n          this._dialect.supports.bulkDefault\n          && serials[key] === true\n        ) {\n          // fieldValueHashes[key] ?? 'DEFAULT'\n          return fieldValueHash[key] != null ? fieldValueHash[key] : 'DEFAULT';\n        }\n\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' });\n      });\n\n      tuples.push(`(${values.join(',')})`);\n    }\n\n    // `options.updateOnDuplicate` is the list of field names to update if a duplicate key is hit during the insert.  It\n    // contains just the field names.  This option is _usually_ explicitly set by the corresponding query-interface\n    // upsert function.\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == ' ON CONFLICT DO UPDATE SET') { // postgres / sqlite\n        // If no conflict target columns were specified, use the primary key names from options.upsertKeys\n        const conflictKeys = options.upsertKeys.map(attr => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n\n        let whereClause = false;\n        if (options.conflictWhere) {\n          if (!this._dialect.supports.inserts.onConflictWhere) {\n            throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n          }\n\n          whereClause = this.whereQuery(options.conflictWhere, options);\n        }\n\n        // The Utils.joinSQLFragments later on will join this as it handles nested arrays.\n        onDuplicateKeyUpdate = [\n          'ON CONFLICT',\n          '(',\n          conflictKeys.join(','),\n          ')',\n          whereClause,\n          'DO UPDATE SET',\n          updateKeys.join(',')\n        ];\n      } else { // mysql / maria\n        if (options.conflictWhere) {\n          throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n        }\n\n        const valueKeys = options.updateOnDuplicate.map(attr => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(',')}`;\n      }\n    }\n\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : '';\n    const attributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : '';\n    let returning = '';\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);\n\n      returning += returnValues.returningFragment;\n    }\n\n    return Utils.joinSQLFragments([\n      'INSERT',\n      ignoreDuplicates,\n      'INTO',\n      this.quoteTable(tableName),\n      `(${attributes})`,\n      'VALUES',\n      tuples.join(','),\n      onDuplicateKeyUpdate,\n      onConflictDoNothing,\n      returning,\n      ';'\n    ]);\n  }\n\n  /**\n   * Returns an update query\n   *\n   * @param {string} tableName\n   * @param {object} attrValueHash\n   * @param {object} where A hash with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {object} options\n   * @param {object} attributes\n   *\n   * @private\n   */\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = '';\n    let tmpTable = ''; // tmpTable declaration for trigger\n    let suffix = '';\n\n    if (_.get(this, ['sequelize', 'options', 'dialectOptions', 'prependSearchPath']) || options.searchPath) {\n      // Not currently supported with search path (requires output of multiple queries)\n      options.bindParam = false;\n    }\n\n    const bindParam = options.bindParam === undefined ? this.bindParam(bind) : options.bindParam;\n\n    if (this._dialect.supports['LIMIT ON UPDATE'] && options.limit) {\n      if (!['mssql', 'db2', 'oracle'].includes(this.dialect)) {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      } else if (this.dialect === 'oracle') {\n        // This cannot be setted in where because rownum will be quoted\n        if (where && (where.length && where.length > 0 || Object.keys(where).length > 0)) {\n          // If we have a where clause, we add AND\n          suffix += ' AND ';\n        } else {\n          // No where clause, we add where\n          suffix += ' WHERE ';\n        }\n        suffix += `rownum <= ${this.escape(options.limit)} `;\n      }\n    }\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      suffix += returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || '';\n      outputFragment = returnValues.outputFragment || '';\n\n      // ensure that the return output is properly mapped to model fields.\n      if (!this._dialect.supports.returnValues.output && options.returning) {\n        options.mapToModel = true;\n      }\n    }\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] &&\n        modelAttributeMap[key].autoIncrement === true &&\n        !this._dialect.supports.autoIncrement.update) {\n        // not allowed to update identity column\n        continue;\n      }\n\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    const whereOptions = { ...options, bindParam };\n\n    if (values.length === 0) {\n      return '';\n    }\n\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    // Used by Postgres upsertQuery and calls to here with options.exception set to true\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n\n  /**\n   * Returns an update query using arithmetic operator\n   *\n   * @param {string} operator                    String with the arithmetic operator (e.g. '+' or '-')\n   * @param {string} tableName                   Name of the table\n   * @param {object} where                       A plain-object with conditions (e.g. {name: 'foo'}) OR an ID as integer\n   * @param {object} incrementAmountsByField     A plain-object with attribute-value-pairs\n   * @param {object} extraAttributesToBeUpdated  A plain-object with attribute-value-pairs\n   * @param {object} options\n   *\n   * @private\n   */\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n\n    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);\n\n    let outputFragment = '';\n    let returningFragment = '';\n\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(null, options);\n\n      outputFragment = returnValues.outputFragment;\n      returningFragment = returnValues.returningFragment;\n    }\n\n    const updateSetSqlFragments = [];\n    for (const field in incrementAmountsByField) {\n      const incrementAmount = incrementAmountsByField[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedAmount = this.escape(incrementAmount);\n      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);\n    }\n    for (const field in extraAttributesToBeUpdated) {\n      const newValue = extraAttributesToBeUpdated[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedValue = this.escape(newValue);\n      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'UPDATE',\n      this.quoteTable(tableName),\n      'SET',\n      updateSetSqlFragments.join(','),\n      outputFragment,\n      this.whereQuery(where),\n      returningFragment\n    ]);\n  }\n\n  /*\n    Returns an add index query.\n    Parameters:\n      - tableName -> Name of an existing table, possibly with schema.\n      - options:\n        - type: UNIQUE|FULLTEXT|SPATIAL\n        - name: The name of the index. Default is <table>_<attr1>_<attr2>\n        - fields: An array of attributes as string or as hash.\n                  If the attribute is a hash, it must have the following content:\n                  - name: The name of the attribute/column\n                  - length: An integer. Optional\n                  - order: 'ASC' or 'DESC'. Optional\n        - parser\n        - using\n        - operator\n        - concurrently: Pass CONCURRENT so other operations run while the index is created\n      - rawTablename, the name of the table, without schema. Used to create the name of the index\n   @private\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = undefined;\n    } else {\n      options.fields = attributes;\n    }\n\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === 'string') {\n      options.prefix = options.prefix.replace(/\\./g, '_');\n      options.prefix = options.prefix.replace(/(\"|')/g, '');\n    }\n\n    const fieldsSql = options.fields.map(field => {\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (typeof field === 'string') {\n        field = {\n          name: field\n        };\n      }\n      let result = '';\n\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n\n      result += this.quoteIdentifier(field.name);\n\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n\n      if (this._dialect.supports.index.operator) {\n        const operator = field.operator || options.operator;\n        if (operator) {\n          result += ` ${operator}`;\n        }\n      }\n\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n\n      return result;\n    });\n\n    if (!options.name) {\n      // Mostly for cases where addIndex is called directly by the user without an options object (for example in migrations)\n      // All calls that go through sequelize should already have a name\n      options = Utils.nameIndex(options, options.prefix);\n    }\n\n    options = Model._conformIndex(options);\n\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? 'CONCURRENTLY' : undefined;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        'ALTER TABLE',\n        tableName,\n        concurrently,\n        'ADD'\n      ];\n    } else {\n      ind = ['CREATE'];\n    }\n\n    ind = ind.concat(\n      options.unique ? 'UNIQUE' : '',\n      options.type, 'INDEX',\n      !this._dialect.supports.indexViaAlter ? concurrently : undefined,\n      this.quoteIdentifiers(options.name),\n      this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : '',\n      !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : undefined,\n      this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : '',\n      `(${fieldsSql.join(', ')})`,\n      this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : undefined,\n      this._dialect.supports.index.where && options.where ? options.where : undefined\n    );\n\n    return _.compact(ind).join(' ');\n  }\n\n  addConstraintQuery(tableName, options) {\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      tableName,\n      'ADD',\n      this.getConstraintSnippet(tableName, options || {}),\n      ';'\n    ]);\n  }\n\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n\n    const fieldsSql = options.fields.map(field => {\n      if (typeof field === 'string') {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n\n      return this.quoteIdentifier(field.name);\n    });\n\n    const fieldsSqlQuotedString = fieldsSql.join(', ');\n    const fieldsSqlString = fieldsSql.join('_');\n\n    switch (options.type.toUpperCase()) {\n      case 'UNIQUE':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case 'CHECK':\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case 'DEFAULT':\n        if (options.defaultValue === undefined) {\n          throw new Error('Default value must be specified for DEFAULT CONSTRAINT');\n        }\n\n        if (this._dialect.name !== 'mssql') {\n          throw new Error('Default constraints are supported only for MSSQL dialect.');\n        }\n\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case 'PRIMARY KEY':\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case 'FOREIGN KEY':\n        const references = options.references;\n        if (!references || !references.table || !(references.field || references.fields)) {\n          throw new Error('references object with table and field must be specified');\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const quotedReferences =\n          typeof references.field !== 'undefined'\n            ? this.quoteIdentifier(references.field)\n            : references.fields.map(f => this.quoteIdentifier(f)).join(', ');\n        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default: throw new Error(`${options.type} is invalid.`);\n    }\n\n    if (options.deferrable && ['UNIQUE', 'PRIMARY KEY', 'FOREIGN KEY'].includes(options.type.toUpperCase())) {\n      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;\n    }\n\n    return constraintSnippet;\n  }\n\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      tableName,\n      'DROP CONSTRAINT',\n      this.quoteIdentifiers(constraintName)\n    ]);\n  }\n\n  /*\n    Quote an object based on its type. This is a more general version of quoteIdentifiers\n    Strings: should proxy to quoteIdentifiers\n    Arrays:\n      * Expects array in the form: [<model> (optional), <model> (optional),... String, String (optional)]\n        Each <model> can be a model, or an object {model: Model, as: String}, matching include, or an\n        association object, or the name of an association.\n      * Zero or more models can be included in the array and are used to trace a path through the tree of\n        included nested associations. This produces the correct table name for the ORDER BY/GROUP BY SQL\n        and quotes it.\n      * If a single string is appended to end of array, it is quoted.\n        If two strings appended, the 1st string is quoted, the 2nd string unquoted.\n    Objects:\n      * If raw is set, that value should be returned verbatim, without quoting\n      * If fn is set, the string should start with the value of fn, starting paren, followed by\n        the values of cols (which is assumed to be an array), quoted and joined with ', ',\n        unless they are themselves objects\n      * If direction is set, should be prepended\n\n    Currently this function is only used for ordering / grouping columns and Sequelize.col(), but it could\n    potentially also be used for other places where we want to be able to call SQL functions (e.g. as default values)\n   @private\n  */\n  quote(collection, parent, connector) {\n    // init\n    const validOrderOptions = [\n      'ASC',\n      'DESC',\n      'ASC NULLS LAST',\n      'DESC NULLS LAST',\n      'ASC NULLS FIRST',\n      'DESC NULLS FIRST',\n      'NULLS FIRST',\n      'NULLS LAST'\n    ];\n\n    // default\n    connector = connector || '.';\n\n    // just quote as identifiers if string\n    if (typeof collection === 'string') {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      // iterate through the collection and mutate objects into associations\n      collection.forEach((item, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n\n        // set the previous as the parent when previous is undefined or the target of the association\n        if (!previous && parent !== undefined) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n\n        // if the previous item is a model, then attempt getting an association\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n\n          if (typeof item === 'function' && item.prototype instanceof Model) {\n            // set\n            model = item;\n          } else if (_.isPlainObject(item) && item.model && item.model.prototype instanceof Model) {\n            // set\n            model = item.model;\n            as = item.as;\n          }\n\n          if (model) {\n            // set the as to either the through name or the model name\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              // get from previous association\n              item = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              // get association from previous model\n              item = previousModel.getAssociationForAlias(model, as);\n\n              // attempt to use the model name if the item is still null\n              if (!item) {\n                item = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n\n            // make sure we have an association\n            if (!(item instanceof Association)) {\n              throw new Error(util.format('Unable to find a valid association for model, \\'%s\\'', model.name));\n            }\n          }\n        }\n\n        if (typeof item === 'string') {\n          // get order index\n          const orderIndex = validOrderOptions.indexOf(item.toUpperCase());\n\n          // see if this is an order\n          if (index > 0 && orderIndex !== -1) {\n            item = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            // only go down this path if we have preivous model and check only once\n            if (previousModel.associations !== undefined && previousModel.associations[item]) {\n              // convert the item to an association\n              item = previousModel.associations[item];\n            } else if (previousModel.rawAttributes !== undefined && previousModel.rawAttributes[item] && item !== previousModel.rawAttributes[item].field) {\n              // convert the item attribute from its alias\n              item = previousModel.rawAttributes[item].field;\n            } else if (\n              item.includes('.')\n              && previousModel.rawAttributes !== undefined\n            ) {\n              const itemSplit = item.split('.');\n\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                // just quote identifiers for now\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n\n                // get path\n                const path = itemSplit.slice(1);\n\n                // extract path\n                item = this.jsonPathExtractionQuery(identifier, path);\n\n                // literal because we don't want to append the model name when string\n                item = this.sequelize.literal(item);\n              }\n            }\n          }\n        }\n\n        collection[index] = item;\n      }, this);\n\n      // loop through array, adding table names of models to quoted\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === 'string' || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n\n      // start building sql\n      let sql = '';\n\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === 'string' && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n\n      // loop through everything past i and append to the sql\n      collection.slice(i).forEach(collectionItem => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      // simple objects with raw is no longer supported\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n\n  _initQuoteIdentifier() {\n    this._quoteIdentifier = this.quoteIdentifier;\n    this.quoteIdentifier = function(identifier, force) {\n      if (identifier === '*') return identifier;\n      return this._quoteIdentifier(identifier, force);\n    };\n  }\n\n  /**\n   * Adds quotes to identifier\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    throw new Error(`quoteIdentifier for Dialect \"${this.dialect}\" is not implemented`);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part.\n   *\n   * @param {string} identifiers\n   *\n   * @returns {string}\n   */\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes('.')) {\n      identifiers = identifiers.split('.');\n\n      const head = identifiers.slice(0, identifiers.length - 1).join('->');\n      const tail = identifiers[identifiers.length - 1];\n\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n\n    return this.quoteIdentifier(identifiers);\n  }\n\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n\n  /**\n   * Returns the alias token\n   *\n   * @returns {string}\n   */\n  getAliasToken() {\n    return 'AS';\n  }\n\n  /**\n   * Quote table name with optional alias and schema attribution\n   *\n   * @param {string|object}  param table string or object\n   * @param {string|boolean} alias alias name\n   *\n   * @returns {string}\n   */\n  quoteTable(param, alias) {\n    let table = '';\n\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || '.');\n        }\n\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n\n    if (alias) {\n      table += ` ${this.getAliasToken()} ${this.quoteIdentifier(alias)}`;\n    }\n\n    return table;\n  }\n\n  /*\n    Escape a value (e.g. a string, number or date)\n    @private\n  */\n  escape(value, field, options) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.stringify) {\n          // Users shouldn't have to worry about these args - just give them a function that takes a single arg\n          const simpleEscape = escVal => SqlString.escape(escVal, this.options.timezone, this.dialect);\n\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n\n          if (field.type.escape === false) {\n            // The data-type already did the required escaping\n            return value;\n          }\n        }\n      }\n    }\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n\n  bindParam(bind) {\n    return value => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n\n  /*\n    Returns a bind parameter representation of a value (e.g. a string, number or date)\n    @private\n  */\n  format(value, field, options, bindParam) {\n    options = options || {};\n\n    if (value !== null && value !== undefined) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error('Cannot pass SequelizeMethod as a bind parameter - use escape instead');\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n\n    return bindParam(value);\n  }\n\n  /*\n    Validate a value against a field specification\n    @private\n  */\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(\n            error.message,\n            'Validation error',\n            field.fieldName,\n            value,\n            null,\n            `${field.type.key} validator`\n          ));\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  isIdentifierQuoted(identifier) {\n    return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n  }\n\n  /**\n   * Generates an SQL query that extract JSON property of given path.\n   *\n   * @param   {string}               column   The JSON column\n   * @param   {string|Array<string>} [path]   The path to extract (optional)\n   * @param   {boolean}              [isJson] The value is JSON use alt symbols (optional)\n   * @returns {string}                        The generated sql query\n   * @private\n   */\n  jsonPathExtractionQuery(column, path, isJson) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column)\n      ? column\n      : this.quoteIdentifier(column);\n\n    switch (this.dialect) {\n      case 'mysql':\n      case 'mariadb':\n      case 'sqlite':\n        /**\n         * Non digit sub paths need to be quoted as ECMAScript identifiers\n         * https://bugs.mysql.com/bug.php?id=81896\n         */\n        if (this.dialect === 'mysql') {\n          paths = paths.map(subPath => {\n            return /\\D/.test(subPath)\n              ? Utils.addTicks(subPath, '\"')\n              : subPath;\n          });\n        }\n\n        pathStr = this.escape(['$']\n          .concat(paths)\n          .join('.')\n          .replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n        if (this.dialect === 'sqlite') {\n          return `json_extract(${quotedColumn},${pathStr})`;\n        }\n\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n\n      case 'postgres':\n        const join = isJson ? '#>' : '#>>';\n        pathStr = this.escape(`{${paths.join(',')}}`);\n        return `(${quotedColumn}${join}${pathStr})`;\n\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n\n  /*\n    Returns a query for selecting elements in the table <tableName>.\n    Options:\n      - attributes -> An array of attributes (e.g. ['name', 'birthday']). Default: *\n      - where -> A hash with conditions (e.g. {name: 'foo'})\n                 OR an ID as integer\n      - order -> e.g. 'id DESC'\n      - group\n      - limit -> The maximum count you want to get.\n      - offset -> An offset value to start from. Only useable with limit!\n   @private\n  */\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === undefined ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n\n    // Aliases can be passed through subqueries and we don't want to reset them\n    if (this.options.minifyAliases && !options.aliasesMapping) {\n      options.aliasesMapping = new Map();\n      options.aliasesByTable = {};\n      options.includeAliases = new Map();\n    }\n\n    // resolve table name options\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map(t => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(', ');\n\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        // Check if mainAttributes contain the primary key of the model either as a field or an aliased field\n        if (!attributes.main.some(attr => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : ['*']);\n\n    // If subquery, we add the mainAttributes to the subQuery and set the mainAttributes to select * from subquery\n    if (subQuery || options.groupedLimit) {\n      // We need primary keys\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n        }\n      }\n    }\n\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(''));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = { ...options.where };\n        let groupedLimitOrder,\n          whereKey,\n          include,\n          groupedTableName = mainTable.as;\n\n        if (typeof options.groupedLimit.on === 'string') {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          // BTM includes needs to join the through table on to check ID\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false, // The UNION'ed query may contain duplicates, but each sub-query cannot\n              required: true,\n              where: {\n                [Op.placeholder]: true,\n                ...options.groupedLimit.through && options.groupedLimit.through.where\n              }\n            }],\n            model\n          });\n\n          // Make sure attributes from the join table are mapped back to models\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n\n          if (Array.isArray(options.order)) {\n            // We need to make sure the order by attributes are available to the parent query\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n\n              // We don't want to prepend model name when we alias the attributes, so quote them here\n              alias = this.sequelize.literal(this.quote(alias));\n\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          // Ordering is handled by the subqueries, so ordering the UNION'ed result is not needed\n          groupedLimitOrder = options.order;\n\n          // For the Oracle dialect, the result of a select is a set, not a sequence, and so is the result of UNION.\n          // So the top level ORDER BY is required\n          if (!this._dialect.supports.topLevelOrderByRequired) {\n            delete options.order;\n          }\n          where[Op.placeholder] = true;\n        }\n\n        // Caching the base query and splicing the where part into it is consistently > twice\n        // as fast than generating from scratch each time for values.length >= 5\n        const baseQuery = `SELECT * FROM (${this.selectQuery(\n          tableName,\n          {\n            attributes: options.attributes,\n            offset: options.offset,\n            limit: options.groupedLimit.limit,\n            order: groupedLimitOrder,\n            aliasesMapping: options.aliasesMapping,\n            aliasesByTable: options.aliasesByTable,\n            where,\n            include,\n            model\n          },\n          model\n        ).replace(/;$/, '')}) ${this.getAliasToken()} sub`; // Every derived table must have its own alias\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${\n          options.groupedLimit.values.map(value => {\n            let groupWhere;\n            if (whereKey) {\n              groupWhere = {\n                [whereKey]: value\n              };\n            }\n            if (include) {\n              groupWhere = {\n                [options.groupedLimit.on.foreignIdentifierField]: value\n              };\n            }\n\n            return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n          }).join(\n            this._dialect.supports['UNION ALL'] ? ' UNION ALL ' : ' UNION '\n          )\n        })`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n\n      mainQueryItems.push(mainJoinQueries.join(''));\n    }\n\n    // Add WHERE to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'where') && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          // Walk the main query to update all selects\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith('SELECT')) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n\n    // Add GROUP BY to sub or main query\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map(t => this.aliasGrouping(t, model, mainTable.as, options)).join(', ') : this.aliasGrouping(options.group, model, mainTable.as, options);\n\n      if (subQuery && options.group) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else if (options.group) {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n\n    // Add HAVING to sub or main query\n    if (Object.prototype.hasOwnProperty.call(options, 'having')) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n\n    // Add ORDER to sub or main query\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(', ')}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(', ')}`);\n      }\n    }\n\n    // Add LIMIT, OFFSET to sub or main query\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n\n    if (subQuery) {\n      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });\n      query = `SELECT ${attributes.main.join(', ')} FROM (${subQueryItems.join('')}) ${this.getAliasToken()} ${mainTable.as}${mainJoinQueries.join('')}${mainQueryItems.join('')}`;\n    } else {\n      query = mainQueryItems.join('');\n    }\n\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === 'object') {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && ['KEY SHARE', 'NO KEY UPDATE'].includes(lock)) {\n        query += ` FOR ${lock}`;\n      } else if (lock === 'SHARE') {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += ' FOR UPDATE';\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += ' SKIP LOCKED';\n      }\n    }\n\n    return `${query};`;\n  }\n\n  aliasGrouping(field, model, tableName, options) {\n    const src = Array.isArray(field) ? field[0] : field;\n\n    return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n  }\n\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map(attr => {\n      let addTable = true;\n\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (this.options.attributeBehavior === 'escape' || !attr[0].includes('(') && !attr[0].includes(')')) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else if (this.options.attributeBehavior !== 'unsafe-legacy') {\n          throw new Error(`Attributes cannot include parentheses in Sequelize 6:\nIn order to fix the vulnerability CVE-2023-22578, we had to remove support for treating attributes as raw SQL if they included parentheses.\nSequelize 7 escapes all attributes, even if they include parentheses.\nFor Sequelize 6, because we're introducing this change in a minor release, we've opted for throwing an error instead of silently escaping the attribute as a way to warn you about this change.\n\nHere is what you can do to fix this error:\n- Wrap the attribute in a literal() call. This will make Sequelize treat it as raw SQL.\n- Set the \"attributeBehavior\" sequelize option to \"escape\" to make Sequelize escape the attribute, like in Sequelize v7. We highly recommend this option.\n- Set the \"attributeBehavior\" sequelize option to \"unsafe-legacy\" to make Sequelize escape the attribute, like in Sequelize v5.\n\nWe sincerely apologize for the inconvenience this may cause you. You can find more information on the following threads:\nhttps://github.com/sequelize/sequelize/security/advisories/GHSA-f598-mfpv-gmfx\nhttps://github.com/sequelize/sequelize/discussions/15694`);\n        }\n\n        let alias = attr[1];\n\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, mainTableAs, options);\n        }\n\n        attr = [attr[0], this.quoteIdentifier(alias)].join(' AS ');\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"')\n          ? this.quoteAttribute(attr, options.model)\n          : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && (!attr.includes('.') || options.dotNotation) && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n\n      return attr;\n    });\n  }\n\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n\n    topLevelInfo.options.keysEscaped = true;\n\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n\n    // includeIgnoreAttributes is used by aggregate functions\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapFinderOptions(include, include.model);\n\n      const includeAttributes = include.attributes.map(attr => {\n        let attrAs = attr;\n        let verbatim = false;\n\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (\n            attr[0] instanceof Utils.Literal ||\n            attr[0] instanceof Utils.Cast ||\n            attr[0] instanceof Utils.Fn\n          )) {\n            verbatim = true;\n          }\n\n          attr = attr.map(attr => attr instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr) : attr);\n\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val; // We trust the user to rename the field correctly\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\n            'Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. ' +\n            'This means the attribute will not be added to the returned instance'\n          );\n        }\n\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, '')})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else if (/json_value\\(/.test(attr)) {\n          prefix = attr.replace(/json_value\\(/i, `json_value(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        let alias = `${includeAs.externalAs}.${attrAs}`;\n\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n        }\n\n        return Utils.joinSQLFragments([\n          prefix,\n          'AS',\n          this.quoteIdentifier(alias, true)\n        ]);\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n\n    //through\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n\n    // handle possible new attributes created in join\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        // if the child is a sub query we just give it to the\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(''));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(''));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join('')} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(''));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(''));\n    }\n\n    return {\n      mainQuery: joinQueries.mainQuery.join(''),\n      subQuery: joinQueries.subQuery.join(''),\n      attributes\n    };\n  }\n\n  _getMinifiedAlias(alias, tableName, options) {\n    // We do not want to re-alias in case of a subquery\n    if (options.aliasesByTable[`${tableName}${alias}`]) {\n      return options.aliasesByTable[`${tableName}${alias}`];\n    }\n\n    // Do not alias custom suquery_orders\n    if (alias.match(/subquery_order_[0-9]/)) {\n      return alias;\n    }\n\n    const minifiedAlias = `_${options.aliasesMapping.size}`;\n\n    options.aliasesMapping.set(minifiedAlias, alias);\n    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;\n\n    return minifiedAlias;\n  }\n\n  _getAliasForField(tableName, field, options) {\n    if (this.options.minifyAliases) {\n      if (options.aliasesByTable[`${tableName}${field}`]) {\n        return options.aliasesByTable[`${tableName}${field}`];\n      }\n    }\n    return null;\n  }\n\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    /* Attributes for the left side */\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ?\n      association.identifier :\n      association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ?\n      association.identifierField :\n      left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    /* Attributes for the right side */\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ?\n      right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field :\n      association.identifierField;\n    let asRight = include.as;\n\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n\n    if (!asLeft) asLeft = parent.as || parent.model.name;\n    else asRight = `${asLeft}->${asRight}`;\n\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n    const subqueryAttributes = [];\n\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        // The main model attributes is not aliased to a prefix\n        const tableName = this.quoteTable(parent.as || parent.model.name);\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;\n\n        if (topLevelInfo.subQuery) {\n          const dbIdentifier = `${tableName}.${this.quoteIdentifier(fieldLeft)}`;\n          subqueryAttributes.push(dbIdentifier !== joinOn ? `${dbIdentifier} AS ${this.quoteIdentifier(attrLeft)}` : dbIdentifier);\n        }\n      } else {\n        const joinSource = `${asLeft.replace(/->/g, '.')}.${attrLeft}`;\n\n        // Check for potential aliased JOIN condition\n        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n      }\n    }\n\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n\n    this.aliasAs(asRight, topLevelInfo);\n\n    return {\n      join: include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN',\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: subqueryAttributes\n      }\n    };\n  }\n\n  /**\n   * Returns the SQL fragments to handle returning the attributes from an insert/update query.\n   *\n   * @param  {object} modelAttributes An object with the model attributes.\n   * @param  {object} options         An object with options.\n   *\n   * @private\n   */\n  generateReturnValues(modelAttributes, options) {\n    const returnFields = [];\n    const returnTypes = [];\n    let outputFragment = '';\n    let returningFragment = '';\n    let tmpTable = '';\n\n    if (Array.isArray(options.returning)) {\n      returnFields.push(...options.returning.map(field => this.quoteIdentifier(field)));\n    } else if (modelAttributes) {\n      _.each(modelAttributes, attribute => {\n        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n          returnFields.push(this.quoteIdentifier(attribute.field));\n          returnTypes.push(attribute.type);\n        }\n      });\n    }\n\n    if (_.isEmpty(returnFields)) {\n      returnFields.push('*');\n    }\n\n    if (this._dialect.supports.returnValues.returning) {\n      returningFragment = ` RETURNING ${returnFields.join(',')}`;\n    } else if (this._dialect.supports.returnIntoValues) {\n      returningFragment = ` RETURNING ${returnFields.join(',')} INTO `;\n    } else if (this._dialect.supports.returnValues.output) {\n      outputFragment = ` OUTPUT ${returnFields.map(field => `INSERTED.${field}`).join(',')}`;\n\n      //To capture output rows when there is a trigger on MSSQL DB\n      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);\n\n        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(',')}); `;\n        outputFragment += ' INTO @tmp';\n        returningFragment = '; SELECT * FROM @tmp';\n      }\n    }\n\n    return { outputFragment, returnFields, returnTypes, returningFragment, tmpTable };\n  }\n\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map(attr => {\n      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;\n\n      if (this.options.minifyAliases) {\n        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n      }\n\n      return Utils.joinSQLFragments([\n        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,\n        'AS',\n        this.quoteIdentifier(alias)\n      ]);\n    });\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n\n    const joinType = include.required ? 'INNER JOIN' : include.right && this._dialect.supports['RIGHT JOIN'] ? 'RIGHT OUTER JOIN' : 'LEFT OUTER JOIN';\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      // Through includes are always hasMany, so we need to add the attributes to the mainAttributes no matter what (Real join will never be executed in subquery)\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n\n    // Figure out if we need to use field or attribute\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n\n    // Filter statement for left side of through\n    // Used by both join and subquery where\n    // If parent include was in a subquery need to join on the aliased attribute\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;\n\n      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;\n    } else {\n      // If we are minifying aliases and our JOIN target has been minified, we need to use the alias instead of the original column name\n      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n\n    // Filter statement for right side of through\n    // Used by both join and subquery where\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n\n    this.aliasAs(includeAs.internalAs, topLevelInfo);\n\n    // Generate a wrapped join so that the through table join can be dependent on the target join\n    joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n    if (throughWhere) {\n      joinBody += ` AND ${throughWhere}`;\n    }\n    joinBody += ')';\n    joinCondition = sourceJoinOn;\n\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n\n  /*\n   * Appends to the alias cache if the alias 64+ characters long and minifyAliases is true.\n   * This helps to avoid character limits in PostgreSQL.\n   */\n  aliasAs(as, topLevelInfo) {\n    if (this.options.minifyAliases && as.length >= 64) {\n      const alias = `%${topLevelInfo.options.includeAliases.size}`;\n\n      topLevelInfo.options.includeAliases.set(alias, as);\n    }\n  }\n\n  /*\n   * Generates subQueryFilter - a select nested in the where clause of the subQuery.\n   * For a given include a query is generated that contains all the way from the subQuery\n   * table to the include table plus everything that's in required transitive closure of the\n   * given include.\n   */\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n\n    while ((parent = parent.parent)) { // eslint-disable-line\n      if (parent.parent && !parent.required) {\n        return; // only generate subQueryFilter if all the parents of this include are required\n      }\n\n      if (parent.subQueryFilter) {\n        // the include is already handled as this parent has the include on its required closure\n        // skip to prevent duplicate subQueryFilter\n        return;\n      }\n\n      nestedIncludes = [{ ...child, include: nestedIncludes, attributes: [] }];\n      child = parent;\n    }\n\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = undefined;\n\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(' = ')),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === 'BelongsTo';\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(' = ');\n\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      '(',\n      query.replace(/;$/, ''),\n      ')',\n      'IS NOT NULL'\n    ].join(' '));\n  }\n\n  /*\n   * For a given include hierarchy creates a copy of it where only the required includes\n   * are preserved.\n   */\n  _getRequiredClosure(include) {\n    const copy = { ...include, attributes: [], include: [] };\n\n    if (Array.isArray(include.include)) {\n      copy.include = include.include\n        .filter(i => i.required)\n        .map(inc => this._getRequiredClosure(inc));\n    }\n\n    return copy;\n  }\n\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n\n        // wrap if not array\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n\n        if (\n          subQuery\n          && Array.isArray(order)\n          && order[0]\n          && !(order[0] instanceof Association)\n          && !(typeof order[0] === 'function' && order[0].prototype instanceof Model)\n          && !(typeof order[0].model === 'function' && order[0].model.prototype instanceof Model)\n          && !(typeof order[0] === 'string' && model && model.associations !== undefined && model.associations[order[0]])\n        ) {\n          const field = model.rawAttributes[order[0]] ? model.rawAttributes[order[0]].field : order[0];\n          const subQueryAlias = this._getAliasForField(this.quoteIdentifier(model.name), field, options);\n\n          let parent = null;\n          let orderToQuote = [];\n\n          // we need to ensure that the parent is null if we use the subquery alias, else we'll get an exception since\n          // \"model_name\".\"alias\" doesn't exist - only \"alias\" does. we also need to ensure that we preserve order direction\n          // by pushing order[1] to the subQueryOrder as well - in case it doesn't exist, we want to push \"ASC\"\n          if (subQueryAlias === null) {\n            orderToQuote = order;\n            parent = model;\n          } else {\n            orderToQuote = [subQueryAlias, order.length > 1 ? order[1] : 'ASC'];\n            parent = null;\n          }\n\n          subQueryOrder.push(this.quote(orderToQuote, parent, '->'));\n        }\n\n        // Handle case where renamed attributes are used to order by,\n        // see https://github.com/sequelize/sequelize/issues/8739\n        // need to check if either of the attribute options match the order\n        if (options.attributes && model) {\n          const aliasedAttribute = options.attributes.find(attr => Array.isArray(attr)\n              && attr[1]\n              && (attr[0] === order[0] || attr[1] === order[0]));\n\n          if (aliasedAttribute) {\n            const modelName = this.quoteIdentifier(model.name);\n            const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n\n            order[0] = new Utils.Col(alias || aliasedAttribute[1]);\n          }\n        }\n\n        mainQueryOrder.push(this.quote(order, model, '->'));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, '->');\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error('Order must be type of array or instance of a valid sequelize method.');\n    }\n\n    return { mainQueryOrder, subQueryOrder };\n  }\n\n  _throwOnEmptyAttributes(attributes, extraInfo = {}) {\n    if (attributes.length > 0) return;\n    const asPart = extraInfo.as && `as ${extraInfo.as}` || '';\n    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || '';\n    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;\n    throw new sequelizeError.QueryError(message.replace(/ +/g, ' '));\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    let fragment = `SELECT ${attributes.join(', ')} FROM ${tables}`;\n\n    if (mainTableAs) {\n      fragment += ` ${this.getAliasToken()} ${mainTableAs}`;\n    }\n\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map(indexName => this.quoteIdentifiers(indexName)).join(',')})`;\n        }\n      }\n    }\n\n    return fragment;\n  }\n\n  /**\n   * Returns an SQL fragment for adding result constraints.\n   *\n   * @param  {object} options An object with selectQuery options.\n   * @returns {string}         The generated sql query.\n   * @private\n   */\n  addLimitAndOffset(options) {\n    let fragment = '';\n\n    /* eslint-disable */\n    if (options.offset != null && options.limit == null) {\n      fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + 10000000000000;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += ' LIMIT ' + this.escape(options.offset) + ', ' + this.escape(options.limit);\n      } else {\n        fragment += ' LIMIT ' + this.escape(options.limit);\n      }\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n\n        if (value === 'NULL') {\n          if (smth.comparator === '=') {\n            smth.comparator = 'IS';\n          }\n          if (smth.comparator === '!=') {\n            smth.comparator = 'IS NOT';\n          }\n        }\n\n        return [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {\n        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;\n      } else if (typeof value === 'boolean') {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n\n      if (value === 'NULL') {\n        if (smth.comparator === '=') {\n          smth.comparator = 'IS';\n        }\n        if (smth.comparator === '!=') {\n          smth.comparator = 'IS NOT';\n        }\n      }\n\n      return [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${\n        smth.args.map(arg => {\n          if (arg instanceof Utils.SequelizeMethod) {\n            return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n          }\n          if (_.isPlainObject(arg)) {\n            return this.whereItemsQuery(arg);\n          }\n          return this.escape(typeof arg === 'string' ? arg.replace(/\\$/g, '$$$') : arg);\n        }).join(', ')\n      })`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error('Cannot call Sequelize.col() with array outside of order / group clause');\n      }\n      if (smth.col.startsWith('*')) {\n        return '*';\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return '';\n  }\n\n  whereItemsQuery(where, options, binding) {\n    if (\n      where === null ||\n      where === undefined ||\n      Utils.getComplexSize(where) === 0\n    ) {\n      // NO OP\n      return '';\n    }\n\n    if (typeof where === 'string') {\n      throw new Error('Support for `{where: \\'raw query\\'}` has been removed.');\n    }\n\n    const items = [];\n\n    binding = binding || 'AND';\n    if (binding[0] !== ' ') binding = ` ${binding} `;\n\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach(prop => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(undefined, where, options));\n    }\n\n    return items.length && items.filter(item => item && item.length).join(binding) || '';\n  }\n\n  whereItemQuery(key, value, options = {}) {\n    if (value === undefined) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n\n    if (typeof key === 'string' && key.includes('.') && options.model) {\n      const keyParts = key.split('.');\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field.field || keyParts[0], tmp, { field, ...options });\n      }\n    }\n\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n\n    if (key === undefined) {\n      if (typeof value === 'string') {\n        return value;\n      }\n\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n\n    if (value === null) {\n      const opValue = options.bindParam ? 'NULL' : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.is], options.prefix);\n    }\n\n    if (!value) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (value instanceof Utils.SequelizeMethod && !(key !== undefined && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n\n    // Convert where: [] to Op.and if possible, else treat as literal/replacements\n    if (key === undefined && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error('Support for literal replacements in the `where` object has been removed.');\n      }\n    }\n\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n\n\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    // If multiple keys we combine the different logic conditions\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n\n    if (key === Op.placeholder) {\n      const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue, this.OperatorMap[Op.eq], options.prefix);\n    }\n\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n\n  // OR/AND/NOT grouping logic\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? 'NOT ' : '';\n\n    if (Array.isArray(value)) {\n      value = value.map(item => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter(item => item && item.length);\n\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    // Op.or: [] should return no data.\n    // Op.not of no restriction should also return no data\n    if ((key === Op.or || key === Op.not) && !value) {\n      return '0 = 1';\n    }\n\n    return value ? `${outerBinding}(${value})` : undefined;\n  }\n\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map(prop => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map(item => this.whereItemQuery(key, item, options));\n    }\n\n    value = value.filter(item => item && item.length);\n\n    return value.length ? `(${value.join(binding)})` : undefined;\n  }\n\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n\n    Utils.getOperators(value).forEach(op => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, { ...options, json: false }));\n    });\n\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n\n    if (path[path.length - 1].includes('::')) {\n      const tmp = path[path.length - 1].split('::');\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n\n    let pathKey = this.jsonPathExtractionQuery(baseKey, path);\n\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach(op => {\n        const value = this._toJSONValue(item[op]);\n        let isJson = false;\n        if (typeof value === 'string' && op === Op.contains) {\n          try {\n            JSON.stringify(value);\n            isJson = true;\n          } catch (e) {\n            // failed to parse, is not json so isJson remains false\n          }\n        }\n        pathKey = this.jsonPathExtractionQuery(baseKey, path, isJson);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n\n      return;\n    }\n\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n\n  _toJSONValue(value) {\n    return value;\n  }\n\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n\n    return new Utils.Literal(key);\n  }\n\n  _getJsonCast(value) {\n    if (typeof value === 'number') {\n      return 'double precision';\n    }\n    if (value instanceof Date) {\n      return 'timestamptz';\n    }\n    if (typeof value === 'boolean') {\n      return 'boolean';\n    }\n    return;\n  }\n\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === undefined) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split('.');\n\n      if (key.length > 2) {\n        key = [\n          // join the tables by -> to match out internal namings\n          key.slice(0, -1).join('->'),\n          key[key.length - 1]\n        ];\n      }\n\n      return key.map(identifier => this.quoteIdentifier(identifier)).join('.');\n    }\n\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join('.');\n      }\n\n      return [this.quoteTable(prefix), key].join('.');\n    }\n\n    return key;\n  }\n\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map(item => this.escape(item, field)).join(', ')})`, comparator, options.prefix);\n        }\n\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, '(NULL)', comparator, options.prefix);\n        }\n\n        return '';\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map(item => `(${this.escape(item)})`).join(', ')})`, comparator, options.prefix);\n        }\n\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error('The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.');\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split('.');\n\n        if (value.length > 2) {\n          value = [\n            // join the tables by -> to match out internal namings\n            value.slice(0, -1).join('->'),\n            value[value.length - 1]\n          ];\n        }\n\n        return this._joinKeyValue(key, value.map(identifier => this.quoteIdentifier(identifier)).join('.'), comparator, options.prefix);\n      case Op.startsWith:\n      case Op.endsWith:\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n\n        if (value instanceof Utils.Literal) {\n          value = value.val;\n        }\n\n        let pattern = `${value}%`;\n\n        if (prop === Op.endsWith) pattern = `%${value}`;\n        if (prop === Op.substring) pattern = `%${value}%`;\n\n        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);\n    }\n\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n\n  /*\n    Takes something and transforms it into values of a where condition.\n   @private\n  */\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n\n    options = options || {};\n\n    if (prepend === undefined) {\n      prepend = true;\n    }\n\n    if (smth && smth instanceof Utils.SequelizeMethod) { // Checking a property is cheaper than a lot of instanceof calls\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === 'number' || typeof smth === 'bigint') {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n\n      if (primaryKeys.length > 0) {\n        // Since we're just a number, assume only the first key\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = 'id';\n      }\n\n      where[primaryKeys] = smth;\n\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === 'string') {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0) return '1=1';\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error('Support for literal replacements in the `where` object has been removed.');\n    }\n    if (smth == null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n\n    throw new Error(`Unsupported where option value: ${util.inspect(smth)}. Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option.`);\n  }\n\n  // A recursive parser for nested where conditions\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key))); // Recursively parse objects\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n\n  booleanValue(value) {\n    return value;\n  }\n\n  /**\n   * Returns the authenticate test query string\n   */\n  authTestQuery() {\n    return 'SELECT 1+1 AS result';\n  }\n}\n\nObject.assign(QueryGenerator.prototype, require('./query-generator/operators'));\nObject.assign(QueryGenerator.prototype, require('./query-generator/transaction'));\n\nmodule.exports = QueryGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}