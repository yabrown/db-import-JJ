{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return a;\n};\nvar __markAsModule = function __markAsModule(target) {\n  return __defProp(target, \"__esModule\", {\n    value: true\n  });\n};\nvar __export = function __export(target, all) {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n__export(exports, {\n  OracleQueryGenerator: function OracleQueryGenerator() {\n    return _OracleQueryGenerator;\n  }\n});\nvar Utils = require(\"../../utils\");\nvar DataTypes = require(\"../../data-types\");\nvar AbstractQueryGenerator = require(\"../abstract/query-generator\");\nvar _ = require(\"lodash\");\nvar util = require(\"util\");\nvar Transaction = require(\"../../transaction\");\nvar ORACLE_RESERVED_WORDS = [\"ACCESS\", \"ADD\", \"ALL\", \"ALTER\", \"AND\", \"ANY\", \"ARRAYLEN\", \"AS\", \"ASC\", \"AUDIT\", \"BETWEEN\", \"BY\", \"CHAR\", \"CHECK\", \"CLUSTER\", \"COLUMN\", \"COMMENT\", \"COMPRESS\", \"CONNECT\", \"CREATE\", \"CURRENT\", \"DATE\", \"DECIMAL\", \"DEFAULT\", \"DELETE\", \"DESC\", \"DISTINCT\", \"DROP\", \"ELSE\", \"EXCLUSIVE\", \"EXISTS\", \"FILE\", \"FLOAT\", \"FOR\", \"FROM\", \"GRANT\", \"GROUP\", \"HAVING\", \"IDENTIFIED\", \"IMMEDIATE\", \"IN\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"INSERT\", \"INTEGER\", \"INTERSECT\", \"INTO\", \"IS\", \"LEVEL\", \"LIKE\", \"LOCK\", \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"MODIFY\", \"NOAUDIT\", \"NOCOMPRESS\", \"NOT\", \"NOTFOUND\", \"NOWAIT\", \"NULL\", \"NUMBER\", \"OF\", \"OFFLINE\", \"ON\", \"ONLINE\", \"OPTION\", \"OR\", \"ORDER\", \"PCTFREE\", \"PRIOR\", \"PRIVILEGES\", \"PUBLIC\", \"RAW\", \"RENAME\", \"RESOURCE\", \"REVOKE\", \"ROW\", \"ROWID\", \"ROWLABEL\", \"ROWNUM\", \"ROWS\", \"SELECT\", \"SESSION\", \"SET\", \"SHARE\", \"SIZE\", \"SMALLINT\", \"SQLBUF\", \"START\", \"SUCCESSFUL\", \"SYNONYM\", \"SYSDATE\", \"TABLE\", \"THEN\", \"TO\", \"TRIGGER\", \"UID\", \"UNION\", \"UNIQUE\", \"UPDATE\", \"USER\", \"VALIDATE\", \"VALUES\", \"VARCHAR\", \"VARCHAR2\", \"VIEW\", \"WHENEVER\", \"WHERE\", \"WITH\"];\nvar JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nvar JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nvar TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nvar _OracleQueryGenerator = /*#__PURE__*/function (_AbstractQueryGenerat) {\n  _inherits(_OracleQueryGenerator, _AbstractQueryGenerat);\n  var _super = _createSuper(_OracleQueryGenerator);\n  function _OracleQueryGenerator(options) {\n    _classCallCheck(this, _OracleQueryGenerator);\n    return _super.call(this, options);\n  }\n  _createClass(_OracleQueryGenerator, [{\n    key: \"getCatalogName\",\n    value: function getCatalogName(value) {\n      if (value) {\n        if (this.options.quoteIdentifiers === false) {\n          var quotedValue = this.quoteIdentifier(value);\n          if (quotedValue === value) {\n            value = value.toUpperCase();\n          }\n        }\n      }\n      return value;\n    }\n  }, {\n    key: \"getSchemaNameAndTableName\",\n    value: function getSchemaNameAndTableName(table) {\n      var tableName = this.getCatalogName(table.tableName || table);\n      var schemaName = this.getCatalogName(table.schema);\n      return [tableName, schemaName];\n    }\n  }, {\n    key: \"createSchema\",\n    value: function createSchema(schema) {\n      var quotedSchema = this.quoteIdentifier(schema);\n      return [\"DECLARE\", \"USER_FOUND BOOLEAN := FALSE;\", \"BEGIN\", \" BEGIN\", \"   EXECUTE IMMEDIATE \", this.escape(\"CREATE USER \".concat(quotedSchema, \" IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS\")), \";\", \"   EXCEPTION WHEN OTHERS THEN\", \"     IF SQLCODE != -1920 THEN\", \"       RAISE;\", \"     ELSE\", \"       USER_FOUND := TRUE;\", \"     END IF;\", \" END;\", \" IF NOT USER_FOUND THEN\", \"    EXECUTE IMMEDIATE \", this.escape(\"GRANT \\\"CONNECT\\\" TO \".concat(quotedSchema)), \";\", \"    EXECUTE IMMEDIATE \", this.escape(\"GRANT CREATE TABLE TO \".concat(quotedSchema)), \";\", \"    EXECUTE IMMEDIATE \", this.escape(\"GRANT CREATE VIEW TO \".concat(quotedSchema)), \";\", \"    EXECUTE IMMEDIATE \", this.escape(\"GRANT CREATE ANY TRIGGER TO \".concat(quotedSchema)), \";\", \"    EXECUTE IMMEDIATE \", this.escape(\"GRANT CREATE ANY PROCEDURE TO \".concat(quotedSchema)), \";\", \"    EXECUTE IMMEDIATE \", this.escape(\"GRANT CREATE SEQUENCE TO \".concat(quotedSchema)), \";\", \"    EXECUTE IMMEDIATE \", this.escape(\"GRANT CREATE SYNONYM TO \".concat(quotedSchema)), \";\", \"    EXECUTE IMMEDIATE \", this.escape(\"ALTER USER \".concat(quotedSchema, \" QUOTA UNLIMITED ON USERS\")), \";\", \" END IF;\", \"END;\"].join(\" \");\n    }\n  }, {\n    key: \"showSchemasQuery\",\n    value: function showSchemasQuery() {\n      return \"SELECT USERNAME AS \\\"schema_name\\\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user\";\n    }\n  }, {\n    key: \"dropSchema\",\n    value: function dropSchema(schema) {\n      return [\"BEGIN\", \"EXECUTE IMMEDIATE \", this.escape(\"DROP USER \".concat(this.quoteTable(schema), \" CASCADE\")), \";\", \"EXCEPTION WHEN OTHERS THEN\", \"  IF SQLCODE != -1918 THEN\", \"    RAISE;\", \"  END IF;\", \"END;\"].join(\" \");\n    }\n  }, {\n    key: \"versionQuery\",\n    value: function versionQuery() {\n      return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n    }\n  }, {\n    key: \"createTableQuery\",\n    value: function createTableQuery(tableName, attributes, options) {\n      var _this = this;\n      var primaryKeys = [],\n        foreignKeys = Object.create(null),\n        attrStr = [],\n        checkStr = [];\n      var values = {\n        table: this.quoteTable(tableName)\n      };\n      for (var attr in attributes) {\n        if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n        var dataType = attributes[attr];\n        attr = this.quoteIdentifier(attr);\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (dataType.includes(\"REFERENCES\")) {\n            var match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(\"\".concat(attr, \" \").concat(match[1].replace(/PRIMARY KEY/, \"\")));\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(\"\".concat(attr, \" \").concat(dataType.replace(/PRIMARY KEY/, \"\").trim()));\n          }\n        } else if (dataType.includes(\"REFERENCES\")) {\n          var _match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(\"\".concat(attr, \" \").concat(_match[1]));\n          foreignKeys[attr] = _match[2];\n        } else {\n          attrStr.push(\"\".concat(attr, \" \").concat(dataType));\n        }\n      }\n      values[\"attributes\"] = attrStr.join(\", \");\n      var pkString = primaryKeys.map(function (pk) {\n        return _this.quoteIdentifier(pk);\n      }).join(\", \");\n      if (pkString.length > 0) {\n        values.attributes += \",PRIMARY KEY (\".concat(pkString, \")\");\n      }\n      for (var fkey in foreignKeys) {\n        if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue;\n        if (foreignKeys[fkey].indexOf(\"ON DELETE NO ACTION\") > -1) {\n          foreignKeys[fkey] = foreignKeys[fkey].replace(\"ON DELETE NO ACTION\", \"\");\n        }\n        values.attributes += \",FOREIGN KEY (\".concat(this.quoteIdentifier(fkey), \") \").concat(foreignKeys[fkey]);\n      }\n      if (checkStr.length > 0) {\n        values.attributes += \", \".concat(checkStr.join(\", \"));\n      }\n      if (options && options.indexes && options.indexes.length > 0) {\n        var idxToDelete = [];\n        options.indexes.forEach(function (index, idx) {\n          if (\"unique\" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n            var fields = index.fields.map(function (field) {\n              if (typeof field === \"string\") {\n                return field;\n              }\n              return field.attribute;\n            });\n            var canContinue = true;\n            if (options.uniqueKeys) {\n              var keys = Object.keys(options.uniqueKeys);\n              for (var fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n                var currUnique = options.uniqueKeys[keys[fieldIdx]];\n                if (currUnique.fields.length === fields.length) {\n                  for (var i = 0; i < currUnique.fields.length; i++) {\n                    var field = currUnique.fields[i];\n                    if (_.includes(fields, field)) {\n                      canContinue = false;\n                    } else {\n                      canContinue = true;\n                      break;\n                    }\n                  }\n                }\n              }\n              if (canContinue) {\n                var indexName = \"name\" in index ? index.name : \"\";\n                var constraintToAdd = {\n                  name: indexName,\n                  fields: fields\n                };\n                if (!(\"uniqueKeys\" in options)) {\n                  options.uniqueKeys = {};\n                }\n                options.uniqueKeys[indexName] = constraintToAdd;\n                idxToDelete.push(idx);\n              } else {\n                idxToDelete.push(idx);\n              }\n            }\n          }\n        });\n        idxToDelete.forEach(function (idx) {\n          options.indexes.splice(idx, 1);\n        });\n      }\n      if (options && !!options.uniqueKeys) {\n        _.each(options.uniqueKeys, function (columns, indexName) {\n          var canBeUniq = false;\n          primaryKeys.forEach(function (primaryKey) {\n            primaryKey = primaryKey.replace(/\"/g, \"\");\n            if (!_.includes(columns.fields, primaryKey)) {\n              canBeUniq = true;\n            }\n          });\n          columns.fields.forEach(function (field) {\n            var currField = \"\";\n            if (!_.isString(field)) {\n              currField = field.attribute.replace(/[.,\"\\s]/g, \"\");\n            } else {\n              currField = field.replace(/[.,\"\\s]/g, \"\");\n            }\n            if (currField in attributes) {\n              if (attributes[currField].toUpperCase().indexOf(\"UNIQUE\") > -1 && canBeUniq) {\n                var attrToReplace = attributes[currField].replace(\"UNIQUE\", \"\");\n                values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n              }\n            }\n          });\n          if (canBeUniq) {\n            var index = options.uniqueKeys[columns.name];\n            delete options.uniqueKeys[columns.name];\n            indexName = indexName.replace(/[.,\\s]/g, \"\");\n            columns.name = indexName;\n            options.uniqueKeys[indexName] = index;\n            if (indexName.length === 0) {\n              values.attributes += \",UNIQUE (\".concat(columns.fields.map(function (field) {\n                return _this.quoteIdentifier(field);\n              }).join(\", \"), \")\");\n            } else {\n              values.attributes += \", CONSTRAINT \".concat(_this.quoteIdentifier(indexName), \" UNIQUE (\").concat(columns.fields.map(function (field) {\n                return _this.quoteIdentifier(field);\n              }).join(\", \"), \")\");\n            }\n          }\n        });\n      }\n      var query = Utils.joinSQLFragments([\"CREATE TABLE\", values.table, \"(\".concat(values.attributes, \")\")]);\n      return Utils.joinSQLFragments([\"BEGIN\", \"EXECUTE IMMEDIATE\", \"\".concat(this.escape(query), \";\"), \"EXCEPTION WHEN OTHERS THEN\", \"IF SQLCODE != -955 THEN\", \"RAISE;\", \"END IF;\", \"END;\"]);\n    }\n  }, {\n    key: \"tableExistsQuery\",\n    value: function tableExistsQuery(table) {\n      var _this$getSchemaNameAn = this.getSchemaNameAndTableName(table),\n        _this$getSchemaNameAn2 = _slicedToArray(_this$getSchemaNameAn, 2),\n        tableName = _this$getSchemaNameAn2[0],\n        schemaName = _this$getSchemaNameAn2[1];\n      return \"SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = \".concat(this.escape(tableName), \" AND OWNER = \").concat(table.schema ? this.escape(schemaName) : \"USER\");\n    }\n  }, {\n    key: \"describeTableQuery\",\n    value: function describeTableQuery(tableName, schema) {\n      var currTableName = this.getCatalogName(tableName.tableName || tableName);\n      schema = this.getCatalogName(schema);\n      return [\"SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type \", \"FROM all_tab_columns atc \", \"LEFT OUTER JOIN \", \"(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc \", \"ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) \", schema ? \"WHERE (atc.OWNER = \".concat(this.escape(schema), \") \") : \"WHERE atc.OWNER = USER \", \"AND (atc.TABLE_NAME = \".concat(this.escape(currTableName), \")\"), \"ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC\"].join(\"\");\n    }\n  }, {\n    key: \"renameTableQuery\",\n    value: function renameTableQuery(before, after) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(before), \"RENAME TO\", this.quoteTable(after)]);\n    }\n  }, {\n    key: \"showConstraintsQuery\",\n    value: function showConstraintsQuery(table) {\n      var tableName = this.getCatalogName(table.tableName || table);\n      return \"SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = \".concat(this.escape(tableName));\n    }\n  }, {\n    key: \"showTablesQuery\",\n    value: function showTablesQuery() {\n      return \"SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \\\"schema_name\\\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')\";\n    }\n  }, {\n    key: \"dropTableQuery\",\n    value: function dropTableQuery(tableName) {\n      return Utils.joinSQLFragments([\"BEGIN \", \"EXECUTE IMMEDIATE 'DROP TABLE\", this.quoteTable(tableName), \"CASCADE CONSTRAINTS PURGE';\", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -942 THEN\", \"   RAISE;\", \" END IF;\", \"END;\"]);\n    }\n  }, {\n    key: \"addIndexQuery\",\n    value: function addIndexQuery(tableName, attributes, options, rawTablename) {\n      if (typeof tableName !== \"string\" && attributes.name) {\n        attributes.name = \"\".concat(tableName.schema, \".\").concat(attributes.name);\n      }\n      return _get(_getPrototypeOf(_OracleQueryGenerator.prototype), \"addIndexQuery\", this).call(this, tableName, attributes, options, rawTablename);\n    }\n  }, {\n    key: \"addConstraintQuery\",\n    value: function addConstraintQuery(tableName, options) {\n      options = options || {};\n      var constraintSnippet = this.getConstraintSnippet(tableName, options);\n      tableName = this.quoteTable(tableName);\n      return \"ALTER TABLE \".concat(tableName, \" ADD \").concat(constraintSnippet, \";\");\n    }\n  }, {\n    key: \"addColumnQuery\",\n    value: function addColumnQuery(table, key, dataType) {\n      dataType.field = key;\n      var attribute = Utils.joinSQLFragments([this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: \"addColumn\"\n      })]);\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", attribute]);\n    }\n  }, {\n    key: \"removeColumnQuery\",\n    value: function removeColumnQuery(tableName, attributeName) {\n      return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP COLUMN\", this.quoteIdentifier(attributeName), \";\"]);\n    }\n  }, {\n    key: \"_alterForeignKeyConstraint\",\n    value: function _alterForeignKeyConstraint(definition, table, attributeName) {\n      var _this$getSchemaNameAn3 = this.getSchemaNameAndTableName(table),\n        _this$getSchemaNameAn4 = _slicedToArray(_this$getSchemaNameAn3, 2),\n        tableName = _this$getSchemaNameAn4[0],\n        schemaName = _this$getSchemaNameAn4[1];\n      var attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n      var schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : \"USER\";\n      var tableNameConstant = this.escape(this.getCatalogName(tableName));\n      var getConsNameQuery = [\"SELECT constraint_name INTO cons_name\", \"FROM (\", \"  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns\", \"  FROM all_cons_columns cc, all_constraints c\", \"  WHERE cc.owner = c.owner\", \"  AND cc.table_name = c.table_name\", \"  AND cc.constraint_name = c.constraint_name\", \"  AND c.constraint_type = 'R'\", \"  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name\", \")\", \"WHERE owner =\", schemaNameConstant, \"AND table_name =\", tableNameConstant, \"AND cons_columns =\", attributeNameConstant, \";\"].join(\" \");\n      var secondQuery = Utils.joinSQLFragments([\"ALTER TABLE \".concat(this.quoteIdentifier(tableName)), \"ADD FOREIGN KEY\", \"(\".concat(this.quoteIdentifier(attributeName), \")\"), definition.replace(/.+?(?=REFERENCES)/, \"\")]);\n      return [\"BEGIN\", getConsNameQuery, \"EXCEPTION\", \"WHEN NO_DATA_FOUND THEN\", \" CONS_NAME := NULL;\", \"END;\", \"IF CONS_NAME IS NOT NULL THEN\", \" EXECUTE IMMEDIATE 'ALTER TABLE \".concat(this.quoteTable(table), \" DROP CONSTRAINT \\\"'||CONS_NAME||'\\\"';\"), \"END IF;\", \"EXECUTE IMMEDIATE \".concat(this.escape(secondQuery), \";\")].join(\" \");\n    }\n  }, {\n    key: \"_modifyQuery\",\n    value: function _modifyQuery(definition, table, attributeName) {\n      var query = Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"MODIFY\", this.quoteIdentifier(attributeName), definition]);\n      var secondQuery = query.replace(\"NOT NULL\", \"\").replace(\"NULL\", \"\");\n      return [\"BEGIN\", \"EXECUTE IMMEDIATE \".concat(this.escape(query), \";\"), \"EXCEPTION\", \"WHEN OTHERS THEN\", \" IF SQLCODE = -1442 OR SQLCODE = -1451 THEN\", \"   EXECUTE IMMEDIATE \".concat(this.escape(secondQuery), \";\"), \" ELSE\", \"   RAISE;\", \" END IF;\", \"END;\"].join(\" \");\n    }\n  }, {\n    key: \"changeColumnQuery\",\n    value: function changeColumnQuery(table, attributes) {\n      var sql = [\"DECLARE\", \"CONS_NAME VARCHAR2(200);\", \"BEGIN\"];\n      for (var attributeName in attributes) {\n        if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n        var definition = attributes[attributeName];\n        if (definition.match(/REFERENCES/)) {\n          sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n        } else {\n          sql.push(this._modifyQuery(definition, table, attributeName));\n        }\n      }\n      sql.push(\"END;\");\n      return sql.join(\" \");\n    }\n  }, {\n    key: \"renameColumnQuery\",\n    value: function renameColumnQuery(tableName, attrBefore, attributes) {\n      var newName = Object.keys(attributes)[0];\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" RENAME COLUMN \").concat(this.quoteIdentifier(attrBefore), \" TO \").concat(this.quoteIdentifier(newName));\n    }\n  }, {\n    key: \"populateInsertQueryReturnIntoBinds\",\n    value: function populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n      var _this2 = this;\n      var oracledb = this.sequelize.connectionManager.lib;\n      var outBindAttributes = Object.create(null);\n      var outbind = [];\n      var outbindParam = this.bindParam(outbind, inbindLength);\n      returningModelAttributes.forEach(function (element, index) {\n        if (element.startsWith('\"')) {\n          element = element.substring(1, element.length - 1);\n        }\n        outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), {\n          dir: oracledb.BIND_OUT\n        });\n        var returnAttribute = \"\".concat(_this2.format(void 0, void 0, {\n          context: \"INSERT\"\n        }, outbindParam));\n        returnAttributes.push(returnAttribute);\n      });\n      options.outBindAttributes = outBindAttributes;\n    }\n  }, {\n    key: \"upsertQuery\",\n    value: function upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n      var rawAttributes = model.rawAttributes;\n      var updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n      options.bind = updateQuery.bind;\n      var insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n      var sql = [\"DECLARE \", \"BEGIN \", updateQuery.query ? [updateQuery.query, \"; \", \" IF ( SQL%ROWCOUNT = 0 ) THEN \", insertQuery.query, \" :isUpdate := 0; \", \"ELSE \", \" :isUpdate := 1; \", \" END IF; \"].join(\"\") : [insertQuery.query, \" :isUpdate := 0; \", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -1 THEN\", \"   RAISE;\", \" END IF;\"].join(\"\"), \"END;\"];\n      var query = sql.join(\"\");\n      var result = {\n        query: query\n      };\n      if (options.bindParam !== false) {\n        result.bind = updateQuery.bind || insertQuery.bind;\n      }\n      return result;\n    }\n  }, {\n    key: \"bulkInsertQuery\",\n    value: function bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n      var _this3 = this;\n      options = options || {};\n      options.executeMany = true;\n      fieldMappedAttributes = fieldMappedAttributes || {};\n      var tuples = [];\n      var allColumns = {};\n      var inBindBindDefMap = {};\n      var outBindBindDefMap = {};\n      var oracledb = this.sequelize.connectionManager.lib;\n      var _iterator2 = _createForOfIteratorHelper(fieldValueHashes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var fieldValueHash = _step2.value;\n          _.forOwn(fieldValueHash, function (value, key) {\n            allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var inBindPosition;\n      var _iterator3 = _createForOfIteratorHelper(fieldValueHashes),\n        _step3;\n      try {\n        var _loop = function _loop() {\n          var fieldValueHash = _step3.value;\n          var tuple = [];\n          var inbindParam = options.bindParam === void 0 ? _this3.bindParam(tuple) : options.bindParam;\n          var tempBindPositions = Object.keys(allColumns).map(function (key) {\n            if (allColumns[key] === true) {\n              if (fieldValueHash[key] !== null) {\n                throw Error(\"For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!\");\n              }\n              return \"DEFAULT\";\n            }\n            return _this3.format(fieldValueHash[key], fieldMappedAttributes[key], {\n              context: \"INSERT\"\n            }, inbindParam);\n          });\n          if (!inBindPosition) {\n            inBindPosition = tempBindPositions;\n          }\n          tuples.push(tuple);\n        };\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var returnColumn = [];\n      var returnColumnBindPositions = [];\n      var insertColumns = [];\n      for (var _i = 0, _Object$keys = Object.keys(allColumns); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        if (fieldMappedAttributes[key]) {\n          var bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n          if (allColumns[key]) {\n            bindDef.dir = oracledb.BIND_OUT;\n            outBindBindDefMap[key] = bindDef;\n            returnColumn.push(this.quoteIdentifier(key));\n            returnColumnBindPositions.push(\":\".concat(tuples[0].length + returnColumn.length));\n          } else {\n            bindDef.dir = oracledb.BIND_IN;\n            inBindBindDefMap[key] = bindDef;\n          }\n        }\n        insertColumns.push(this.quoteIdentifier(key));\n      }\n      var query = Utils.joinSQLFragments([\"INSERT\", \"INTO\", this.quoteTable(tableName), \"(\".concat(insertColumns.join(\",\"), \")\"), \"VALUES\", \"(\".concat(inBindPosition, \")\")]);\n      if (returnColumn.length > 0) {\n        options.outBindAttributes = outBindBindDefMap;\n        query = Utils.joinSQLFragments([query, \"RETURNING\", \"\".concat(returnColumn.join(\",\")), \"INTO\", \"\".concat(returnColumnBindPositions)]);\n      }\n      var result = {\n        query: query\n      };\n      result.bind = tuples;\n      options.inbindAttributes = inBindBindDefMap;\n      return result;\n    }\n  }, {\n    key: \"truncateTableQuery\",\n    value: function truncateTableQuery(tableName) {\n      return \"TRUNCATE TABLE \".concat(this.quoteTable(tableName));\n    }\n  }, {\n    key: \"deleteQuery\",\n    value: function deleteQuery(tableName, where, options, model) {\n      options = options || {};\n      var table = tableName;\n      where = this.getWhereConditions(where, null, model, options);\n      var queryTmpl;\n      if (options.limit) {\n        var whereTmpl = where ? \" AND \".concat(where) : \"\";\n        queryTmpl = \"DELETE FROM \".concat(this.quoteTable(table), \" WHERE rowid IN (SELECT rowid FROM \").concat(this.quoteTable(table), \" WHERE rownum <= \").concat(this.escape(options.limit)).concat(whereTmpl, \")\");\n      } else {\n        var _whereTmpl = where ? \" WHERE \".concat(where) : \"\";\n        queryTmpl = \"DELETE FROM \".concat(this.quoteTable(table)).concat(_whereTmpl);\n      }\n      return queryTmpl;\n    }\n  }, {\n    key: \"showIndexesQuery\",\n    value: function showIndexesQuery(table) {\n      var _this$getSchemaNameAn5 = this.getSchemaNameAndTableName(table),\n        _this$getSchemaNameAn6 = _slicedToArray(_this$getSchemaNameAn5, 2),\n        tableName = _this$getSchemaNameAn6[0],\n        owner = _this$getSchemaNameAn6[1];\n      var sql = [\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type \", \"FROM all_ind_columns i \", \"INNER JOIN all_indexes u \", \"ON (u.table_name = i.table_name AND u.index_name = i.index_name) \", \"LEFT OUTER JOIN all_constraints c \", \"ON (c.table_name = i.table_name AND c.index_name = i.index_name) \", \"WHERE i.table_name = \".concat(this.escape(tableName)), \" AND u.table_owner = \", owner ? this.escape(owner) : \"USER\", \" ORDER BY index_name, column_position\"];\n      return sql.join(\"\");\n    }\n  }, {\n    key: \"removeIndexQuery\",\n    value: function removeIndexQuery(tableName, indexNameOrAttributes) {\n      var indexName = indexNameOrAttributes;\n      if (typeof indexName !== \"string\") {\n        indexName = Utils.underscore(\"\".concat(tableName, \"_\").concat(indexNameOrAttributes.join(\"_\")));\n      }\n      return \"DROP INDEX \".concat(this.quoteIdentifier(indexName));\n    }\n  }, {\n    key: \"attributeToSQL\",\n    value: function attributeToSQL(attribute, options) {\n      var _this4 = this;\n      if (!_.isPlainObject(attribute)) {\n        attribute = {\n          type: attribute\n        };\n      }\n      attribute.onUpdate = \"\";\n      if (attribute.references) {\n        if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n          this.sequelize.log(\"Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n          attribute.onDelete = \"\";\n        }\n      }\n      var template;\n      if (attribute.type instanceof DataTypes.ENUM) {\n        if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n        template = attribute.type.toSql();\n        template += \" CHECK (\".concat(this.quoteIdentifier(options.attributeName), \" IN(\").concat(_.map(attribute.values, function (value) {\n          return _this4.escape(value);\n        }).join(\", \"), \"))\");\n        return template;\n      }\n      if (attribute.type instanceof DataTypes.JSON) {\n        template = attribute.type.toSql();\n        template += \" CHECK (\".concat(this.quoteIdentifier(options.attributeName), \" IS JSON)\");\n        return template;\n      }\n      if (attribute.type instanceof DataTypes.BOOLEAN) {\n        template = attribute.type.toSql();\n        template += \" CHECK (\".concat(this.quoteIdentifier(options.attributeName), \" IN('1', '0'))\");\n        return template;\n      }\n      if (attribute.autoIncrement) {\n        template = \" NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY\";\n      } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n        template = attribute.type.toSql();\n      } else if (attribute.type) {\n        var unsignedTemplate = \"\";\n        if (attribute.type._unsigned) {\n          attribute.type._unsigned = false;\n          unsignedTemplate += \" check(\".concat(this.quoteIdentifier(options.attributeName), \" >= 0)\");\n        }\n        template = attribute.type.toString();\n        if (attribute.type && attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n          template += \" DEFAULT \".concat(this.escape(attribute.defaultValue));\n        }\n        if (!attribute.autoIncrement) {\n          if (attribute.allowNull === false) {\n            template += \" NOT NULL\";\n          } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n            template += \" NULL\";\n          }\n        }\n        template += unsignedTemplate;\n      } else {\n        template = \"\";\n      }\n      if (attribute.unique === true && !attribute.primaryKey) {\n        template += \" UNIQUE\";\n      }\n      if (attribute.primaryKey) {\n        template += \" PRIMARY KEY\";\n      }\n      if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n        template += \" REFERENCES \".concat(this.quoteTable(attribute.references.model));\n        if (attribute.references.key) {\n          template += \" (\".concat(this.quoteIdentifier(attribute.references.key), \")\");\n        } else {\n          template += \" (\".concat(this.quoteIdentifier(\"id\"), \")\");\n        }\n        if (attribute.onDelete && attribute.onDelete.toUpperCase() !== \"NO ACTION\") {\n          template += \" ON DELETE \".concat(attribute.onDelete.toUpperCase());\n        }\n      }\n      return template;\n    }\n  }, {\n    key: \"attributesToSQL\",\n    value: function attributesToSQL(attributes, options) {\n      var result = {};\n      for (var key in attributes) {\n        var attribute = attributes[key];\n        var attributeName = attribute.field || key;\n        result[attributeName] = this.attributeToSQL(attribute, __spreadValues({\n          attributeName: attributeName\n        }, options));\n      }\n      return result;\n    }\n  }, {\n    key: \"createTrigger\",\n    value: function createTrigger() {\n      throwMethodUndefined(\"createTrigger\");\n    }\n  }, {\n    key: \"dropTrigger\",\n    value: function dropTrigger() {\n      throwMethodUndefined(\"dropTrigger\");\n    }\n  }, {\n    key: \"renameTrigger\",\n    value: function renameTrigger() {\n      throwMethodUndefined(\"renameTrigger\");\n    }\n  }, {\n    key: \"createFunction\",\n    value: function createFunction() {\n      throwMethodUndefined(\"createFunction\");\n    }\n  }, {\n    key: \"dropFunction\",\n    value: function dropFunction() {\n      throwMethodUndefined(\"dropFunction\");\n    }\n  }, {\n    key: \"renameFunction\",\n    value: function renameFunction() {\n      throwMethodUndefined(\"renameFunction\");\n    }\n  }, {\n    key: \"getConstraintsOnColumn\",\n    value: function getConstraintsOnColumn(table, column) {\n      var _this$getSchemaNameAn7 = this.getSchemaNameAndTableName(table),\n        _this$getSchemaNameAn8 = _slicedToArray(_this$getSchemaNameAn7, 2),\n        tableName = _this$getSchemaNameAn8[0],\n        schemaName = _this$getSchemaNameAn8[1];\n      column = this.getCatalogName(column);\n      var sql = [\"SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = \", this.escape(tableName), \" and OWNER = \", table.schema ? this.escape(schemaName) : \"USER\", \" and COLUMN_NAME = \", this.escape(column), \" AND POSITION IS NOT NULL ORDER BY POSITION\"].join(\"\");\n      return sql;\n    }\n  }, {\n    key: \"getForeignKeysQuery\",\n    value: function getForeignKeysQuery(table) {\n      var _this$getSchemaNameAn9 = this.getSchemaNameAndTableName(table),\n        _this$getSchemaNameAn10 = _slicedToArray(_this$getSchemaNameAn9, 2),\n        tableName = _this$getSchemaNameAn10[0],\n        schemaName = _this$getSchemaNameAn10[1];\n      var sql = ['SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"', \" FROM all_cons_columns a\", \" JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name\", \" JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name\", \" WHERE c.constraint_type  = 'R'\", \" AND a.table_name = \", this.escape(tableName), \" AND a.owner = \", table.schema ? this.escape(schemaName) : \"USER\", \" ORDER BY a.table_name, a.constraint_name\"].join(\"\");\n      return sql;\n    }\n  }, {\n    key: \"dropForeignKeyQuery\",\n    value: function dropForeignKeyQuery(tableName, foreignKey) {\n      return this.dropConstraintQuery(tableName, foreignKey);\n    }\n  }, {\n    key: \"getPrimaryKeyConstraintQuery\",\n    value: function getPrimaryKeyConstraintQuery(table) {\n      var _this$getSchemaNameAn11 = this.getSchemaNameAndTableName(table),\n        _this$getSchemaNameAn12 = _slicedToArray(_this$getSchemaNameAn11, 2),\n        tableName = _this$getSchemaNameAn12[0],\n        schemaName = _this$getSchemaNameAn12[1];\n      var sql = [\"SELECT cols.column_name, atc.identity_column \", \"FROM all_constraints cons, all_cons_columns cols \", \"INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )\", \"WHERE cols.table_name = \", this.escape(tableName), \"AND cols.owner = \", table.schema ? this.escape(schemaName) : \"USER \", \"AND cons.constraint_type = 'P' \", \"AND cons.constraint_name = cols.constraint_name \", \"AND cons.owner = cols.owner \", \"ORDER BY cols.table_name, cols.position\"].join(\"\");\n      return sql;\n    }\n  }, {\n    key: \"dropConstraintQuery\",\n    value: function dropConstraintQuery(tableName, constraintName) {\n      return \"ALTER TABLE \".concat(this.quoteTable(tableName), \" DROP CONSTRAINT \").concat(constraintName);\n    }\n  }, {\n    key: \"setIsolationLevelQuery\",\n    value: function setIsolationLevelQuery(value, options) {\n      if (options.parent) {\n        return;\n      }\n      switch (value) {\n        case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n          return \"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\";\n        case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n          return \"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\";\n        default:\n          throw new Error(\"isolation level \\\"\".concat(value, \"\\\" is not supported\"));\n      }\n    }\n  }, {\n    key: \"getAliasToken\",\n    value: function getAliasToken() {\n      return \"\";\n    }\n  }, {\n    key: \"startTransactionQuery\",\n    value: function startTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return \"SAVEPOINT \".concat(this.quoteIdentifier(transaction.name));\n      }\n      return \"BEGIN TRANSACTION\";\n    }\n  }, {\n    key: \"commitTransactionQuery\",\n    value: function commitTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return;\n      }\n      return \"COMMIT TRANSACTION\";\n    }\n  }, {\n    key: \"rollbackTransactionQuery\",\n    value: function rollbackTransactionQuery(transaction) {\n      if (transaction.parent) {\n        return \"ROLLBACK TO SAVEPOINT \".concat(this.quoteIdentifier(transaction.name));\n      }\n      return \"ROLLBACK TRANSACTION\";\n    }\n  }, {\n    key: \"handleSequelizeMethod\",\n    value: function handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n      var _this5 = this;\n      var str;\n      if (smth instanceof Utils.Json) {\n        if (smth.conditions) {\n          var conditions = this.parseConditionObject(smth.conditions).map(function (condition) {\n            return \"\".concat(_this5.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path)), \" = '\").concat(condition.value, \"'\");\n          });\n          return conditions.join(\" AND \");\n        }\n        if (smth.path) {\n          if (this._checkValidJsonStatement(smth.path)) {\n            str = smth.path;\n          } else {\n            var paths = _.toPath(smth.path);\n            var column = paths.shift();\n            str = this.jsonPathExtractionQuery(column, paths);\n          }\n          if (smth.value) {\n            str += util.format(\" = %s\", this.escape(smth.value));\n          }\n          return str;\n        }\n      }\n      if (smth instanceof Utils.Cast) {\n        if (smth.val instanceof Utils.SequelizeMethod) {\n          str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n          if (smth.type === \"boolean\") {\n            str = \"(CASE WHEN \".concat(str, \"='true' THEN 1 ELSE 0 END)\");\n            return \"CAST(\".concat(str, \" AS NUMBER)\");\n          }\n          if (smth.type === \"timestamptz\" && /json_value\\(/.test(str)) {\n            str = str.slice(0, -1);\n            return \"\".concat(str, \" RETURNING TIMESTAMP WITH TIME ZONE)\");\n          }\n        }\n      }\n      return _get(_getPrototypeOf(_OracleQueryGenerator.prototype), \"handleSequelizeMethod\", this).call(this, smth, tableName, factory, options, prepend);\n    }\n  }, {\n    key: \"_checkValidJsonStatement\",\n    value: function _checkValidJsonStatement(stmt) {\n      if (typeof stmt !== \"string\") {\n        return false;\n      }\n      var currentIndex = 0;\n      var openingBrackets = 0;\n      var closingBrackets = 0;\n      var hasJsonFunction = false;\n      var hasInvalidToken = false;\n      while (currentIndex < stmt.length) {\n        var string = stmt.substr(currentIndex);\n        var functionMatches = JSON_FUNCTION_REGEX.exec(string);\n        if (functionMatches) {\n          currentIndex += functionMatches[0].indexOf(\"(\");\n          hasJsonFunction = true;\n          continue;\n        }\n        var operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n        if (operatorMatches) {\n          currentIndex += operatorMatches[0].length;\n          hasJsonFunction = true;\n          continue;\n        }\n        var tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n        if (tokenMatches) {\n          var capturedToken = tokenMatches[1];\n          if (capturedToken === \"(\") {\n            openingBrackets++;\n          } else if (capturedToken === \")\") {\n            closingBrackets++;\n          } else if (capturedToken === \";\") {\n            hasInvalidToken = true;\n            break;\n          }\n          currentIndex += tokenMatches[0].length;\n          continue;\n        }\n        break;\n      }\n      if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n        throw new Error(\"Invalid json statement: \".concat(stmt));\n      }\n      return hasJsonFunction;\n    }\n  }, {\n    key: \"jsonPathExtractionQuery\",\n    value: function jsonPathExtractionQuery(column, path) {\n      var paths = _.toPath(path);\n      var quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n      paths = paths.map(function (subPath) {\n        return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n      });\n      var pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, function (__, digit) {\n        return \"[\".concat(digit, \"]\");\n      }));\n      return \"json_value(\".concat(quotedColumn, \",\").concat(pathStr, \")\");\n    }\n  }, {\n    key: \"addLimitAndOffset\",\n    value: function addLimitAndOffset(options, model) {\n      var fragment = \"\";\n      var offset = options.offset || 0,\n        isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      var orders = {};\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n      if (options.limit || options.offset) {\n        if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n          var tablePkFragment = \"\".concat(this.quoteTable(options.tableAs || model.name), \".\").concat(this.quoteIdentifier(model.primaryKeyField));\n          fragment += \" ORDER BY \".concat(tablePkFragment);\n        }\n        if (options.offset || options.limit) {\n          fragment += \" OFFSET \".concat(this.escape(offset), \" ROWS\");\n        }\n        if (options.limit) {\n          fragment += \" FETCH NEXT \".concat(this.escape(options.limit), \" ROWS ONLY\");\n        }\n      }\n      return fragment;\n    }\n  }, {\n    key: \"booleanValue\",\n    value: function booleanValue(value) {\n      return value ? 1 : 0;\n    }\n  }, {\n    key: \"quoteIdentifier\",\n    value: function quoteIdentifier(identifier) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var optForceQuote = force;\n      var optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n      var rawIdentifier = Utils.removeTicks(identifier, '\"');\n      var regExp = /^(([\\w][\\w\\d_]*))$/g;\n      if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {\n        return rawIdentifier;\n      }\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n  }, {\n    key: \"bindParam\",\n    value: function bindParam(bind) {\n      var posOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return function (value) {\n        bind.push(value);\n        return \":\".concat(bind.length + posOffset);\n      };\n    }\n  }, {\n    key: \"authTestQuery\",\n    value: function authTestQuery() {\n      return \"SELECT 1+1 AS result FROM DUAL\";\n    }\n  }]);\n  return _OracleQueryGenerator;\n}(AbstractQueryGenerator);\nfunction throwMethodUndefined(methodName) {\n  throw new Error(\"The method \\\"\".concat(methodName, \"\\\" is not defined! Please add it to your sql dialect.\"));\n}","map":{"version":3,"names":["__export","exports","OracleQueryGenerator","Utils","require","DataTypes","AbstractQueryGenerator","_","util","Transaction","ORACLE_RESERVED_WORDS","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","_AbstractQueryGenerat","_inherits","_OracleQueryGenerator","_super","_createSuper","options","_classCallCheck","call","_createClass","key","value","getCatalogName","quoteIdentifiers","quotedValue","quoteIdentifier","toUpperCase","getSchemaNameAndTableName","table","tableName","schemaName","schema","createSchema","quotedSchema","escape","concat","join","showSchemasQuery","dropSchema","quoteTable","versionQuery","createTableQuery","attributes","_this","primaryKeys","foreignKeys","Object","create","attrStr","checkStr","values","attr","prototype","hasOwnProperty","dataType","includes","push","match","replace","trim","pkString","map","pk","length","fkey","indexOf","indexes","idxToDelete","forEach","index","idx","unique","fields","field","attribute","canContinue","uniqueKeys","keys","fieldIdx","currUnique","i","indexName","name","constraintToAdd","splice","each","columns","canBeUniq","primaryKey","currField","isString","attrToReplace","query","joinSQLFragments","tableExistsQuery","_this$getSchemaNameAn","_this$getSchemaNameAn2","_slicedToArray","describeTableQuery","currTableName","renameTableQuery","before","after","showConstraintsQuery","showTablesQuery","dropTableQuery","addIndexQuery","rawTablename","_get","_getPrototypeOf","addConstraintQuery","constraintSnippet","getConstraintSnippet","addColumnQuery","attributeToSQL","attributeName","context","removeColumnQuery","_alterForeignKeyConstraint","definition","_this$getSchemaNameAn3","_this$getSchemaNameAn4","attributeNameConstant","schemaNameConstant","tableNameConstant","getConsNameQuery","secondQuery","_modifyQuery","changeColumnQuery","sql","renameColumnQuery","attrBefore","newName","populateInsertQueryReturnIntoBinds","returningModelAttributes","returnTypes","inbindLength","returnAttributes","_this2","oracledb","sequelize","connectionManager","lib","outBindAttributes","outbind","outbindParam","bindParam","element","startsWith","substring","assign","_getBindDef","dir","BIND_OUT","returnAttribute","format","upsertQuery","insertValues","updateValues","where","model","rawAttributes","updateQuery","bind","insertQuery","result","bulkInsertQuery","fieldValueHashes","fieldMappedAttributes","_this3","executeMany","tuples","allColumns","inBindBindDefMap","outBindBindDefMap","_iterator2","_createForOfIteratorHelper","_step2","s","n","done","fieldValueHash","forOwn","autoIncrement","err","e","f","inBindPosition","_iterator3","_step3","_loop","tuple","inbindParam","tempBindPositions","Error","returnColumn","returnColumnBindPositions","insertColumns","_i","_Object$keys","bindDef","type","BIND_IN","inbindAttributes","truncateTableQuery","deleteQuery","getWhereConditions","queryTmpl","limit","whereTmpl","showIndexesQuery","_this$getSchemaNameAn5","_this$getSchemaNameAn6","owner","removeIndexQuery","indexNameOrAttributes","underscore","_this4","isPlainObject","onUpdate","references","Model","log","onDelete","template","ENUM","toSql","JSON","BOOLEAN","DOUBLE","unsignedTemplate","_unsigned","toString","_binary","defaultValueSchemable","defaultValue","allowNull","withoutForeignKeyConstraints","attributesToSQL","__spreadValues","createTrigger","throwMethodUndefined","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","getConstraintsOnColumn","column","_this$getSchemaNameAn7","_this$getSchemaNameAn8","getForeignKeysQuery","_this$getSchemaNameAn9","_this$getSchemaNameAn10","dropForeignKeyQuery","foreignKey","dropConstraintQuery","getPrimaryKeyConstraintQuery","_this$getSchemaNameAn11","_this$getSchemaNameAn12","constraintName","setIsolationLevelQuery","parent","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","getAliasToken","startTransactionQuery","transaction","commitTransactionQuery","rollbackTransactionQuery","handleSequelizeMethod","smth","factory","prepend","_this5","str","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","_checkValidJsonStatement","paths","toPath","shift","Cast","val","SequelizeMethod","test","slice","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","operatorMatches","tokenMatches","capturedToken","quotedColumn","isIdentifierQuoted","subPath","addTicks","pathStr","__","digit","addLimitAndOffset","fragment","offset","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","order","getQueryOrders","mainQueryOrder","subQueryOrder","tablePkFragment","tableAs","primaryKeyField","booleanValue","identifier","force","arguments","undefined","optForceQuote","optQuoteIdentifiers","rawIdentifier","removeTicks","regExp","posOffset","authTestQuery","methodName"],"sources":["../../../src/dialects/oracle/query-generator.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst _ = require('lodash');\nconst util = require('util');\nconst Transaction = require('../../transaction');\n\n/**\n * list of reserved words in Oracle DB 21c\n * source: https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\n *\n * @private\n */\nconst ORACLE_RESERVED_WORDS = ['ACCESS', 'ADD', 'ALL', 'ALTER', 'AND', 'ANY', 'ARRAYLEN', 'AS', 'ASC', 'AUDIT', 'BETWEEN', 'BY', 'CHAR', 'CHECK', 'CLUSTER', 'COLUMN', 'COMMENT', 'COMPRESS', 'CONNECT', 'CREATE', 'CURRENT', 'DATE', 'DECIMAL', 'DEFAULT', 'DELETE', 'DESC', 'DISTINCT', 'DROP', 'ELSE', 'EXCLUSIVE', 'EXISTS', 'FILE', 'FLOAT', 'FOR', 'FROM', 'GRANT', 'GROUP', 'HAVING', 'IDENTIFIED', 'IMMEDIATE', 'IN', 'INCREMENT', 'INDEX', 'INITIAL', 'INSERT', 'INTEGER', 'INTERSECT', 'INTO', 'IS', 'LEVEL', 'LIKE', 'LOCK', 'LONG', 'MAXEXTENTS', 'MINUS', 'MODE', 'MODIFY', 'NOAUDIT', 'NOCOMPRESS', 'NOT', 'NOTFOUND', 'NOWAIT', 'NULL', 'NUMBER', 'OF', 'OFFLINE', 'ON', 'ONLINE', 'OPTION', 'OR', 'ORDER', 'PCTFREE', 'PRIOR', 'PRIVILEGES', 'PUBLIC', 'RAW', 'RENAME', 'RESOURCE', 'REVOKE', 'ROW', 'ROWID', 'ROWLABEL', 'ROWNUM', 'ROWS', 'SELECT', 'SESSION', 'SET', 'SHARE', 'SIZE', 'SMALLINT', 'SQLBUF', 'START', 'SUCCESSFUL', 'SYNONYM', 'SYSDATE', 'TABLE', 'THEN', 'TO', 'TRIGGER', 'UID', 'UNION', 'UNIQUE', 'UPDATE', 'USER', 'VALIDATE', 'VALUES', 'VARCHAR', 'VARCHAR2', 'VIEW', 'WHENEVER', 'WHERE', 'WITH'];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\nexport class OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * Returns the value as it is stored in the Oracle DB\n   *\n   * @param {string} value\n   */\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns the tableName and schemaName as it is stored the Oracle DB\n   *\n   * @param {object|string} table\n   */\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\n      'DECLARE',\n      'USER_FOUND BOOLEAN := FALSE;',\n      'BEGIN',\n      ' BEGIN',\n      '   EXECUTE IMMEDIATE ',\n      this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),\n      ';',\n      '   EXCEPTION WHEN OTHERS THEN',\n      '     IF SQLCODE != -1920 THEN',\n      '       RAISE;',\n      '     ELSE',\n      '       USER_FOUND := TRUE;',\n      '     END IF;',\n      ' END;',\n      ' IF NOT USER_FOUND THEN',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),\n      ';',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return 'SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = (\\'NO\\') AND USERNAME != user';\n  }\n\n  dropSchema(schema) {\n    return [\n      'BEGIN',\n      'EXECUTE IMMEDIATE ',\n      this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),\n      ';',\n      'EXCEPTION WHEN OTHERS THEN',\n      '  IF SQLCODE != -1918 THEN',\n      '    RAISE;',\n      '  END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = Object.create(null),\n      attrStr = [],\n      checkStr = [];\n\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n\n    // Starting by dealing with all attributes\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n\n      // ORACLE doesn't support inline REFERENCES declarations: move to the end\n      if (dataType.includes('PRIMARY KEY')) {\n        // Primary key\n        primaryKeys.push(attr);\n        if (dataType.includes('REFERENCES')) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, '')}`);\n\n          // match[2] already has foreignKeys in correct format so we don't need to replace\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, '').trim()}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // Foreign key\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n\n        // match[2] already has foreignKeys in correct format so we don't need to replace\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n\n    values['attributes'] = attrStr.join(', ');\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n\n    // Dealing with FKs\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue; \n      // Oracle default response for FK, doesn't support if defined\n      if (foreignKeys[fkey].indexOf('ON DELETE NO ACTION') > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace('ON DELETE NO ACTION', '');\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(', ')}`;\n    }\n\n    // Specific case for unique indexes with Oracle, we have to set the constraint on the column, if not, no FK will be possible (ORA-02270: no matching unique or primary key for this column-list)\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if ('unique' in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          // If unique index, transform to unique constraint on column\n          const fields = index.fields.map(field => {\n            if (typeof field === 'string') {\n              return field;\n            } \n            return field.attribute;\n            \n          });\n\n          // Now we have to be sure that the constraint isn't already declared in uniqueKeys\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n\n              if (currUnique.fields.length === fields.length) {\n                // lengths are the same, possible same constraint\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    // We have at least one different column, even if we found the same columns previously, we let the constraint be created\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (canContinue) {\n              const indexName = 'name' in index ? index.name : '';\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!('uniqueKeys' in options)) {\n                options.uniqueKeys = {};\n              }\n\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              // The constraint already exists, we remove it from the list\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach(idx => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n\n        // Check if we can create the unique key\n        primaryKeys.forEach(primaryKey => {\n          // We can create an unique constraint if it's not on the primary key AND if it doesn't have unique in its definition\n          // We replace quotes in primary key with ''\n          // Primary key would be a list with double quotes in it so we remove the double quotes\n          primaryKey = primaryKey.replace(/\"/g, '');\n\n          // We check if the unique indexes are already a part of primary key or not\n          // If it is not then we set canbeuniq to true and add a unique constraint to these fields.\n          // Else we can ignore unique constraint on these\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n\n        columns.fields.forEach(field => {\n          let currField = '';\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, '');\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, '');\n          }\n          if (currField in attributes) {\n            // If canBeUniq is false we need not replace the UNIQUE for the attribute\n            // So we replace UNIQUE with '' only if there exists a primary key\n            if (attributes[currField].toUpperCase().indexOf('UNIQUE') > -1 && canBeUniq) {\n              // We generate the attribute without UNIQUE\n              const attrToReplace = attributes[currField].replace('UNIQUE', '');\n              // We replace in the final string\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n\n        // Oracle cannot have an unique AND a primary key on the same fields, prior to the primary key\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, '');\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n\n          // Autogenerate Constraint name, if no indexName is given\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          } else {\n            values.attributes +=\n              `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          }\n        }\n      });\n    }\n\n    // we replace single quotes by two quotes in order for the execute statement to work\n    const query = Utils.joinSQLFragments([\n      'CREATE TABLE',\n      values.table,\n      `(${values.attributes})`\n    ]);\n\n    return Utils.joinSQLFragments([\n      'BEGIN',\n      'EXECUTE IMMEDIATE',\n      `${this.escape(query)};`,\n      'EXCEPTION WHEN OTHERS THEN',\n      'IF SQLCODE != -955 THEN',\n      'RAISE;',\n      'END IF;',\n      'END;'\n    ]);\n  }\n\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : 'USER'}`;\n  }\n  \n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    // name, type, datalength (except number / nvarchar), datalength varchar, datalength number, nullable, default value, primary ?\n    return [\n      'SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type ',\n      'FROM all_tab_columns atc ',\n      'LEFT OUTER JOIN ',\n      '(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc ',\n      'ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) ',\n      schema\n        ? `WHERE (atc.OWNER = ${this.escape(schema)}) `\n        : 'WHERE atc.OWNER = USER ',\n      `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,\n      'ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC'\n    ].join('');\n  }\n\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(before),\n      'RENAME TO',\n      this.quoteTable(after)\n    ]);\n  }\n\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n\n  showTablesQuery() {\n    return 'SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = \\'N\\')';\n  }\n\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      'BEGIN ',\n      'EXECUTE IMMEDIATE \\'DROP TABLE',\n      this.quoteTable(tableName),\n      'CASCADE CONSTRAINTS PURGE\\';',\n      'EXCEPTION WHEN OTHERS THEN',\n      ' IF SQLCODE != -942 THEN',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ]);\n  }\n\n  /*\n    Modifying the indexname so that it is prefixed with the schema name\n    otherwise Oracle tries to add the index to the USER schema\n   @overide\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== 'string' && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n\n    const attribute = Utils.joinSQLFragments([\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: 'addColumn'\n      })\n    ]);\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      attribute\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  /**\n   * Function to add new foreign key to the attribute \n   * Block for add and drop foreign key constraint query\n   * taking the assumption that there is a single column foreign key reference always\n   * i.e. we always do - FOREIGN KEY (a) reference B(a) during createTable queryGenerator\n   * so there would be one and only one match for a constraint name for each column\n   * and every foreign keyed column would have a different constraint name\n   * Since sequelize doesn't support multiple column foreign key, added complexity to\n   * add the feature isn't needed\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {string|object} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : 'USER';\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\n      'SELECT constraint_name INTO cons_name',\n      'FROM (',\n      '  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns',\n      '  FROM all_cons_columns cc, all_constraints c',\n      '  WHERE cc.owner = c.owner',\n      '  AND cc.table_name = c.table_name',\n      '  AND cc.constraint_name = c.constraint_name',\n      '  AND c.constraint_type = \\'R\\'',\n      '  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name',\n      ')',\n      'WHERE owner =',\n      schemaNameConstant,\n      'AND table_name =',\n      tableNameConstant,\n      'AND cons_columns =',\n      attributeNameConstant,\n      ';'\n    ].join(' ');\n    const secondQuery = Utils.joinSQLFragments([\n      `ALTER TABLE ${this.quoteIdentifier(tableName)}`,\n      'ADD FOREIGN KEY',\n      `(${this.quoteIdentifier(attributeName)})`,\n      definition.replace(/.+?(?=REFERENCES)/, '')\n    ]);\n    return [\n      'BEGIN',\n      getConsNameQuery,\n      'EXCEPTION',\n      'WHEN NO_DATA_FOUND THEN',\n      ' CONS_NAME := NULL;',\n      'END;',\n      'IF CONS_NAME IS NOT NULL THEN',\n      ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`,\n      'END IF;',\n      `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`\n    ].join(' ');\n  }\n\n  /**\n   * Function to alter table modify\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {object|string} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'MODIFY',\n      this.quoteIdentifier(attributeName),\n      definition\n    ]);\n    const secondQuery = query.replace('NOT NULL', '').replace('NULL', '');\n    return [\n      'BEGIN',\n      `EXECUTE IMMEDIATE ${this.escape(query)};`,\n      'EXCEPTION',\n      'WHEN OTHERS THEN',\n      ' IF SQLCODE = -1442 OR SQLCODE = -1451 THEN',\n      // We execute the statement without the NULL / NOT NULL clause if the first statement failed due to this\n      `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,\n      ' ELSE',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  changeColumnQuery(table, attributes) {\n    const sql = [\n      'DECLARE',\n      'CONS_NAME VARCHAR2(200);',\n      'BEGIN'\n    ];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        // Building the modify query\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push('END;');\n    return sql.join(' ');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n\n  /**\n   * Populates the returnAttributes array with outbind bindByPosition values\n   * and also the options.outBindAttributes map with bindDef for outbind of InsertQuery\n   *\n   * @param {Array} returningModelAttributes\n   * @param {Array} returnTypes\n   * @param {number} inbindLength\n   * @param {object} returnAttributes\n   * @param {object} options\n   *\n   * @private\n   */\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      // generateReturnValues function quotes identifier based on the quoteIdentifier option\n      // If the identifier starts with a quote we remove it else we use it as is\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), { dir: oracledb.BIND_OUT });\n      const returnAttribute = `${this.format(undefined, undefined, { context: 'INSERT' }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n\n  /**\n   * Override of upsertQuery, Oracle specific\n   * Using PL/SQL for finding the row\n   *\n   * @param {object|string} tableName\n   * @param {Array} insertValues\n   * @param {Array} updateValues\n   * @param {Array} where\n   * @param {object} model\n   * @param {object} options\n   */\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    // This bind is passed so that the insert query starts appending to this same bind array\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n\n    const sql = [\n      'DECLARE ',\n      'BEGIN ',\n      updateQuery.query ? [ \n        updateQuery.query,\n        '; ',\n        ' IF ( SQL%ROWCOUNT = 0 ) THEN ',\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        'ELSE ',\n        ' :isUpdate := 1; ',\n        ' END IF; '\n      ].join('') : [\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        // If there is a conflict on insert we ignore\n        'EXCEPTION WHEN OTHERS THEN',\n        ' IF SQLCODE != -1 THEN',\n        '   RAISE;',\n        ' END IF;'\n      ].join(''),\n      'END;'\n    ];\n\n    const query = sql.join('');\n    const result = { query };\n    \n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {object} fieldValueHashes\n   * @param {object} options\n   * @param {object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    // Generating the allColumns map\n    // The data is provided as an array of objects. \n    // Each object may contain differing numbers of attributes. \n    // A set of the attribute names that are used in all objects must be determined. \n    // The allColumns map contains the column names and indicates whether the value is generated or not\n    // We set allColumns[key] to true if the field is an\n    // auto-increment field and the value given is null and fieldMappedAttributes[key]\n    // is valid for the specific column else it is set to false\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n\n    // Building the inbind parameter\n    // A list that would have inbind positions like [:1, :2, :3...] to be used in generating sql string\n    let inBindPosition;\n    // Iterating over each row of the fieldValueHashes\n    for (const fieldValueHash of fieldValueHashes) {\n      // Has each column for a row after coverting it to appropriate format using this.format function\n      // like ['Mick', 'Broadstone', 2022-02-16T05:24:18.949Z, 2022-02-16T05:24:18.949Z],\n      const tuple = [];\n      // A function expression for this.bindParam/options.bindparam function\n      // This function is passed to this.format function which inserts column values to the tuple list\n      // using _bindParam/_stringify function in data-type.js file\n      const inbindParam = options.bindParam === undefined ? this.bindParam(tuple) : options.bindParam;\n      // We are iterating over each col\n      // and pushing the given values to tuple list using this.format function\n      // and also simultaneously generating the bindPosition\n      // tempBindPostions has the inbind positions\n      const tempBindPositions = Object.keys(allColumns).map(key => {\n        if (allColumns[key] === true) {\n          // We had set allAttributes[key] to true since at least one row for an auto increment column was null\n          // If we get any other row that has this specific column as non-null we must raise an error\n          // Since for an auto-increment column, either all row has to be null or all row has to be a non-null\n          if (fieldValueHash[key] !== null) {\n            throw Error('For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!');\n          }\n          // Return DEFAULT for auto-increment column and if all values for the column is null in each row\n          return 'DEFAULT';\n        }\n        // Sanitizes the values given by the user and pushes it to the tuple list using inBindParam function and\n        // also generates the inbind position for the sql string for example (:1, :2, :3.....) which is a by product of the push\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' }, inbindParam);\n      });\n\n      // Even though the bind variable positions are calculated for each row we only retain the values for the first row \n      // since the values will be identical\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      // Adding the row to the array of rows that will be supplied to executeMany()\n      tuples.push(tuple);\n    }\n\n    // The columns that we are expecting to be returned from the DB like [\"id1\", \"id2\"...]\n    const returnColumn = [];\n    // The outbind positions for the returning columns like [:3, :4, :5....]\n    const returnColumnBindPositions = [];\n    // Has the columns name in which data would be inserted like [\"id\", \"name\".....]\n    const insertColumns = [];\n    // Iterating over the allColumns keys to get the bindDef for inbind and outbinds\n    // and also to get the list of insert and return column after applying this.quoteIdentifier\n    for (const key of Object.keys(allColumns)) {\n      // If fieldMappenAttributes[attr] is defined we generate the bindDef \n      // and return clause else we can skip it\n      if (fieldMappedAttributes[key]) {\n        // BindDef for the specific column\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          // Binddef for outbinds\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n\n          // Building the outbind parameter list\n          // ReturnColumn has the column name for example \"id\", \"usedId\", quoting depends on quoteIdentifier option\n          returnColumn.push(this.quoteIdentifier(key));\n          // Pushing the outbind index to the returnColumnPositions to generate (:3, :4, :5)\n          // The start offset depend on the tuple length (bind array size of a particular row)\n          // the outbind position starts after the position where inbind position ends\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          // Binddef for inbinds\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      // Quoting and pushing each insert column based on quoteIdentifier option\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n   \n    // Generating the sql query\n    let query = Utils.joinSQLFragments([\n      'INSERT',\n      'INTO',\n      // Table name for the table in which data needs to inserted\n      this.quoteTable(tableName),\n      // Columns names for the columns of the table (example \"a\", \"b\", \"c\" - quoting depends on the quoteidentifier option)\n      `(${insertColumns.join(',')})`,\n      'VALUES',\n      // InBind position for the insert query (for example :1, :2, :3....)\n      `(${inBindPosition})`\n    ]);\n\n    // If returnColumn.length is > 0\n    // then the returning into clause is needed\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([\n        query,\n        'RETURNING',\n        // List of return column (for example \"id\", \"userId\"....)\n        `${returnColumn.join(',')}`,\n        'INTO',\n        // List of outbindPosition (for example :4, :5, :6....)\n        // Start offset depends on where inbindPosition end\n        `${returnColumnBindPositions}`\n      ]);\n    }\n\n    // Binding the bind variable to result\n    const result = { query };\n    // Binding the bindParam to result\n    // Tuple has each row for the insert query\n    result.bind = tuples;\n    // Setting options.inbindAttribute\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n\n    const table = tableName;\n\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    // delete with limit <l> and optional condition <e> on Oracle: DELETE FROM <t> WHERE rowid in (SELECT rowid FROM <t> WHERE <e> AND rownum <= <l>)\n    // Note that the condition <e> has to be in the subquery; otherwise, the subquery would select <l> arbitrary rows.\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : '';\n      queryTmpl =\n        `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${ \n          whereTmpl \n        })`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : '';\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type ',\n      'FROM all_ind_columns i ',\n      'INNER JOIN all_indexes u ',\n      'ON (u.table_name = i.table_name AND u.index_name = i.index_name) ',\n      'LEFT OUTER JOIN all_constraints c ',\n      'ON (c.table_name = i.table_name AND c.index_name = i.index_name) ',\n      `WHERE i.table_name = ${this.escape(tableName)}`,\n      ' AND u.table_owner = ',\n      owner ? this.escape(owner) : 'USER',\n      ' ORDER BY index_name, column_position'\n    ];\n\n    return sql.join('');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName }_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // TODO: Address on update cascade issue whether to throw error or ignore.\n    // Add this to documentation when merging to sequelize-main\n    // ON UPDATE CASCADE IS NOT SUPPORTED BY ORACLE.\n    attribute.onUpdate = '';\n\n    // handle self referential constraints\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\n          'Oracle does not support self referencial constraints, ' +\n            'we will remove it but we recommend restructuring your query'\n        );\n        attribute.onDelete = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${ \n          _.map(attribute.values, value => {\n            return this.escape(value);\n          }).join(', ') \n        }))`;\n      return template;\n    } \n    if (attribute.type instanceof DataTypes.JSON) {\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    } \n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template = attribute.type.toSql();\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    } \n    if (attribute.autoIncrement) {\n      template = ' NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY';\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      // setting it to false because oracle doesn't support unsigned int so put a check to make it behave like unsigned int\n      let unsignedTemplate = '';\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(options.attributeName)} >= 0)`;\n      }\n      template = attribute.type.toString();\n\n      // Blobs/texts cannot have a defaultValue\n      if (\n        attribute.type &&\n        attribute.type !== 'TEXT' &&\n        attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)\n      ) {\n        template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n      }\n\n      if (!attribute.autoIncrement) {\n        // If autoincrement, not null is set automatically\n        if (attribute.allowNull === false) {\n          template += ' NOT NULL';\n        } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n          template += ' NULL';\n        }\n      }\n      template += unsignedTemplate;\n    } else {\n      template = '';\n    }\n\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key) })`;\n      } else {\n        template += ` (${this.quoteIdentifier('id') })`;\n      }\n\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== 'NO ACTION') {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, { attributeName, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\n      'SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = ',\n      this.escape(tableName),\n      ' and OWNER = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' and COLUMN_NAME = ',\n      this.escape(column),\n      ' AND POSITION IS NOT NULL ORDER BY POSITION'\n    ].join('');\n\n    return sql;\n  }\n\n  getForeignKeysQuery(table) {\n    // We don't call quoteTable as we don't want the schema in the table name, Oracle seperates it on another field\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', \n      ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"',\n      ' FROM all_cons_columns a',\n      ' JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name',\n      ' JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name',\n      \" WHERE c.constraint_type  = 'R'\",\n      ' AND a.table_name = ',\n      this.escape(tableName),\n      ' AND a.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' ORDER BY a.table_name, a.constraint_name'\n    ].join('');\n\n    return sql;\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT cols.column_name, atc.identity_column ',\n      'FROM all_constraints cons, all_cons_columns cols ',\n      'INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )',\n      'WHERE cols.table_name = ',\n      this.escape(tableName),\n      'AND cols.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER ',\n      \"AND cons.constraint_type = 'P' \",\n      'AND cons.constraint_name = cols.constraint_name ',\n      'AND cons.owner = cols.owner ',\n      'ORDER BY cols.table_name, cols.position'\n    ].join('');\n\n    return sql;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'SET TRANSACTION ISOLATION LEVEL READ COMMITTED;';\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        // Serializable mode is equal to Snapshot Isolation (SI) \n        // defined in ANSI std.\n        return 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;';\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n\n  getAliasToken() {\n    return '';\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'BEGIN TRANSACTION';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'ROLLBACK TRANSACTION';\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === 'boolean') {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        } if (smth.type === 'timestamptz' && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n\n    paths = paths.map(subPath => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n\n    const pathStr = this.escape(['$'].concat(paths).join('.').replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n\n  addLimitAndOffset(options, model) {\n    let fragment = '';\n    const offset = options.offset || 0,\n      isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // Add needed order by clause only when it is not provided\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n\n    if (\n      optForceQuote !== true &&\n      optQuoteIdentifiers === false &&\n      regExp.test(rawIdentifier) &&\n      !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())\n    ) {\n      // In Oracle, if tables, attributes or alias are created double-quoted,\n      // they are always case sensitive. If they contain any lowercase\n      // characters, they must always be double-quoted otherwise it\n      // would get uppercased by the DB.\n      // Here, we strip quotes if we don't want case sensitivity.\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n\n  /**\n * It causes bindbyPosition like :1, :2, :3\n * We pass the val parameter so that the outBind indexes\n * starts after the inBind indexes end\n *\n * @param {Array} bind\n * @param {number} posOffset\n */\n  bindParam(bind, posOffset = 0) {\n    return value => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n\n  /**\n   * Returns the authenticate test query string\n   */\n  authTestQuery() {\n    return 'SELECT 1+1 AS result FROM DUAL';\n  }\n}\n\n/* istanbul ignore next */\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}