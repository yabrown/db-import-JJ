{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar index = require('./lib/entry-index');\nvar memo = require('./lib/memoization');\nvar write = require('./lib/content/write');\nvar Flush = require('minipass-flush');\nvar _require = require('minipass-collect'),\n  PassThrough = _require.PassThrough;\nvar Pipeline = require('minipass-pipeline');\nvar putOpts = function putOpts(opts) {\n  return _objectSpread({\n    algorithms: ['sha512']\n  }, opts);\n};\nmodule.exports = putData;\nfunction putData(cache, key, data) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _opts = opts,\n    memoize = _opts.memoize;\n  opts = putOpts(opts);\n  return write(cache, data, opts).then(function (res) {\n    return index.insert(cache, key, res.integrity, _objectSpread(_objectSpread({}, opts), {}, {\n      size: res.size\n    })).then(function (entry) {\n      if (memoize) memo.put(cache, entry, data, opts);\n      return res.integrity;\n    });\n  });\n}\nmodule.exports.stream = putStream;\nfunction putStream(cache, key) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _opts2 = opts,\n    memoize = _opts2.memoize;\n  opts = putOpts(opts);\n  var integrity;\n  var size;\n  var memoData;\n  var pipeline = new Pipeline();\n  // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n  if (memoize) {\n    var memoizer = new PassThrough().on('collect', function (data) {\n      memoData = data;\n    });\n    pipeline.push(memoizer);\n  }\n\n  // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n  var contentStream = write.stream(cache, opts).on('integrity', function (int) {\n    integrity = int;\n  }).on('size', function (s) {\n    size = s;\n  });\n  pipeline.push(contentStream);\n\n  // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n  pipeline.push(new Flush({\n    flush: function flush() {\n      return index.insert(cache, key, integrity, _objectSpread(_objectSpread({}, opts), {}, {\n        size: size\n      })).then(function (entry) {\n        if (memoize && memoData) memo.put(cache, entry, memoData, opts);\n        if (integrity) pipeline.emit('integrity', integrity);\n        if (size) pipeline.emit('size', size);\n      });\n    }\n  }));\n  return pipeline;\n}","map":{"version":3,"names":["_objectSpread","require","default","index","memo","write","Flush","_require","PassThrough","Pipeline","putOpts","opts","algorithms","module","exports","putData","cache","key","data","arguments","length","undefined","_opts","memoize","then","res","insert","integrity","size","entry","put","stream","putStream","_opts2","memoData","pipeline","memoizer","on","push","contentStream","int","s","flush","emit"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/cacache/put.js"],"sourcesContent":["'use strict'\n\nconst index = require('./lib/entry-index')\nconst memo = require('./lib/memoization')\nconst write = require('./lib/content/write')\nconst Flush = require('minipass-flush')\nconst { PassThrough } = require('minipass-collect')\nconst Pipeline = require('minipass-pipeline')\n\nconst putOpts = (opts) => ({\n  algorithms: ['sha512'],\n  ...opts,\n})\n\nmodule.exports = putData\n\nfunction putData (cache, key, data, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  return write(cache, data, opts).then((res) => {\n    return index\n      .insert(cache, key, res.integrity, { ...opts, size: res.size })\n      .then((entry) => {\n        if (memoize)\n          memo.put(cache, entry, data, opts)\n\n        return res.integrity\n      })\n  })\n}\n\nmodule.exports.stream = putStream\n\nfunction putStream (cache, key, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  let integrity\n  let size\n\n  let memoData\n  const pipeline = new Pipeline()\n  // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n  if (memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data\n    })\n    pipeline.push(memoizer)\n  }\n\n  // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n  const contentStream = write.stream(cache, opts)\n    .on('integrity', (int) => {\n      integrity = int\n    })\n    .on('size', (s) => {\n      size = s\n    })\n\n  pipeline.push(contentStream)\n\n  // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n  pipeline.push(new Flush({\n    flush () {\n      return index\n        .insert(cache, key, integrity, { ...opts, size })\n        .then((entry) => {\n          if (memoize && memoData)\n            memo.put(cache, entry, memoData, opts)\n\n          if (integrity)\n            pipeline.emit('integrity', integrity)\n\n          if (size)\n            pipeline.emit('size', size)\n        })\n    },\n  }))\n\n  return pipeline\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}