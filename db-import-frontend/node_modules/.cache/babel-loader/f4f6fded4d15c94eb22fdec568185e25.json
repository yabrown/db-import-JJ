{"ast":null,"code":"var _wrapRegExp = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/wrapRegExp.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = function __markAsModule(target) {\n  return __defProp(target, \"__esModule\", {\n    value: true\n  });\n};\nvar __export = function __export(target, all) {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __reExport = function __reExport(target, module2, desc) {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropNames(module2)),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var key = _step.value;\n        if (!__hasOwnProp.call(target, key) && key !== \"default\") __defProp(target, key, {\n          get: function get() {\n            return module2[key];\n          },\n          enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable\n        });\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return target;\n};\nvar __toModule = function __toModule(module2) {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? {\n    get: function get() {\n      return module2.default;\n    },\n    enumerable: true\n  } : {\n    value: module2,\n    enumerable: true\n  })), module2);\n};\n__export(exports, {\n  injectReplacements: function injectReplacements() {\n    return _injectReplacements;\n  }\n});\nvar import_isPlainObject = __toModule(require(\"lodash/isPlainObject\"));\nvar import_sql_string = __toModule(require(\"../sql-string\"));\nfunction _injectReplacements(sqlString, dialect, replacements) {\n  var _a, _b, _c, _d;\n  if (replacements == null) {\n    return sqlString;\n  }\n  if (!Array.isArray(replacements) && !(0, import_isPlainObject.default)(replacements)) {\n    throw new TypeError(\"\\\"replacements\\\" must be an array or a plain object, but received \".concat(JSON.stringify(replacements), \" instead.\"));\n  }\n  var isNamedReplacements = (0, import_isPlainObject.default)(replacements);\n  var isPositionalReplacements = Array.isArray(replacements);\n  var lastConsumedPositionalReplacementIndex = -1;\n  var output = \"\";\n  var currentDollarStringTagName = null;\n  var isString = false;\n  var isColumn = false;\n  var previousSliceEnd = 0;\n  var isSingleLineComment = false;\n  var isCommentBlock = false;\n  var stringIsBackslashEscapable = false;\n  for (var i = 0; i < sqlString.length; i++) {\n    var char = sqlString[i];\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n      continue;\n    }\n    if (isString) {\n      if (char === \"'\" && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n      continue;\n    }\n    if (currentDollarStringTagName !== null) {\n      if (char !== \"$\") {\n        continue;\n      }\n      var remainingString = sqlString.slice(i, sqlString.length);\n      var dollarStringStartMatch = remainingString.match( /*#__PURE__*/_wrapRegExp(/^\\$([a-z_][0-9a-z_]*)?(\\$)/i, {\n        name: 1\n      }));\n      var tagName = ((_a = dollarStringStartMatch == null ? void 0 : dollarStringStartMatch.groups) == null ? void 0 : _a.name) || \"\";\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n      continue;\n    }\n    if (isSingleLineComment) {\n      if (char === \"\\n\") {\n        isSingleLineComment = false;\n      }\n      continue;\n    }\n    if (isCommentBlock) {\n      if (char === \"*\" && sqlString[i + 1] === \"/\") {\n        isCommentBlock = false;\n      }\n      continue;\n    }\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n    if (char === \"'\") {\n      isString = true;\n      stringIsBackslashEscapable = dialect.canBackslashEscape() || dialect.supports.escapeStringConstants && (sqlString[i - 1] === \"E\" || sqlString[i - 1] === \"e\") && canPrecedeNewToken(sqlString[i - 2]);\n      continue;\n    }\n    if (char === \"-\" && sqlString.slice(i, i + 3) === \"-- \") {\n      isSingleLineComment = true;\n      continue;\n    }\n    if (char === \"/\" && sqlString.slice(i, i + 2) === \"/*\") {\n      isCommentBlock = true;\n      continue;\n    }\n    if (char === \"$\") {\n      var previousChar = sqlString[i - 1];\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n      var _remainingString = sqlString.slice(i, sqlString.length);\n      var _dollarStringStartMatch = _remainingString.match( /*#__PURE__*/_wrapRegExp(/^\\$([a-z_][0-9a-z_]*)?(\\$)/i, {\n        name: 1\n      }));\n      if (_dollarStringStartMatch) {\n        currentDollarStringTagName = (_c = (_b = _dollarStringStartMatch.groups) == null ? void 0 : _b.name) != null ? _c : \"\";\n        i += _dollarStringStartMatch[0].length - 1;\n        continue;\n      }\n      continue;\n    }\n    if (isNamedReplacements && char === \":\") {\n      var _previousChar = sqlString[i - 1];\n      if (!canPrecedeNewToken(_previousChar) && _previousChar !== \"[\") {\n        continue;\n      }\n      var _remainingString2 = sqlString.slice(i, sqlString.length);\n      var match = _remainingString2.match( /*#__PURE__*/_wrapRegExp(/^:([a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|\\])/i, {\n        name: 1\n      }));\n      var replacementName = (_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.name;\n      if (!replacementName) {\n        continue;\n      }\n      var replacementValue = replacements[replacementName];\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === void 0) {\n        throw new Error(\"Named replacement \\\":\".concat(replacementName, \"\\\" has no entry in the replacement map.\"));\n      }\n      var escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + replacementName.length + 1;\n      output += escapedReplacement;\n      continue;\n    }\n    if (isPositionalReplacements && char === \"?\") {\n      var _previousChar2 = sqlString[i - 1];\n      if (!canPrecedeNewToken(_previousChar2) && _previousChar2 !== \"[\") {\n        continue;\n      }\n      var nextChar = sqlString[i + 1];\n      if (nextChar === \"|\" || nextChar === \"&\") {\n        continue;\n      }\n      var replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      var _replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n      if (_replacementValue === void 0) {\n        throw new Error(\"Positional replacement (?) \".concat(replacementIndex, \" has no entry in the replacement map (replacements[\").concat(replacementIndex, \"] is undefined).\"));\n      }\n      var _escapedReplacement = (0, import_sql_string.escape)(_replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + 1;\n      output += _escapedReplacement;\n    }\n  }\n  if (isString) {\n    throw new Error(\"The following SQL query includes an unterminated string literal:\\n\".concat(sqlString));\n  }\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n  return output;\n}\nfunction canPrecedeNewToken(char) {\n  return char === void 0 || /[\\s(>,=]/.test(char);\n}\nfunction isBackslashEscaped(string, pos) {\n  var escaped = false;\n  for (var i = pos; i >= 0; i--) {\n    var char = string[i];\n    if (char !== \"\\\\\") {\n      break;\n    }\n    escaped = !escaped;\n  }\n  return escaped;\n}","map":{"version":3,"names":["__export","exports","injectReplacements","import_isPlainObject","__toModule","require","import_sql_string","sqlString","dialect","replacements","_a","_b","_c","_d","Array","isArray","default","TypeError","concat","JSON","stringify","isNamedReplacements","isPositionalReplacements","lastConsumedPositionalReplacementIndex","output","currentDollarStringTagName","isString","isColumn","previousSliceEnd","isSingleLineComment","isCommentBlock","stringIsBackslashEscapable","i","length","char","TICK_CHAR_RIGHT","isBackslashEscaped","remainingString","slice","dollarStringStartMatch","match","_wrapRegExp","name","tagName","groups","TICK_CHAR_LEFT","canBackslashEscape","supports","escapeStringConstants","canPrecedeNewToken","previousChar","test","replacementName","replacementValue","Object","prototype","hasOwnProperty","call","Error","escapedReplacement","escape","nextChar","replacementIndex","string","pos","escaped"],"sources":["../../src/utils/sql.ts"],"sourcesContent":["import isPlainObject from 'lodash/isPlainObject';\nimport type { AbstractDialect } from '../dialects/abstract/index.js';\nimport { escape as escapeSqlValue } from '../sql-string';\n\ntype BindOrReplacements = { [key: string]: unknown } | unknown[];\n\n/**\n * Inlines replacements in places where they would be valid SQL values.\n *\n * @param sqlString The SQL that contains the replacements\n * @param dialect The dialect of the SQL\n * @param replacements if provided, this method will replace ':named' replacements & positional replacements (?)\n *\n * @returns The SQL with replacements rewritten in their dialect-specific syntax.\n */\nexport function injectReplacements(\n  sqlString: string,\n  dialect: AbstractDialect,\n  replacements: BindOrReplacements\n): string {\n  if (replacements == null) {\n    return sqlString;\n  }\n\n  if (!Array.isArray(replacements) && !isPlainObject(replacements)) {\n    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n  }\n\n  const isNamedReplacements = isPlainObject(replacements);\n  const isPositionalReplacements = Array.isArray(replacements);\n  let lastConsumedPositionalReplacementIndex = -1;\n\n  let output = '';\n\n  let currentDollarStringTagName = null;\n  let isString = false;\n  let isColumn = false;\n  let previousSliceEnd = 0;\n  let isSingleLineComment = false;\n  let isCommentBlock = false;\n  let stringIsBackslashEscapable = false;\n\n  for (let i = 0; i < sqlString.length; i++) {\n    const char = sqlString[i];\n\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n\n      continue;\n    }\n\n    if (isString) {\n      if (\n        char === '\\'' &&\n        (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))\n      ) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n\n      continue;\n    }\n\n    if (currentDollarStringTagName !== null) {\n      if (char !== '$') {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      const tagName = dollarStringStartMatch?.groups?.name || '';\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n\n      continue;\n    }\n\n    if (isSingleLineComment) {\n      if (char === '\\n') {\n        isSingleLineComment = false;\n      }\n\n      continue;\n    }\n\n    if (isCommentBlock) {\n      if (char === '*' && sqlString[i + 1] === '/') {\n        isCommentBlock = false;\n      }\n\n      continue;\n    }\n\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n\n    if (char === '\\'') {\n      isString = true;\n\n      // The following query is supported in almost all dialects,\n      //  SELECT E'test';\n      // but postgres interprets it as an E-prefixed string, while other dialects interpret it as\n      //  SELECT E 'test';\n      // which selects the type E and aliases it to 'test'.\n\n      stringIsBackslashEscapable =\n        // all ''-style strings in this dialect can be backslash escaped\n        dialect.canBackslashEscape() ||\n        // checking if this is a postgres-style E-prefixed string, which also supports backslash escaping\n        dialect.supports.escapeStringConstants &&\n          // is this a E-prefixed string, such as `E'abc'`, `e'abc'` ?\n          (sqlString[i - 1] === 'E' || sqlString[i - 1] === 'e') &&\n          // reject things such as `AE'abc'` (the prefix must be exactly E)\n          canPrecedeNewToken(sqlString[i - 2]);\n\n      continue;\n    }\n\n    if (char === '-' && sqlString.slice(i, i + 3) === '-- ') {\n      isSingleLineComment = true;\n      continue;\n    }\n\n    if (char === '/' && sqlString.slice(i, i + 2) === '/*') {\n      isCommentBlock = true;\n      continue;\n    }\n\n    // either the start of a $bind parameter, or the start of a $tag$string$tag$\n    if (char === '$') {\n      const previousChar = sqlString[i - 1];\n\n      // we are part of an identifier\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      if (dollarStringStartMatch) {\n        currentDollarStringTagName = dollarStringStartMatch.groups?.name ?? '';\n        i += dollarStringStartMatch[0].length - 1;\n\n        continue;\n      }\n\n      continue;\n    }\n\n    if (isNamedReplacements && char === ':') {\n      const previousChar = sqlString[i - 1];\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n      // users need to add a space before the bind parameter (except after '(', ',', and '=', '[' (for arrays))\n      if (!canPrecedeNewToken(previousChar) && previousChar !== '[') {\n        continue;\n      }\n\n      const remainingString = sqlString.slice(i, sqlString.length);\n\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\n      const replacementName = match?.groups?.name;\n      if (!replacementName) {\n        continue;\n      }\n\n      // @ts-expect-error -- isPlainObject does not tell typescript that replacements is a plain object, not an array\n      const replacementValue = replacements[replacementName];\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === undefined) {\n        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n      }\n\n      const escapedReplacement = escapeSqlValue(replacementValue, undefined, dialect.name, true);\n\n      // add everything before the bind parameter name\n      output += sqlString.slice(previousSliceEnd, i);\n      // continue after the bind parameter name\n      previousSliceEnd = i + replacementName.length + 1;\n\n      output += escapedReplacement;\n\n      continue;\n    }\n\n    if (isPositionalReplacements && char === '?') {\n      const previousChar = sqlString[i - 1];\n\n      // we want to be conservative with what we consider to be a replacement to avoid risk of conflict with potential operators\n      // users need to add a space before the bind parameter (except after '(', ',', and '=', '[' (for arrays))\n      // -> [ is temporarily added to allow 'ARRAY[:name]' to be replaced\n      // https://github.com/sequelize/sequelize/issues/14410 will make this obsolete.\n      if (!canPrecedeNewToken(previousChar) && previousChar !== '[') {\n        continue;\n      }\n\n      // don't parse ?| and ?& operators as replacements\n      const nextChar = sqlString[i + 1];\n      if (nextChar === '|' || nextChar === '&') {\n        continue;\n      }\n\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore -- ts < 4.4 loses the information that 'replacements' is an array when using 'isPositionalReplacements' instead of 'Array.isArray'\n      //  but performance matters here.\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n\n      if (replacementValue === undefined) {\n        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n      }\n\n      const escapedReplacement = escapeSqlValue(replacementValue as any, undefined, dialect.name, true);\n\n      // add everything before the bind parameter name\n      output += sqlString.slice(previousSliceEnd, i);\n      // continue after the bind parameter name\n      previousSliceEnd = i + 1;\n\n      output += escapedReplacement;\n    }\n  }\n\n  if (isString) {\n    throw new Error(\n      `The following SQL query includes an unterminated string literal:\\n${sqlString}`\n    );\n  }\n\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n\n  return output;\n}\n\nfunction canPrecedeNewToken(char: string | undefined): boolean {\n  return char === undefined || /[\\s(>,=]/.test(char);\n}\n\nfunction isBackslashEscaped(string: string, pos: number): boolean {\n  let escaped = false;\n  for (let i = pos; i >= 0; i--) {\n    const char = string[i];\n    if (char !== '\\\\') {\n      break;\n    }\n\n    escaped = !escaped;\n  }\n\n  return escaped;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}