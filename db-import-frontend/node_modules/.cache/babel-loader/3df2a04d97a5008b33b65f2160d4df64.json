{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar debug = require('debug')('nock.request_overrider');\nvar _require = require('http'),\n  IncomingMessage = _require.IncomingMessage,\n  ClientRequest = _require.ClientRequest,\n  originalHttpRequest = _require.request;\nvar _require2 = require('https'),\n  originalHttpsRequest = _require2.request;\nvar propagate = require('propagate');\nvar common = require('./common');\nvar globalEmitter = require('./global_emitter');\nvar Socket = require('./socket');\nvar _require3 = require('./playback_interceptor'),\n  playbackInterceptor = _require3.playbackInterceptor;\nfunction socketOnClose(req) {\n  debug('socket close');\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.socket._hadError = true;\n    var err = new Error('socket hang up');\n    err.code = 'ECONNRESET';\n    req.emit('error', err);\n  }\n  req.emit('close');\n}\n\n/**\n * Given a group of interceptors, appropriately route an outgoing request.\n * Identify which interceptor ought to respond, if any, then delegate to\n * `playbackInterceptor()` to consume the request itself.\n */\nvar InterceptedRequestRouter = /*#__PURE__*/function () {\n  function InterceptedRequestRouter(_ref) {\n    var _this = this;\n    var req = _ref.req,\n      options = _ref.options,\n      interceptors = _ref.interceptors;\n    _classCallCheck(this, InterceptedRequestRouter);\n    this.req = req;\n    this.options = _objectSpread(_objectSpread({}, options), {}, {\n      // We use lower-case header field names throughout Nock.\n      headers: common.headersFieldNamesToLowerCase(options.headers || {}, false)\n    });\n    this.interceptors = interceptors;\n    this.socket = new Socket(options);\n\n    // support setting `timeout` using request `options`\n    // https://nodejs.org/docs/latest-v12.x/api/http.html#http_http_request_url_options_callback\n    // any timeout in the request options override any timeout in the agent options.\n    // per https://github.com/nodejs/node/pull/21204\n    var timeout = options.timeout || options.agent && options.agent.options && options.agent.options.timeout;\n    if (timeout) {\n      this.socket.setTimeout(timeout);\n    }\n    this.response = new IncomingMessage(this.socket);\n    this.requestBodyBuffers = [];\n    this.playbackStarted = false;\n\n    // For parity with Node, it's important the socket event is emitted before we begin playback.\n    // This flag is set when playback is triggered if we haven't yet gotten the\n    // socket event to indicate that playback should start as soon as it comes in.\n    this.readyToStartPlaybackOnSocketEvent = false;\n    this.attachToReq();\n\n    // Emit a fake socket event on the next tick to mimic what would happen on a real request.\n    // Some clients listen for a 'socket' event to be emitted before calling end(),\n    // which causes Nock to hang.\n    process.nextTick(function () {\n      return _this.connectSocket();\n    });\n  }\n  _createClass(InterceptedRequestRouter, [{\n    key: \"attachToReq\",\n    value: function attachToReq() {\n      var _this2 = this;\n      var req = this.req,\n        options = this.options;\n      for (var _i = 0, _Object$entries = Object.entries(options.headers); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          name = _Object$entries$_i[0],\n          val = _Object$entries$_i[1];\n        req.setHeader(name.toLowerCase(), val);\n      }\n      if (options.auth && !options.headers.authorization) {\n        req.setHeader(\n        // We use lower-case header field names throughout Nock.\n        'authorization', \"Basic \".concat(Buffer.from(options.auth).toString('base64')));\n      }\n      req.path = options.path;\n      req.method = options.method;\n      req.write = function () {\n        return _this2.handleWrite.apply(_this2, arguments);\n      };\n      req.end = function () {\n        return _this2.handleEnd.apply(_this2, arguments);\n      };\n      req.flushHeaders = function () {\n        return _this2.handleFlushHeaders.apply(_this2, arguments);\n      };\n\n      // https://github.com/nock/nock/issues/256\n      if (options.headers.expect === '100-continue') {\n        common.setImmediate(function () {\n          debug('continue');\n          req.emit('continue');\n        });\n      }\n    }\n  }, {\n    key: \"connectSocket\",\n    value: function connectSocket() {\n      var req = this.req,\n        socket = this.socket;\n      if (common.isRequestDestroyed(req)) {\n        return;\n      }\n\n      // ClientRequest.connection is an alias for ClientRequest.socket\n      // https://nodejs.org/api/http.html#http_request_socket\n      // https://github.com/nodejs/node/blob/b0f75818f39ed4e6bd80eb7c4010c1daf5823ef7/lib/_http_client.js#L640-L641\n      // The same Socket is shared between the request and response to mimic native behavior.\n      req.socket = req.connection = socket;\n      propagate(['error', 'timeout'], socket, req);\n      socket.on('close', function () {\n        return socketOnClose(req);\n      });\n      socket.connecting = false;\n      req.emit('socket', socket);\n\n      // https://nodejs.org/api/net.html#net_event_connect\n      socket.emit('connect');\n\n      // https://nodejs.org/api/tls.html#tls_event_secureconnect\n      if (socket.authorized) {\n        socket.emit('secureConnect');\n      }\n      if (this.readyToStartPlaybackOnSocketEvent) {\n        this.maybeStartPlayback();\n      }\n    }\n\n    // from docs: When write function is called with empty string or buffer, it does nothing and waits for more input.\n    // However, actually implementation checks the state of finished and aborted before checking if the first arg is empty.\n  }, {\n    key: \"handleWrite\",\n    value: function handleWrite() {\n      debug('request write');\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var buffer = args[0],\n        encoding = args[1];\n      var req = this.req;\n      if (req.finished) {\n        var err = new Error('write after end');\n        err.code = 'ERR_STREAM_WRITE_AFTER_END';\n        process.nextTick(function () {\n          return req.emit('error', err);\n        });\n\n        // It seems odd to return `true` here, not sure why you'd want to have\n        // the stream potentially written to more, but it's what Node does.\n        // https://github.com/nodejs/node/blob/a9270dcbeba4316b1e179b77ecb6c46af5aa8c20/lib/_http_outgoing.js#L662-L665\n        return true;\n      }\n      if (req.socket && req.socket.destroyed) {\n        return false;\n      }\n      if (!buffer) {\n        return true;\n      }\n      if (!Buffer.isBuffer(buffer)) {\n        buffer = Buffer.from(buffer, encoding);\n      }\n      this.requestBodyBuffers.push(buffer);\n\n      // writable.write encoding param is optional\n      // so if callback is present it's the last argument\n      var callback = args.length > 1 ? args[args.length - 1] : undefined;\n      // can't use instanceof Function because some test runners\n      // run tests in vm.runInNewContext where Function is not same\n      // as that in the current context\n      // https://github.com/nock/nock/pull/1754#issuecomment-571531407\n      if (typeof callback === 'function') {\n        callback();\n      }\n      common.setImmediate(function () {\n        req.emit('drain');\n      });\n      return false;\n    }\n  }, {\n    key: \"handleEnd\",\n    value: function handleEnd(chunk, encoding, callback) {\n      debug('request end');\n      var req = this.req;\n\n      // handle the different overloaded arg signatures\n      if (typeof chunk === 'function') {\n        callback = chunk;\n        chunk = null;\n      } else if (typeof encoding === 'function') {\n        callback = encoding;\n        encoding = null;\n      }\n      if (typeof callback === 'function') {\n        req.once('finish', callback);\n      }\n      if (chunk) {\n        req.write(chunk, encoding);\n      }\n      req.finished = true;\n      this.maybeStartPlayback();\n      return req;\n    }\n  }, {\n    key: \"handleFlushHeaders\",\n    value: function handleFlushHeaders() {\n      debug('request flushHeaders');\n      this.maybeStartPlayback();\n    }\n\n    /**\n     * Set request headers of the given request. This is needed both during the\n     * routing phase, in case header filters were specified, and during the\n     * interceptor-playback phase, to correctly pass mocked request headers.\n     * TODO There are some problems with this; see https://github.com/nock/nock/issues/1718\n     */\n  }, {\n    key: \"setHostHeaderUsingInterceptor\",\n    value: function setHostHeaderUsingInterceptor(interceptor) {\n      var req = this.req,\n        options = this.options;\n\n      // If a filtered scope is being used we have to use scope's host in the\n      // header, otherwise 'host' header won't match.\n      // NOTE: We use lower-case header field names throughout Nock.\n      var HOST_HEADER = 'host';\n      if (interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {\n        options.headers[HOST_HEADER] = interceptor.__nock_scopeHost;\n        req.setHeader(HOST_HEADER, interceptor.__nock_scopeHost);\n      } else {\n        // For all other cases, we always add host header equal to the requested\n        // host unless it was already defined.\n        if (options.host && !req.getHeader(HOST_HEADER)) {\n          var hostHeader = options.host;\n          if (options.port === 80 || options.port === 443) {\n            hostHeader = hostHeader.split(':')[0];\n          }\n          req.setHeader(HOST_HEADER, hostHeader);\n        }\n      }\n    }\n  }, {\n    key: \"maybeStartPlayback\",\n    value: function maybeStartPlayback() {\n      var req = this.req,\n        socket = this.socket,\n        playbackStarted = this.playbackStarted;\n\n      // In order to get the events in the right order we need to delay playback\n      // if we get here before the `socket` event is emitted.\n      if (socket.connecting) {\n        this.readyToStartPlaybackOnSocketEvent = true;\n        return;\n      }\n      if (!common.isRequestDestroyed(req) && !playbackStarted) {\n        this.startPlayback();\n      }\n    }\n  }, {\n    key: \"startPlayback\",\n    value: function startPlayback() {\n      var _this3 = this;\n      debug('ending');\n      this.playbackStarted = true;\n      var req = this.req,\n        response = this.response,\n        socket = this.socket,\n        options = this.options,\n        interceptors = this.interceptors;\n      Object.assign(options, {\n        // Re-update `options` with the current value of `req.path` because badly\n        // behaving agents like superagent like to change `req.path` mid-flight.\n        path: req.path,\n        // Similarly, node-http-proxy will modify headers in flight, so we have\n        // to put the headers back into options.\n        // https://github.com/nock/nock/pull/1484\n        headers: req.getHeaders(),\n        // Fixes https://github.com/nock/nock/issues/976\n        protocol: \"\".concat(options.proto, \":\")\n      });\n      interceptors.forEach(function (interceptor) {\n        _this3.setHostHeaderUsingInterceptor(interceptor);\n      });\n      var requestBodyBuffer = Buffer.concat(this.requestBodyBuffers);\n      // When request body is a binary buffer we internally use in its hexadecimal\n      // representation.\n      var requestBodyIsUtf8Representable = common.isUtf8Representable(requestBodyBuffer);\n      var requestBodyString = requestBodyBuffer.toString(requestBodyIsUtf8Representable ? 'utf8' : 'hex');\n      var matchedInterceptor = interceptors.find(function (i) {\n        return i.match(req, options, requestBodyString);\n      });\n      if (matchedInterceptor) {\n        matchedInterceptor.scope.logger('interceptor identified, starting mocking');\n        matchedInterceptor.markConsumed();\n\n        // wait to emit the finish event until we know for sure an Interceptor is going to playback.\n        // otherwise an unmocked request might emit finish twice.\n        req.emit('finish');\n        playbackInterceptor({\n          req: req,\n          socket: socket,\n          options: options,\n          requestBodyString: requestBodyString,\n          requestBodyIsUtf8Representable: requestBodyIsUtf8Representable,\n          response: response,\n          interceptor: matchedInterceptor\n        });\n      } else {\n        globalEmitter.emit('no match', req, options, requestBodyString);\n\n        // Try to find a hostname match that allows unmocked.\n        var allowUnmocked = interceptors.some(function (i) {\n          return i.matchHostName(options) && i.options.allowUnmocked;\n        });\n        if (allowUnmocked && req instanceof ClientRequest) {\n          var newReq = options.proto === 'https' ? originalHttpsRequest(options) : originalHttpRequest(options);\n          propagate(newReq, req);\n          // We send the raw buffer as we received it, not as we interpreted it.\n          newReq.end(requestBodyBuffer);\n        } else {\n          var reqStr = common.stringifyRequest(options, requestBodyString);\n          var err = new Error(\"Nock: No match for request \".concat(reqStr));\n          err.code = 'ERR_NOCK_NO_MATCH';\n          err.statusCode = err.status = 404;\n          req.destroy(err);\n        }\n      }\n    }\n  }]);\n  return InterceptedRequestRouter;\n}();\nmodule.exports = {\n  InterceptedRequestRouter: InterceptedRequestRouter\n};","map":{"version":3,"names":["_slicedToArray","require","default","_objectSpread","_classCallCheck","_createClass","debug","_require","IncomingMessage","ClientRequest","originalHttpRequest","request","_require2","originalHttpsRequest","propagate","common","globalEmitter","Socket","_require3","playbackInterceptor","socketOnClose","req","res","socket","_hadError","err","Error","code","emit","InterceptedRequestRouter","_ref","_this","options","interceptors","headers","headersFieldNamesToLowerCase","timeout","agent","setTimeout","response","requestBodyBuffers","playbackStarted","readyToStartPlaybackOnSocketEvent","attachToReq","process","nextTick","connectSocket","key","value","_this2","_i","_Object$entries","Object","entries","length","_Object$entries$_i","name","val","setHeader","toLowerCase","auth","authorization","concat","Buffer","from","toString","path","method","write","handleWrite","apply","arguments","end","handleEnd","flushHeaders","handleFlushHeaders","expect","setImmediate","isRequestDestroyed","connection","on","connecting","authorized","maybeStartPlayback","_len","args","Array","_key","buffer","encoding","finished","destroyed","isBuffer","push","callback","undefined","chunk","once","setHostHeaderUsingInterceptor","interceptor","HOST_HEADER","__nock_filteredScope","__nock_scopeHost","host","getHeader","hostHeader","port","split","startPlayback","_this3","assign","getHeaders","protocol","proto","forEach","requestBodyBuffer","requestBodyIsUtf8Representable","isUtf8Representable","requestBodyString","matchedInterceptor","find","i","match","scope","logger","markConsumed","allowUnmocked","some","matchHostName","newReq","reqStr","stringifyRequest","statusCode","status","destroy","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/nock/lib/intercepted_request_router.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')('nock.request_overrider')\nconst {\n  IncomingMessage,\n  ClientRequest,\n  request: originalHttpRequest,\n} = require('http')\nconst { request: originalHttpsRequest } = require('https')\nconst propagate = require('propagate')\nconst common = require('./common')\nconst globalEmitter = require('./global_emitter')\nconst Socket = require('./socket')\nconst { playbackInterceptor } = require('./playback_interceptor')\n\nfunction socketOnClose(req) {\n  debug('socket close')\n\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.socket._hadError = true\n    const err = new Error('socket hang up')\n    err.code = 'ECONNRESET'\n    req.emit('error', err)\n  }\n  req.emit('close')\n}\n\n/**\n * Given a group of interceptors, appropriately route an outgoing request.\n * Identify which interceptor ought to respond, if any, then delegate to\n * `playbackInterceptor()` to consume the request itself.\n */\nclass InterceptedRequestRouter {\n  constructor({ req, options, interceptors }) {\n    this.req = req\n    this.options = {\n      // We may be changing the options object and we don't want those changes\n      // affecting the user so we use a clone of the object.\n      ...options,\n      // We use lower-case header field names throughout Nock.\n      headers: common.headersFieldNamesToLowerCase(\n        options.headers || {},\n        false\n      ),\n    }\n    this.interceptors = interceptors\n\n    this.socket = new Socket(options)\n\n    // support setting `timeout` using request `options`\n    // https://nodejs.org/docs/latest-v12.x/api/http.html#http_http_request_url_options_callback\n    // any timeout in the request options override any timeout in the agent options.\n    // per https://github.com/nodejs/node/pull/21204\n    const timeout =\n      options.timeout ||\n      (options.agent && options.agent.options && options.agent.options.timeout)\n\n    if (timeout) {\n      this.socket.setTimeout(timeout)\n    }\n\n    this.response = new IncomingMessage(this.socket)\n    this.requestBodyBuffers = []\n    this.playbackStarted = false\n\n    // For parity with Node, it's important the socket event is emitted before we begin playback.\n    // This flag is set when playback is triggered if we haven't yet gotten the\n    // socket event to indicate that playback should start as soon as it comes in.\n    this.readyToStartPlaybackOnSocketEvent = false\n\n    this.attachToReq()\n\n    // Emit a fake socket event on the next tick to mimic what would happen on a real request.\n    // Some clients listen for a 'socket' event to be emitted before calling end(),\n    // which causes Nock to hang.\n    process.nextTick(() => this.connectSocket())\n  }\n\n  attachToReq() {\n    const { req, options } = this\n\n    for (const [name, val] of Object.entries(options.headers)) {\n      req.setHeader(name.toLowerCase(), val)\n    }\n\n    if (options.auth && !options.headers.authorization) {\n      req.setHeader(\n        // We use lower-case header field names throughout Nock.\n        'authorization',\n        `Basic ${Buffer.from(options.auth).toString('base64')}`\n      )\n    }\n\n    req.path = options.path\n    req.method = options.method\n\n    req.write = (...args) => this.handleWrite(...args)\n    req.end = (...args) => this.handleEnd(...args)\n    req.flushHeaders = (...args) => this.handleFlushHeaders(...args)\n\n    // https://github.com/nock/nock/issues/256\n    if (options.headers.expect === '100-continue') {\n      common.setImmediate(() => {\n        debug('continue')\n        req.emit('continue')\n      })\n    }\n  }\n\n  connectSocket() {\n    const { req, socket } = this\n\n    if (common.isRequestDestroyed(req)) {\n      return\n    }\n\n    // ClientRequest.connection is an alias for ClientRequest.socket\n    // https://nodejs.org/api/http.html#http_request_socket\n    // https://github.com/nodejs/node/blob/b0f75818f39ed4e6bd80eb7c4010c1daf5823ef7/lib/_http_client.js#L640-L641\n    // The same Socket is shared between the request and response to mimic native behavior.\n    req.socket = req.connection = socket\n\n    propagate(['error', 'timeout'], socket, req)\n    socket.on('close', () => socketOnClose(req))\n\n    socket.connecting = false\n    req.emit('socket', socket)\n\n    // https://nodejs.org/api/net.html#net_event_connect\n    socket.emit('connect')\n\n    // https://nodejs.org/api/tls.html#tls_event_secureconnect\n    if (socket.authorized) {\n      socket.emit('secureConnect')\n    }\n\n    if (this.readyToStartPlaybackOnSocketEvent) {\n      this.maybeStartPlayback()\n    }\n  }\n\n  // from docs: When write function is called with empty string or buffer, it does nothing and waits for more input.\n  // However, actually implementation checks the state of finished and aborted before checking if the first arg is empty.\n  handleWrite(...args) {\n    debug('request write')\n\n    let [buffer, encoding] = args\n\n    const { req } = this\n\n    if (req.finished) {\n      const err = new Error('write after end')\n      err.code = 'ERR_STREAM_WRITE_AFTER_END'\n      process.nextTick(() => req.emit('error', err))\n\n      // It seems odd to return `true` here, not sure why you'd want to have\n      // the stream potentially written to more, but it's what Node does.\n      // https://github.com/nodejs/node/blob/a9270dcbeba4316b1e179b77ecb6c46af5aa8c20/lib/_http_outgoing.js#L662-L665\n      return true\n    }\n\n    if (req.socket && req.socket.destroyed) {\n      return false\n    }\n\n    if (!buffer) {\n      return true\n    }\n\n    if (!Buffer.isBuffer(buffer)) {\n      buffer = Buffer.from(buffer, encoding)\n    }\n    this.requestBodyBuffers.push(buffer)\n\n    // writable.write encoding param is optional\n    // so if callback is present it's the last argument\n    const callback = args.length > 1 ? args[args.length - 1] : undefined\n    // can't use instanceof Function because some test runners\n    // run tests in vm.runInNewContext where Function is not same\n    // as that in the current context\n    // https://github.com/nock/nock/pull/1754#issuecomment-571531407\n    if (typeof callback === 'function') {\n      callback()\n    }\n\n    common.setImmediate(function () {\n      req.emit('drain')\n    })\n\n    return false\n  }\n\n  handleEnd(chunk, encoding, callback) {\n    debug('request end')\n    const { req } = this\n\n    // handle the different overloaded arg signatures\n    if (typeof chunk === 'function') {\n      callback = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      callback = encoding\n      encoding = null\n    }\n\n    if (typeof callback === 'function') {\n      req.once('finish', callback)\n    }\n\n    if (chunk) {\n      req.write(chunk, encoding)\n    }\n    req.finished = true\n    this.maybeStartPlayback()\n\n    return req\n  }\n\n  handleFlushHeaders() {\n    debug('request flushHeaders')\n    this.maybeStartPlayback()\n  }\n\n  /**\n   * Set request headers of the given request. This is needed both during the\n   * routing phase, in case header filters were specified, and during the\n   * interceptor-playback phase, to correctly pass mocked request headers.\n   * TODO There are some problems with this; see https://github.com/nock/nock/issues/1718\n   */\n  setHostHeaderUsingInterceptor(interceptor) {\n    const { req, options } = this\n\n    // If a filtered scope is being used we have to use scope's host in the\n    // header, otherwise 'host' header won't match.\n    // NOTE: We use lower-case header field names throughout Nock.\n    const HOST_HEADER = 'host'\n    if (interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {\n      options.headers[HOST_HEADER] = interceptor.__nock_scopeHost\n      req.setHeader(HOST_HEADER, interceptor.__nock_scopeHost)\n    } else {\n      // For all other cases, we always add host header equal to the requested\n      // host unless it was already defined.\n      if (options.host && !req.getHeader(HOST_HEADER)) {\n        let hostHeader = options.host\n\n        if (options.port === 80 || options.port === 443) {\n          hostHeader = hostHeader.split(':')[0]\n        }\n\n        req.setHeader(HOST_HEADER, hostHeader)\n      }\n    }\n  }\n\n  maybeStartPlayback() {\n    const { req, socket, playbackStarted } = this\n\n    // In order to get the events in the right order we need to delay playback\n    // if we get here before the `socket` event is emitted.\n    if (socket.connecting) {\n      this.readyToStartPlaybackOnSocketEvent = true\n      return\n    }\n\n    if (!common.isRequestDestroyed(req) && !playbackStarted) {\n      this.startPlayback()\n    }\n  }\n\n  startPlayback() {\n    debug('ending')\n    this.playbackStarted = true\n\n    const { req, response, socket, options, interceptors } = this\n\n    Object.assign(options, {\n      // Re-update `options` with the current value of `req.path` because badly\n      // behaving agents like superagent like to change `req.path` mid-flight.\n      path: req.path,\n      // Similarly, node-http-proxy will modify headers in flight, so we have\n      // to put the headers back into options.\n      // https://github.com/nock/nock/pull/1484\n      headers: req.getHeaders(),\n      // Fixes https://github.com/nock/nock/issues/976\n      protocol: `${options.proto}:`,\n    })\n\n    interceptors.forEach(interceptor => {\n      this.setHostHeaderUsingInterceptor(interceptor)\n    })\n\n    const requestBodyBuffer = Buffer.concat(this.requestBodyBuffers)\n    // When request body is a binary buffer we internally use in its hexadecimal\n    // representation.\n    const requestBodyIsUtf8Representable =\n      common.isUtf8Representable(requestBodyBuffer)\n    const requestBodyString = requestBodyBuffer.toString(\n      requestBodyIsUtf8Representable ? 'utf8' : 'hex'\n    )\n\n    const matchedInterceptor = interceptors.find(i =>\n      i.match(req, options, requestBodyString)\n    )\n\n    if (matchedInterceptor) {\n      matchedInterceptor.scope.logger(\n        'interceptor identified, starting mocking'\n      )\n\n      matchedInterceptor.markConsumed()\n\n      // wait to emit the finish event until we know for sure an Interceptor is going to playback.\n      // otherwise an unmocked request might emit finish twice.\n      req.emit('finish')\n\n      playbackInterceptor({\n        req,\n        socket,\n        options,\n        requestBodyString,\n        requestBodyIsUtf8Representable,\n        response,\n        interceptor: matchedInterceptor,\n      })\n    } else {\n      globalEmitter.emit('no match', req, options, requestBodyString)\n\n      // Try to find a hostname match that allows unmocked.\n      const allowUnmocked = interceptors.some(\n        i => i.matchHostName(options) && i.options.allowUnmocked\n      )\n\n      if (allowUnmocked && req instanceof ClientRequest) {\n        const newReq =\n          options.proto === 'https'\n            ? originalHttpsRequest(options)\n            : originalHttpRequest(options)\n\n        propagate(newReq, req)\n        // We send the raw buffer as we received it, not as we interpreted it.\n        newReq.end(requestBodyBuffer)\n      } else {\n        const reqStr = common.stringifyRequest(options, requestBodyString)\n        const err = new Error(`Nock: No match for request ${reqStr}`)\n        err.code = 'ERR_NOCK_NO_MATCH'\n        err.statusCode = err.status = 404\n        req.destroy(err)\n      }\n    }\n  }\n}\n\nmodule.exports = { InterceptedRequestRouter }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}