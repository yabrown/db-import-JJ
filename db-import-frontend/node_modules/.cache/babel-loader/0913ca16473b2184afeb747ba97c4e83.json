{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar AggregateError = require('aggregate-error');\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iterable, mapper) {\n    var _ref2,\n      _ref2$concurrency,\n      concurrency,\n      _ref2$stopOnError,\n      stopOnError,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _ref2 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref2$concurrency = _ref2.concurrency, concurrency = _ref2$concurrency === void 0 ? Infinity : _ref2$concurrency, _ref2$stopOnError = _ref2.stopOnError, stopOnError = _ref2$stopOnError === void 0 ? true : _ref2$stopOnError;\n          return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n            if (typeof mapper !== 'function') {\n              throw new TypeError('Mapper function is required');\n            }\n            if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n              throw new TypeError(\"Expected `concurrency` to be an integer from 1 and up or `Infinity`, got `\".concat(concurrency, \"` (\").concat(typeof concurrency, \")\"));\n            }\n            var result = [];\n            var errors = [];\n            var iterator = iterable[Symbol.iterator]();\n            var isRejected = false;\n            var isIterableDone = false;\n            var resolvingCount = 0;\n            var currentIndex = 0;\n            var next = function next() {\n              if (isRejected) {\n                return;\n              }\n              var nextItem = iterator.next();\n              var index = currentIndex;\n              currentIndex++;\n              if (nextItem.done) {\n                isIterableDone = true;\n                if (resolvingCount === 0) {\n                  if (!stopOnError && errors.length !== 0) {\n                    reject(new AggregateError(errors));\n                  } else {\n                    resolve(result);\n                  }\n                }\n                return;\n              }\n              resolvingCount++;\n              _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var element;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.prev = 0;\n                      _context.next = 3;\n                      return nextItem.value;\n                    case 3:\n                      element = _context.sent;\n                      _context.next = 6;\n                      return mapper(element, index);\n                    case 6:\n                      result[index] = _context.sent;\n                      resolvingCount--;\n                      next();\n                      _context.next = 14;\n                      break;\n                    case 11:\n                      _context.prev = 11;\n                      _context.t0 = _context[\"catch\"](0);\n                      if (stopOnError) {\n                        isRejected = true;\n                        reject(_context.t0);\n                      } else {\n                        errors.push(_context.t0);\n                        resolvingCount--;\n                        next();\n                      }\n                    case 14:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _callee, null, [[0, 11]]);\n              }))();\n            };\n            for (var i = 0; i < concurrency; i++) {\n              next();\n              if (isIterableDone) {\n                break;\n              }\n            }\n          }));\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["_regeneratorRuntime","require","default","_asyncToGenerator","AggregateError","module","exports","_ref","mark","_callee2","iterable","mapper","_ref2","_ref2$concurrency","concurrency","_ref2$stopOnError","stopOnError","_args2","arguments","wrap","_callee2$","_context2","prev","next","length","undefined","Infinity","abrupt","Promise","resolve","reject","TypeError","Number","isSafeInteger","concat","result","errors","iterator","Symbol","isRejected","isIterableDone","resolvingCount","currentIndex","nextItem","index","done","_callee","element","_callee$","_context","value","sent","t0","push","stop","i","_x","_x2","apply"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/p-map/index.js"],"sourcesContent":["'use strict';\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tresult[index] = await mapper(element, index);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}