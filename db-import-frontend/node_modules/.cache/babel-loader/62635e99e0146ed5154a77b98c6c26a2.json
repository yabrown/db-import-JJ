{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withTimeout = withTimeout;\nvar _nodeAbortController = require(\"node-abort-controller\");\nvar _timeoutError = _interopRequireDefault(require(\"../errors/timeout-error\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Run the function `func` with an `AbortSignal` that will automatically abort after the time specified\n * by `timeout` or when the given `signal` is aborted.\n *\n * On timeout, the `timeoutSignal` will be aborted and a `TimeoutError` will be thrown.\n */\nfunction withTimeout(_x, _x2, _x3) {\n  return _withTimeout.apply(this, arguments);\n}\nfunction _withTimeout() {\n  _withTimeout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(timeout, func, signal) {\n    var timeoutController, abortCurrentAttempt, timer;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          timeoutController = new _nodeAbortController.AbortController();\n          abortCurrentAttempt = function abortCurrentAttempt() {\n            timeoutController.abort();\n          };\n          timer = setTimeout(abortCurrentAttempt, timeout);\n          signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', abortCurrentAttempt, {\n            once: true\n          });\n          _context.prev = 4;\n          _context.next = 7;\n          return func(timeoutController.signal);\n        case 7:\n          return _context.abrupt(\"return\", _context.sent);\n        case 10:\n          _context.prev = 10;\n          _context.t0 = _context[\"catch\"](4);\n          if (!(_context.t0 instanceof Error && _context.t0.name === 'AbortError' && !(signal && signal.aborted))) {\n            _context.next = 14;\n            break;\n          }\n          throw new _timeoutError.default();\n        case 14:\n          throw _context.t0;\n        case 15:\n          _context.prev = 15;\n          signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', abortCurrentAttempt);\n          clearTimeout(timer);\n          return _context.finish(15);\n        case 19:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[4, 10, 15, 19]]);\n  }));\n  return _withTimeout.apply(this, arguments);\n}","map":{"version":3,"names":["_nodeAbortController","require","_timeoutError","_interopRequireDefault","withTimeout","_x","_x2","_x3","_withTimeout","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","timeout","func","signal","timeoutController","abortCurrentAttempt","timer","wrap","_callee$","_context","prev","next","AbortController","abort","setTimeout","addEventListener","once","abrupt","sent","t0","Error","name","aborted","default","removeEventListener","clearTimeout","finish","stop"],"sources":["../../src/utils/with-timeout.ts"],"sourcesContent":["import { AbortController, AbortSignal } from 'node-abort-controller';\nimport TimeoutError from '../errors/timeout-error';\n\n/**\n * Run the function `func` with an `AbortSignal` that will automatically abort after the time specified\n * by `timeout` or when the given `signal` is aborted.\n *\n * On timeout, the `timeoutSignal` will be aborted and a `TimeoutError` will be thrown.\n */\nexport async function withTimeout<T>(timeout: number, func: (timeoutSignal: AbortSignal) => Promise<T>, signal?: AbortSignal): Promise<T> {\n  const timeoutController = new AbortController();\n  const abortCurrentAttempt = () => { timeoutController.abort(); };\n\n  const timer = setTimeout(abortCurrentAttempt, timeout);\n  signal?.addEventListener('abort', abortCurrentAttempt, { once: true });\n\n  try {\n    return await func(timeoutController.signal);\n  } catch (err) {\n    if (err instanceof Error && err.name === 'AbortError' && !(signal && signal.aborted)) {\n      throw new TimeoutError();\n    }\n\n    throw err;\n  } finally {\n    signal?.removeEventListener('abort', abortCurrentAttempt);\n    clearTimeout(timer);\n  }\n}\n"],"mappings":";;;;;;;;AAAA,IAAAA,oBAAA,GAAAC,OAAA;AACA,IAAAC,aAAA,GAAAC,sBAAA,CAAAF,OAAA;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA,SAMsBG,WAAfA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,YAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,aAAA;EAAAA,YAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,UAAAC,QAA8BC,OAA9B,EAA+CC,IAA/C,EAAiGC,MAAjG;IAAA,IAAAC,iBAAA,EAAAC,mBAAA,EAAAC,KAAA;IAAA,OAAAR,mBAAA,GAAAS,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UACCP,iBAAiB,GAAG,IAAIlB,oBAAA,CAAA0B,eAAJ,EAA1B;UACMP,mBAAmB,GAAG,SAAtBA,mBAAmBA,CAAA,EAAS;YAAED,iBAAiB,CAACS,KAAlB;UAA4B,CAAhE;UAEMP,KAAK,GAAGQ,UAAU,CAACT,mBAAD,EAAsBJ,OAAtB,CAAxB;UACAE,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEY,gBAAR,CAAyB,OAAzB,EAAkCV,mBAAlC,EAAuD;YAAEW,IAAI,EAAE;UAAR,CAAvD;UAAAP,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAE,IAAA;UAAA,OAGeT,IAAI,CAACE,iBAAiB,CAACD,MAAnB,CAAjB;QAAA;UAAA,OAAAM,QAAA,CAAAQ,MAAA,WAAAR,QAAA,CAAAS,IAAA;QAAA;UAAAT,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAU,EAAA,GAAAV,QAAA;UAAA,MAEIA,QAAA,CAAAU,EAAA,YAAeC,KAAf,IAAwBX,QAAA,CAAAU,EAAA,CAAIE,IAAJ,KAAa,YAArC,IAAqD,EAAElB,MAAM,IAAIA,MAAM,CAACmB,OAAnB,CAAzD;YAAAb,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACQ,IAAIvB,aAAA,CAAAmC,OAAJ,EAAN;QAAA;UAAA,MAAAd,QAAA,CAAAU,EAAA;QAAA;UAAAV,QAAA,CAAAC,IAAA;UAKFP,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAEqB,mBAAR,CAA4B,OAA5B,EAAqCnB,mBAArC;UACAoB,YAAY,CAACnB,KAAD,CAAZ;UAAA,OAAAG,QAAA,CAAAiB,MAAA;QAAA;QAAA;UAAA,OAAAjB,QAAA,CAAAkB,IAAA;MAAA;IAAA,GAAA3B,OAAA;EAAA,CAEH;EAAA,OAAAN,YAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"script"}