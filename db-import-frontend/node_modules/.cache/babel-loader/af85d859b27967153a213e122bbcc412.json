{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _require = require('minipass-fetch'),\n  FetchError = _require.FetchError,\n  Request = _require.Request,\n  isRedirect = _require.isRedirect;\nvar url = require('url');\nvar CachePolicy = require('./cache/policy.js');\nvar cache = require('./cache/index.js');\nvar remote = require('./remote.js');\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nvar canFollowRedirect = function canFollowRedirect(request, response, options) {\n  if (!isRedirect(response.status)) return false;\n  if (options.redirect === 'manual') return false;\n  if (options.redirect === 'error') throw new FetchError(\"redirect mode is set to error: \".concat(request.url), 'no-redirect', {\n    code: 'ENOREDIRECT'\n  });\n  if (!response.headers.has('location')) throw new FetchError(\"redirect location header missing for: \".concat(request.url), 'no-location', {\n    code: 'EINVALIDREDIRECT'\n  });\n  if (request.counter >= request.follow) throw new FetchError(\"maximum redirect reached at: \".concat(request.url), 'max-redirect', {\n    code: 'EMAXREDIRECT'\n  });\n  return true;\n};\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nvar getRedirect = function getRedirect(request, response, options) {\n  var _opts = _objectSpread({}, options);\n  var location = response.headers.get('location');\n  var redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url);\n  // Comment below is used under the following license:\n  // Copyright (c) 2010-2012 Mikeal Rogers\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  // http://www.apache.org/licenses/LICENSE-2.0\n  // Unless required by applicable law or agreed to in writing,\n  // software distributed under the License is distributed on an \"AS\n  // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  // express or implied. See the License for the specific language\n  // governing permissions and limitations under the License.\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) request.headers.delete('authorization');\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (response.status === 303 || request.method === 'POST' && [301, 302].includes(response.status)) {\n    _opts.method = 'GET';\n    _opts.body = null;\n    request.headers.delete('content-length');\n  }\n  _opts.headers = {};\n  request.headers.forEach(function (value, key) {\n    _opts.headers[key] = value;\n  });\n  _opts.counter = ++request.counter;\n  var redirectReq = new Request(url.format(redirectUrl), _opts);\n  return {\n    request: redirectReq,\n    options: _opts\n  };\n};\nvar fetch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, options) {\n    var response, redirect;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!CachePolicy.storable(request, options)) {\n            _context.next = 6;\n            break;\n          }\n          _context.next = 3;\n          return cache(request, options);\n        case 3:\n          _context.t0 = _context.sent;\n          _context.next = 9;\n          break;\n        case 6:\n          _context.next = 8;\n          return remote(request, options);\n        case 8:\n          _context.t0 = _context.sent;\n        case 9:\n          response = _context.t0;\n          if (!(!['GET', 'HEAD'].includes(request.method) && response.status >= 200 && response.status <= 399)) {\n            _context.next = 13;\n            break;\n          }\n          _context.next = 13;\n          return cache.invalidate(request, options);\n        case 13:\n          if (canFollowRedirect(request, response, options)) {\n            _context.next = 15;\n            break;\n          }\n          return _context.abrupt(\"return\", response);\n        case 15:\n          redirect = getRedirect(request, response, options);\n          return _context.abrupt(\"return\", fetch(redirect.request, redirect.options));\n        case 17:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function fetch(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nmodule.exports = fetch;","map":{"version":3,"names":["_regeneratorRuntime","require","default","_asyncToGenerator","_objectSpread","_require","FetchError","Request","isRedirect","url","CachePolicy","cache","remote","canFollowRedirect","request","response","options","status","redirect","concat","code","headers","has","counter","follow","getRedirect","_opts","location","get","redirectUrl","URL","test","undefined","hostname","delete","method","includes","body","forEach","value","key","redirectReq","format","fetch","_ref","mark","_callee","wrap","_callee$","_context","prev","next","storable","t0","sent","invalidate","abrupt","stop","_x","_x2","apply","arguments","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/make-fetch-happen/lib/fetch.js"],"sourcesContent":["'use strict'\n\nconst { FetchError, Request, isRedirect } = require('minipass-fetch')\nconst url = require('url')\n\nconst CachePolicy = require('./cache/policy.js')\nconst cache = require('./cache/index.js')\nconst remote = require('./remote.js')\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status))\n    return false\n\n  if (options.redirect === 'manual')\n    return false\n\n  if (options.redirect === 'error')\n    throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', { code: 'ENOREDIRECT' })\n\n  if (!response.headers.has('location'))\n    throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', { code: 'EINVALIDREDIRECT' })\n\n  if (request.counter >= request.follow)\n    throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', { code: 'EMAXREDIRECT' })\n\n  return true\n}\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options }\n  const location = response.headers.get('location')\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url)\n  // Comment below is used under the following license:\n  // Copyright (c) 2010-2012 Mikeal Rogers\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  // http://www.apache.org/licenses/LICENSE-2.0\n  // Unless required by applicable law or agreed to in writing,\n  // software distributed under the License is distributed on an \"AS\n  // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  // express or implied. See the License for the specific language\n  // governing permissions and limitations under the License.\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname)\n    request.headers.delete('authorization')\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (response.status === 303 || (request.method === 'POST' && [301, 302].includes(response.status))) {\n    _opts.method = 'GET'\n    _opts.body = null\n    request.headers.delete('content-length')\n  }\n\n  _opts.headers = {}\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value\n  })\n\n  _opts.counter = ++request.counter\n  const redirectReq = new Request(url.format(redirectUrl), _opts)\n  return {\n    request: redirectReq,\n    options: _opts,\n  }\n}\n\nconst fetch = async (request, options) => {\n  const response = CachePolicy.storable(request, options)\n    ? await cache(request, options)\n    : await remote(request, options)\n\n  // if the request wasn't a GET or HEAD, and the response\n  // status is between 200 and 399 inclusive, invalidate the\n  // request url\n  if (!['GET', 'HEAD'].includes(request.method) &&\n      response.status >= 200 &&\n      response.status <= 399)\n    await cache.invalidate(request, options)\n\n  if (!canFollowRedirect(request, response, options))\n    return response\n\n  const redirect = getRedirect(request, response, options)\n  return fetch(redirect.request, redirect.options)\n}\n\nmodule.exports = fetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}