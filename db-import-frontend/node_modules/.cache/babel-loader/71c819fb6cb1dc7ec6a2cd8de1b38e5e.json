{"ast":null,"code":"'use strict';\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar assert = require('assert');\nvar Parser = require('./parse.js');\nvar fs = require('fs');\nvar fsm = require('fs-minipass');\nvar path = require('path');\nvar mkdir = require('./mkdir.js');\nvar wc = require('./winchars.js');\nvar pathReservations = require('./path-reservations.js');\nvar stripAbsolutePath = require('./strip-absolute-path.js');\nvar normPath = require('./normalize-windows-path.js');\nvar stripSlash = require('./strip-trailing-slashes.js');\nvar normalize = require('./normalize-unicode.js');\nvar ONENTRY = Symbol('onEntry');\nvar CHECKFS = Symbol('checkFs');\nvar CHECKFS2 = Symbol('checkFs2');\nvar PRUNECACHE = Symbol('pruneCache');\nvar ISREUSABLE = Symbol('isReusable');\nvar MAKEFS = Symbol('makeFs');\nvar FILE = Symbol('file');\nvar DIRECTORY = Symbol('directory');\nvar LINK = Symbol('link');\nvar SYMLINK = Symbol('symlink');\nvar HARDLINK = Symbol('hardlink');\nvar UNSUPPORTED = Symbol('unsupported');\nvar CHECKPATH = Symbol('checkPath');\nvar MKDIR = Symbol('mkdir');\nvar ONERROR = Symbol('onError');\nvar PENDING = Symbol('pending');\nvar PEND = Symbol('pend');\nvar UNPEND = Symbol('unpend');\nvar ENDED = Symbol('ended');\nvar MAYBECLOSE = Symbol('maybeClose');\nvar SKIP = Symbol('skip');\nvar DOCHOWN = Symbol('doChown');\nvar UID = Symbol('uid');\nvar GID = Symbol('gid');\nvar CHECKED_CWD = Symbol('checkedCwd');\nvar crypto = require('crypto');\nvar getFlag = require('./get-write-flag.js');\nvar platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nvar isWindows = platform === 'win32';\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nvar unlinkFile = function unlinkFile(path, cb) {\n  if (!isWindows) {\n    return fs.unlink(path, cb);\n  }\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, function (er) {\n    if (er) {\n      return cb(er);\n    }\n    fs.unlink(name, cb);\n  });\n};\n\n/* istanbul ignore next */\nvar unlinkFileSync = function unlinkFileSync(path) {\n  if (!isWindows) {\n    return fs.unlinkSync(path);\n  }\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n};\n\n// this.gid, entry.gid, this.processUid\nvar uint32 = function uint32(a, b, c) {\n  return a === a >>> 0 ? a : b === b >>> 0 ? b : c;\n};\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nvar cacheKeyNormalize = function cacheKeyNormalize(path) {\n  return stripSlash(normPath(normalize(path))).toLowerCase();\n};\nvar pruneCache = function pruneCache(cache, abs) {\n  abs = cacheKeyNormalize(abs);\n  var _iterator = _createForOfIteratorHelper(cache.keys()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _path = _step.value;\n      var pnorm = cacheKeyNormalize(_path);\n      if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n        cache.delete(_path);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar dropCache = function dropCache(cache) {\n  var _iterator2 = _createForOfIteratorHelper(cache.keys()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value;\n      cache.delete(key);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\nvar Unpack = /*#__PURE__*/function (_Parser) {\n  _inherits(Unpack, _Parser);\n  var _super = _createSuper(Unpack);\n  function Unpack(opt) {\n    var _this;\n    _classCallCheck(this, Unpack);\n    if (!opt) {\n      opt = {};\n    }\n    opt.ondone = function (_) {\n      _this[ENDED] = true;\n      _this[MAYBECLOSE]();\n    };\n    _this = _super.call(this, opt);\n    _this[CHECKED_CWD] = false;\n    _this.reservations = pathReservations();\n    _this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    _this.writable = true;\n    _this.readable = false;\n    _this[PENDING] = 0;\n    _this[ENDED] = false;\n    _this.dirCache = opt.dirCache || new Map();\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid');\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      }\n      _this.uid = opt.uid;\n      _this.gid = opt.gid;\n      _this.setOwner = true;\n    } else {\n      _this.uid = null;\n      _this.gid = null;\n      _this.setOwner = false;\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      _this.preserveOwner = process.getuid && process.getuid() === 0;\n    } else {\n      _this.preserveOwner = !!opt.preserveOwner;\n    }\n    _this.processUid = (_this.preserveOwner || _this.setOwner) && process.getuid ? process.getuid() : null;\n    _this.processGid = (_this.preserveOwner || _this.setOwner) && process.getgid ? process.getgid() : null;\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    _this.forceChown = opt.forceChown === true;\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    _this.win32 = !!opt.win32 || isWindows;\n\n    // do not unpack over files that are newer than what's in the archive\n    _this.newer = !!opt.newer;\n\n    // do not unpack over ANY files\n    _this.keep = !!opt.keep;\n\n    // do not set mtime/atime of extracted entries\n    _this.noMtime = !!opt.noMtime;\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    _this.preservePaths = !!opt.preservePaths;\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    _this.unlink = !!opt.unlink;\n    _this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));\n    _this.strip = +opt.strip || 0;\n    // if we're not chmodding, then we don't need the process umask\n    _this.processUmask = opt.noChmod ? 0 : process.umask();\n    _this.umask = typeof opt.umask === 'number' ? opt.umask : _this.processUmask;\n\n    // default mode for dirs created as parents\n    _this.dmode = opt.dmode || 511 & ~_this.umask;\n    _this.fmode = opt.fmode || 438 & ~_this.umask;\n    _this.on('entry', function (entry) {\n      return _this[ONENTRY](entry);\n    });\n    return _this;\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  _createClass(Unpack, [{\n    key: \"warn\",\n    value: function warn(code, msg) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n        data.recoverable = false;\n      }\n      return _get(_getPrototypeOf(Unpack.prototype), \"warn\", this).call(this, code, msg, data);\n    }\n  }, {\n    key: MAYBECLOSE,\n    value: function value() {\n      if (this[ENDED] && this[PENDING] === 0) {\n        this.emit('prefinish');\n        this.emit('finish');\n        this.emit('end');\n      }\n    }\n  }, {\n    key: CHECKPATH,\n    value: function value(entry) {\n      if (this.strip) {\n        var parts = normPath(entry.path).split('/');\n        if (parts.length < this.strip) {\n          return false;\n        }\n        entry.path = parts.slice(this.strip).join('/');\n        if (entry.type === 'Link') {\n          var linkparts = normPath(entry.linkpath).split('/');\n          if (linkparts.length >= this.strip) {\n            entry.linkpath = linkparts.slice(this.strip).join('/');\n          } else {\n            return false;\n          }\n        }\n      }\n      if (!this.preservePaths) {\n        var p = normPath(entry.path);\n        var _parts = p.split('/');\n        if (_parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(_parts[0])) {\n          this.warn('TAR_ENTRY_ERROR', \"path contains '..'\", {\n            entry: entry,\n            path: p\n          });\n          return false;\n        }\n\n        // strip off the root\n        var _stripAbsolutePath = stripAbsolutePath(p),\n          _stripAbsolutePath2 = _slicedToArray(_stripAbsolutePath, 2),\n          root = _stripAbsolutePath2[0],\n          stripped = _stripAbsolutePath2[1];\n        if (root) {\n          entry.path = stripped;\n          this.warn('TAR_ENTRY_INFO', \"stripping \".concat(root, \" from absolute path\"), {\n            entry: entry,\n            path: p\n          });\n        }\n      }\n      if (path.isAbsolute(entry.path)) {\n        entry.absolute = normPath(path.resolve(entry.path));\n      } else {\n        entry.absolute = normPath(path.resolve(this.cwd, entry.path));\n      }\n\n      // if we somehow ended up with a path that escapes the cwd, and we are\n      // not in preservePaths mode, then something is fishy!  This should have\n      // been prevented above, so ignore this for coverage.\n      /* istanbul ignore if - defense in depth */\n      if (!this.preservePaths && entry.absolute.indexOf(this.cwd + '/') !== 0 && entry.absolute !== this.cwd) {\n        this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n          entry: entry,\n          path: normPath(entry.path),\n          resolvedPath: entry.absolute,\n          cwd: this.cwd\n        });\n        return false;\n      }\n\n      // an archive can set properties on the extraction directory, but it\n      // may not replace the cwd with a different kind of thing entirely.\n      if (entry.absolute === this.cwd && entry.type !== 'Directory' && entry.type !== 'GNUDumpDir') {\n        return false;\n      }\n\n      // only encode : chars that aren't drive letter indicators\n      if (this.win32) {\n        var _path$win32$parse = path.win32.parse(entry.absolute),\n          aRoot = _path$win32$parse.root;\n        entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));\n        var _path$win32$parse2 = path.win32.parse(entry.path),\n          pRoot = _path$win32$parse2.root;\n        entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));\n      }\n      return true;\n    }\n  }, {\n    key: ONENTRY,\n    value: function value(entry) {\n      if (!this[CHECKPATH](entry)) {\n        return entry.resume();\n      }\n      assert.equal(typeof entry.absolute, 'string');\n      switch (entry.type) {\n        case 'Directory':\n        case 'GNUDumpDir':\n          if (entry.mode) {\n            entry.mode = entry.mode | 448;\n          }\n\n        // eslint-disable-next-line no-fallthrough\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n        case 'Link':\n        case 'SymbolicLink':\n          return this[CHECKFS](entry);\n        case 'CharacterDevice':\n        case 'BlockDevice':\n        case 'FIFO':\n        default:\n          return this[UNSUPPORTED](entry);\n      }\n    }\n  }, {\n    key: ONERROR,\n    value: function value(er, entry) {\n      // Cwd has to exist, or else nothing works. That's serious.\n      // Other errors are warnings, which raise the error in strict\n      // mode, but otherwise continue on.\n      if (er.name === 'CwdError') {\n        this.emit('error', er);\n      } else {\n        this.warn('TAR_ENTRY_ERROR', er, {\n          entry: entry\n        });\n        this[UNPEND]();\n        entry.resume();\n      }\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode, cb) {\n      mkdir(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n        noChmod: this.noChmod\n      }, cb);\n    }\n  }, {\n    key: DOCHOWN,\n    value: function value(entry) {\n      // in preserve owner mode, chown if the entry doesn't match process\n      // in set owner mode, chown if setting doesn't match process\n      return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n    }\n  }, {\n    key: UID,\n    value: function value(entry) {\n      return uint32(this.uid, entry.uid, this.processUid);\n    }\n  }, {\n    key: GID,\n    value: function value(entry) {\n      return uint32(this.gid, entry.gid, this.processGid);\n    }\n  }, {\n    key: FILE,\n    value: function value(entry, fullyDone) {\n      var _this2 = this;\n      var mode = entry.mode & 4095 || this.fmode;\n      var stream = new fsm.WriteStream(entry.absolute, {\n        flags: getFlag(entry.size),\n        mode: mode,\n        autoClose: false\n      });\n      stream.on('error', function (er) {\n        if (stream.fd) {\n          fs.close(stream.fd, function () {});\n        }\n\n        // flush all the data out so that we aren't left hanging\n        // if the error wasn't actually fatal.  otherwise the parse\n        // is blocked, and we never proceed.\n        stream.write = function () {\n          return true;\n        };\n        _this2[ONERROR](er, entry);\n        fullyDone();\n      });\n      var actions = 1;\n      var done = function done(er) {\n        if (er) {\n          /* istanbul ignore else - we should always have a fd by now */\n          if (stream.fd) {\n            fs.close(stream.fd, function () {});\n          }\n          _this2[ONERROR](er, entry);\n          fullyDone();\n          return;\n        }\n        if (--actions === 0) {\n          fs.close(stream.fd, function (er) {\n            if (er) {\n              _this2[ONERROR](er, entry);\n            } else {\n              _this2[UNPEND]();\n            }\n            fullyDone();\n          });\n        }\n      };\n      stream.on('finish', function (_) {\n        // if futimes fails, try utimes\n        // if utimes fails, fail with the original error\n        // same for fchown/chown\n        var abs = entry.absolute;\n        var fd = stream.fd;\n        if (entry.mtime && !_this2.noMtime) {\n          actions++;\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n          fs.futimes(fd, atime, mtime, function (er) {\n            return er ? fs.utimes(abs, atime, mtime, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n        if (_this2[DOCHOWN](entry)) {\n          actions++;\n          var uid = _this2[UID](entry);\n          var gid = _this2[GID](entry);\n          fs.fchown(fd, uid, gid, function (er) {\n            return er ? fs.chown(abs, uid, gid, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n        done();\n      });\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          _this2[ONERROR](er, entry);\n          fullyDone();\n        });\n        entry.pipe(tx);\n      }\n      tx.pipe(stream);\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry, fullyDone) {\n      var _this3 = this;\n      var mode = entry.mode & 4095 || this.dmode;\n      this[MKDIR](entry.absolute, mode, function (er) {\n        if (er) {\n          _this3[ONERROR](er, entry);\n          fullyDone();\n          return;\n        }\n        var actions = 1;\n        var done = function done(_) {\n          if (--actions === 0) {\n            fullyDone();\n            _this3[UNPEND]();\n            entry.resume();\n          }\n        };\n        if (entry.mtime && !_this3.noMtime) {\n          actions++;\n          fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n        }\n        if (_this3[DOCHOWN](entry)) {\n          actions++;\n          fs.chown(entry.absolute, _this3[UID](entry), _this3[GID](entry), done);\n        }\n        done();\n      });\n    }\n  }, {\n    key: UNSUPPORTED,\n    value: function value(entry) {\n      entry.unsupported = true;\n      this.warn('TAR_ENTRY_UNSUPPORTED', \"unsupported entry type: \".concat(entry.type), {\n        entry: entry\n      });\n      entry.resume();\n    }\n  }, {\n    key: SYMLINK,\n    value: function value(entry, done) {\n      this[LINK](entry, entry.linkpath, 'symlink', done);\n    }\n  }, {\n    key: HARDLINK,\n    value: function value(entry, done) {\n      var linkpath = normPath(path.resolve(this.cwd, entry.linkpath));\n      this[LINK](entry, linkpath, 'link', done);\n    }\n  }, {\n    key: PEND,\n    value: function value() {\n      this[PENDING]++;\n    }\n  }, {\n    key: UNPEND,\n    value: function value() {\n      this[PENDING]--;\n      this[MAYBECLOSE]();\n    }\n  }, {\n    key: SKIP,\n    value: function value(entry) {\n      this[UNPEND]();\n      entry.resume();\n    }\n\n    // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n  }, {\n    key: ISREUSABLE,\n    value: function value(entry, st) {\n      return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;\n    }\n\n    // check if a thing is there, and if so, try to clobber it\n  }, {\n    key: CHECKFS,\n    value: function value(entry) {\n      var _this4 = this;\n      this[PEND]();\n      var paths = [entry.path];\n      if (entry.linkpath) {\n        paths.push(entry.linkpath);\n      }\n      this.reservations.reserve(paths, function (done) {\n        return _this4[CHECKFS2](entry, done);\n      });\n    }\n  }, {\n    key: PRUNECACHE,\n    value: function value(entry) {\n      // if we are not creating a directory, and the path is in the dirCache,\n      // then that means we are about to delete the directory we created\n      // previously, and it is no longer going to be a directory, and neither\n      // is any of its children.\n      // If a symbolic link is encountered, all bets are off.  There is no\n      // reasonable way to sanitize the cache in such a way we will be able to\n      // avoid having filesystem collisions.  If this happens with a non-symlink\n      // entry, it'll just fail to unpack, but a symlink to a directory, using an\n      // 8.3 shortname or certain unicode attacks, can evade detection and lead\n      // to arbitrary writes to anywhere on the system.\n      if (entry.type === 'SymbolicLink') {\n        dropCache(this.dirCache);\n      } else if (entry.type !== 'Directory') {\n        pruneCache(this.dirCache, entry.absolute);\n      }\n    }\n  }, {\n    key: CHECKFS2,\n    value: function value(entry, fullyDone) {\n      var _this5 = this;\n      this[PRUNECACHE](entry);\n      var done = function done(er) {\n        _this5[PRUNECACHE](entry);\n        fullyDone(er);\n      };\n      var checkCwd = function checkCwd() {\n        _this5[MKDIR](_this5.cwd, _this5.dmode, function (er) {\n          if (er) {\n            _this5[ONERROR](er, entry);\n            done();\n            return;\n          }\n          _this5[CHECKED_CWD] = true;\n          start();\n        });\n      };\n      var start = function start() {\n        if (entry.absolute !== _this5.cwd) {\n          var parent = normPath(path.dirname(entry.absolute));\n          if (parent !== _this5.cwd) {\n            return _this5[MKDIR](parent, _this5.dmode, function (er) {\n              if (er) {\n                _this5[ONERROR](er, entry);\n                done();\n                return;\n              }\n              afterMakeParent();\n            });\n          }\n        }\n        afterMakeParent();\n      };\n      var afterMakeParent = function afterMakeParent() {\n        fs.lstat(entry.absolute, function (lstatEr, st) {\n          if (st && (_this5.keep || _this5.newer && st.mtime > entry.mtime)) {\n            _this5[SKIP](entry);\n            done();\n            return;\n          }\n          if (lstatEr || _this5[ISREUSABLE](entry, st)) {\n            return _this5[MAKEFS](null, entry, done);\n          }\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              var needChmod = !_this5.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;\n              var afterChmod = function afterChmod(er) {\n                return _this5[MAKEFS](er, entry, done);\n              };\n              if (!needChmod) {\n                return afterChmod();\n              }\n              return fs.chmod(entry.absolute, entry.mode, afterChmod);\n            }\n            // Not a dir entry, have to remove it.\n            // NB: the only way to end up with an entry that is the cwd\n            // itself, in such a way that == does not detect, is a\n            // tricky windows absolute path with UNC or 8.3 parts (and\n            // preservePaths:true, or else it will have been stripped).\n            // In that case, the user has opted out of path protections\n            // explicitly, so if they blow away the cwd, c'est la vie.\n            if (entry.absolute !== _this5.cwd) {\n              return fs.rmdir(entry.absolute, function (er) {\n                return _this5[MAKEFS](er, entry, done);\n              });\n            }\n          }\n\n          // not a dir, and not reusable\n          // don't remove if the cwd, we want that error\n          if (entry.absolute === _this5.cwd) {\n            return _this5[MAKEFS](null, entry, done);\n          }\n          unlinkFile(entry.absolute, function (er) {\n            return _this5[MAKEFS](er, entry, done);\n          });\n        });\n      };\n      if (this[CHECKED_CWD]) {\n        start();\n      } else {\n        checkCwd();\n      }\n    }\n  }, {\n    key: MAKEFS,\n    value: function value(er, entry, done) {\n      if (er) {\n        this[ONERROR](er, entry);\n        done();\n        return;\n      }\n      switch (entry.type) {\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n          return this[FILE](entry, done);\n        case 'Link':\n          return this[HARDLINK](entry, done);\n        case 'SymbolicLink':\n          return this[SYMLINK](entry, done);\n        case 'Directory':\n        case 'GNUDumpDir':\n          return this[DIRECTORY](entry, done);\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link, done) {\n      var _this6 = this;\n      // XXX: get the type ('symlink' or 'junction') for windows\n      fs[link](linkpath, entry.absolute, function (er) {\n        if (er) {\n          _this6[ONERROR](er, entry);\n        } else {\n          _this6[UNPEND]();\n          entry.resume();\n        }\n        done();\n      });\n    }\n  }]);\n  return Unpack;\n}(Parser);\nvar callSync = function callSync(fn) {\n  try {\n    return [null, fn()];\n  } catch (er) {\n    return [er, null];\n  }\n};\nvar UnpackSync = /*#__PURE__*/function (_Unpack) {\n  _inherits(UnpackSync, _Unpack);\n  var _super2 = _createSuper(UnpackSync);\n  function UnpackSync() {\n    _classCallCheck(this, UnpackSync);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(UnpackSync, [{\n    key: MAKEFS,\n    value: function value(er, entry) {\n      return _get(_getPrototypeOf(UnpackSync.prototype), MAKEFS, this).call(this, er, entry, function () {});\n    }\n  }, {\n    key: CHECKFS,\n    value: function value(entry) {\n      this[PRUNECACHE](entry);\n      if (!this[CHECKED_CWD]) {\n        var _er = this[MKDIR](this.cwd, this.dmode);\n        if (_er) {\n          return this[ONERROR](_er, entry);\n        }\n        this[CHECKED_CWD] = true;\n      }\n\n      // don't bother to make the parent if the current entry is the cwd,\n      // we've already checked it.\n      if (entry.absolute !== this.cwd) {\n        var parent = normPath(path.dirname(entry.absolute));\n        if (parent !== this.cwd) {\n          var mkParent = this[MKDIR](parent, this.dmode);\n          if (mkParent) {\n            return this[ONERROR](mkParent, entry);\n          }\n        }\n      }\n      var _callSync = callSync(function () {\n          return fs.lstatSync(entry.absolute);\n        }),\n        _callSync2 = _slicedToArray(_callSync, 2),\n        lstatEr = _callSync2[0],\n        st = _callSync2[1];\n      if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n        return this[SKIP](entry);\n      }\n      if (lstatEr || this[ISREUSABLE](entry, st)) {\n        return this[MAKEFS](null, entry);\n      }\n      if (st.isDirectory()) {\n        if (entry.type === 'Directory') {\n          var needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;\n          var _ref = needChmod ? callSync(function () {\n              fs.chmodSync(entry.absolute, entry.mode);\n            }) : [],\n            _ref2 = _slicedToArray(_ref, 1),\n            _er2 = _ref2[0];\n          return this[MAKEFS](_er2, entry);\n        }\n        // not a dir entry, have to remove it\n        var _callSync3 = callSync(function () {\n            return fs.rmdirSync(entry.absolute);\n          }),\n          _callSync4 = _slicedToArray(_callSync3, 1),\n          _er3 = _callSync4[0];\n        this[MAKEFS](_er3, entry);\n      }\n\n      // not a dir, and not reusable.\n      // don't remove if it's the cwd, since we want that error.\n      var _ref3 = entry.absolute === this.cwd ? [] : callSync(function () {\n          return unlinkFileSync(entry.absolute);\n        }),\n        _ref4 = _slicedToArray(_ref3, 1),\n        er = _ref4[0];\n      this[MAKEFS](er, entry);\n    }\n  }, {\n    key: FILE,\n    value: function value(entry, done) {\n      var _this7 = this;\n      var mode = entry.mode & 4095 || this.fmode;\n      var oner = function oner(er) {\n        var closeError;\n        try {\n          fs.closeSync(fd);\n        } catch (e) {\n          closeError = e;\n        }\n        if (er || closeError) {\n          _this7[ONERROR](er || closeError, entry);\n        }\n        done();\n      };\n      var fd;\n      try {\n        fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);\n      } catch (er) {\n        return oner(er);\n      }\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          return _this7[ONERROR](er, entry);\n        });\n        entry.pipe(tx);\n      }\n      tx.on('data', function (chunk) {\n        try {\n          fs.writeSync(fd, chunk, 0, chunk.length);\n        } catch (er) {\n          oner(er);\n        }\n      });\n      tx.on('end', function (_) {\n        var er = null;\n        // try both, falling futimes back to utimes\n        // if either fails, handle the first error\n        if (entry.mtime && !_this7.noMtime) {\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n          try {\n            fs.futimesSync(fd, atime, mtime);\n          } catch (futimeser) {\n            try {\n              fs.utimesSync(entry.absolute, atime, mtime);\n            } catch (utimeser) {\n              er = futimeser;\n            }\n          }\n        }\n        if (_this7[DOCHOWN](entry)) {\n          var uid = _this7[UID](entry);\n          var gid = _this7[GID](entry);\n          try {\n            fs.fchownSync(fd, uid, gid);\n          } catch (fchowner) {\n            try {\n              fs.chownSync(entry.absolute, uid, gid);\n            } catch (chowner) {\n              er = er || fchowner;\n            }\n          }\n        }\n        oner(er);\n      });\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry, done) {\n      var mode = entry.mode & 4095 || this.dmode;\n      var er = this[MKDIR](entry.absolute, mode);\n      if (er) {\n        this[ONERROR](er, entry);\n        done();\n        return;\n      }\n      if (entry.mtime && !this.noMtime) {\n        try {\n          fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n        } catch (er) {}\n      }\n      if (this[DOCHOWN](entry)) {\n        try {\n          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n        } catch (er) {}\n      }\n      done();\n      entry.resume();\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode) {\n      try {\n        return mkdir.sync(normPath(dir), {\n          uid: this.uid,\n          gid: this.gid,\n          processUid: this.processUid,\n          processGid: this.processGid,\n          umask: this.processUmask,\n          preserve: this.preservePaths,\n          unlink: this.unlink,\n          cache: this.dirCache,\n          cwd: this.cwd,\n          mode: mode\n        });\n      } catch (er) {\n        return er;\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link, done) {\n      try {\n        fs[link + 'Sync'](linkpath, entry.absolute);\n        done();\n        entry.resume();\n      } catch (er) {\n        return this[ONERROR](er, entry);\n      }\n    }\n  }]);\n  return UnpackSync;\n}(Unpack);\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":{"version":3,"names":["_slicedToArray","require","default","_classCallCheck","_createClass","_get","_getPrototypeOf","_inherits","_createSuper","_createForOfIteratorHelper","assert","Parser","fs","fsm","path","mkdir","wc","pathReservations","stripAbsolutePath","normPath","stripSlash","normalize","ONENTRY","Symbol","CHECKFS","CHECKFS2","PRUNECACHE","ISREUSABLE","MAKEFS","FILE","DIRECTORY","LINK","SYMLINK","HARDLINK","UNSUPPORTED","CHECKPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","ENDED","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","CHECKED_CWD","crypto","getFlag","platform","process","env","TESTING_TAR_FAKE_PLATFORM","isWindows","unlinkFile","cb","unlink","name","randomBytes","toString","rename","er","unlinkFileSync","unlinkSync","renameSync","uint32","a","b","c","cacheKeyNormalize","toLowerCase","pruneCache","cache","abs","_iterator","keys","_step","s","n","done","value","pnorm","indexOf","delete","err","e","f","dropCache","_iterator2","_step2","key","Unpack","_Parser","_super","opt","_this","ondone","_","call","reservations","transform","writable","readable","dirCache","Map","uid","gid","TypeError","preserveOwner","setOwner","undefined","getuid","processUid","processGid","getgid","forceChown","win32","newer","keep","noMtime","preservePaths","cwd","resolve","strip","processUmask","noChmod","umask","dmode","fmode","on","entry","warn","code","msg","data","arguments","length","recoverable","prototype","emit","parts","split","slice","join","type","linkparts","linkpath","p","includes","test","_stripAbsolutePath","_stripAbsolutePath2","root","stripped","concat","isAbsolute","absolute","resolvedPath","_path$win32$parse","parse","aRoot","encode","_path$win32$parse2","pRoot","resume","equal","mode","dir","preserve","fullyDone","_this2","stream","WriteStream","flags","size","autoClose","fd","close","write","actions","mtime","atime","Date","futimes","utimes","er2","fchown","chown","tx","pipe","_this3","unsupported","st","isFile","nlink","_this4","paths","push","reserve","_this5","checkCwd","start","parent","dirname","afterMakeParent","lstat","lstatEr","isDirectory","needChmod","afterChmod","chmod","rmdir","link","_this6","callSync","fn","UnpackSync","_Unpack","_super2","apply","mkParent","_callSync","lstatSync","_callSync2","_ref","chmodSync","_ref2","_callSync3","rmdirSync","_callSync4","_ref3","_ref4","_this7","oner","closeError","closeSync","openSync","chunk","writeSync","futimesSync","futimeser","utimesSync","utimeser","fchownSync","fchowner","chownSync","chowner","sync","Sync","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/tar/lib/unpack.js"],"sourcesContent":["'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\nconst normalize = require('./normalize-unicode.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path)\n    }\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key)\n  }\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt) {\n      opt = {}\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid')\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/')\n      if (parts.length < this.strip) {\n        return false\n      }\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path)\n      const parts = p.split('/')\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir') {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry)\n          } else {\n            this[UNPEND]()\n          }\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, { entry })\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache)\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute)\n    }\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry)\n      }\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AAAA,IAAAA,cAAA,GAAAC,OAAA,2FAAAC,OAAA;AAAA,IAAAC,eAAA,GAAAF,OAAA,4FAAAC,OAAA;AAAA,IAAAE,YAAA,GAAAH,OAAA,yFAAAC,OAAA;AAAA,IAAAG,IAAA,GAAAJ,OAAA,iFAAAC,OAAA;AAAA,IAAAI,eAAA,GAAAL,OAAA,4FAAAC,OAAA;AAAA,IAAAK,SAAA,GAAAN,OAAA,sFAAAC,OAAA;AAAA,IAAAM,YAAA,GAAAP,OAAA,yFAAAC,OAAA;AAAA,IAAAO,0BAAA,GAAAR,OAAA,uGAAAC,OAAA;AAEA,IAAMQ,MAAM,GAAGT,OAAO,CAAC,QAAQ,CAAC;AAChC,IAAMU,MAAM,GAAGV,OAAO,CAAC,YAAY,CAAC;AACpC,IAAMW,EAAE,GAAGX,OAAO,CAAC,IAAI,CAAC;AACxB,IAAMY,GAAG,GAAGZ,OAAO,CAAC,aAAa,CAAC;AAClC,IAAMa,IAAI,GAAGb,OAAO,CAAC,MAAM,CAAC;AAC5B,IAAMc,KAAK,GAAGd,OAAO,CAAC,YAAY,CAAC;AACnC,IAAMe,EAAE,GAAGf,OAAO,CAAC,eAAe,CAAC;AACnC,IAAMgB,gBAAgB,GAAGhB,OAAO,CAAC,wBAAwB,CAAC;AAC1D,IAAMiB,iBAAiB,GAAGjB,OAAO,CAAC,0BAA0B,CAAC;AAC7D,IAAMkB,QAAQ,GAAGlB,OAAO,CAAC,6BAA6B,CAAC;AACvD,IAAMmB,UAAU,GAAGnB,OAAO,CAAC,6BAA6B,CAAC;AACzD,IAAMoB,SAAS,GAAGpB,OAAO,CAAC,wBAAwB,CAAC;AAEnD,IAAMqB,OAAO,GAAGC,MAAM,CAAC,SAAS,CAAC;AACjC,IAAMC,OAAO,GAAGD,MAAM,CAAC,SAAS,CAAC;AACjC,IAAME,QAAQ,GAAGF,MAAM,CAAC,UAAU,CAAC;AACnC,IAAMG,UAAU,GAAGH,MAAM,CAAC,YAAY,CAAC;AACvC,IAAMI,UAAU,GAAGJ,MAAM,CAAC,YAAY,CAAC;AACvC,IAAMK,MAAM,GAAGL,MAAM,CAAC,QAAQ,CAAC;AAC/B,IAAMM,IAAI,GAAGN,MAAM,CAAC,MAAM,CAAC;AAC3B,IAAMO,SAAS,GAAGP,MAAM,CAAC,WAAW,CAAC;AACrC,IAAMQ,IAAI,GAAGR,MAAM,CAAC,MAAM,CAAC;AAC3B,IAAMS,OAAO,GAAGT,MAAM,CAAC,SAAS,CAAC;AACjC,IAAMU,QAAQ,GAAGV,MAAM,CAAC,UAAU,CAAC;AACnC,IAAMW,WAAW,GAAGX,MAAM,CAAC,aAAa,CAAC;AACzC,IAAMY,SAAS,GAAGZ,MAAM,CAAC,WAAW,CAAC;AACrC,IAAMa,KAAK,GAAGb,MAAM,CAAC,OAAO,CAAC;AAC7B,IAAMc,OAAO,GAAGd,MAAM,CAAC,SAAS,CAAC;AACjC,IAAMe,OAAO,GAAGf,MAAM,CAAC,SAAS,CAAC;AACjC,IAAMgB,IAAI,GAAGhB,MAAM,CAAC,MAAM,CAAC;AAC3B,IAAMiB,MAAM,GAAGjB,MAAM,CAAC,QAAQ,CAAC;AAC/B,IAAMkB,KAAK,GAAGlB,MAAM,CAAC,OAAO,CAAC;AAC7B,IAAMmB,UAAU,GAAGnB,MAAM,CAAC,YAAY,CAAC;AACvC,IAAMoB,IAAI,GAAGpB,MAAM,CAAC,MAAM,CAAC;AAC3B,IAAMqB,OAAO,GAAGrB,MAAM,CAAC,SAAS,CAAC;AACjC,IAAMsB,GAAG,GAAGtB,MAAM,CAAC,KAAK,CAAC;AACzB,IAAMuB,GAAG,GAAGvB,MAAM,CAAC,KAAK,CAAC;AACzB,IAAMwB,WAAW,GAAGxB,MAAM,CAAC,YAAY,CAAC;AACxC,IAAMyB,MAAM,GAAG/C,OAAO,CAAC,QAAQ,CAAC;AAChC,IAAMgD,OAAO,GAAGhD,OAAO,CAAC,qBAAqB,CAAC;AAC9C,IAAMiD,QAAQ,GAAGC,OAAO,CAACC,GAAG,CAACC,yBAAyB,IAAIF,OAAO,CAACD,QAAQ;AAC1E,IAAMI,SAAS,GAAGJ,QAAQ,KAAK,OAAO;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMK,UAAU,GAAG,SAAbA,UAAUA,CAAIzC,IAAI,EAAE0C,EAAE,EAAK;EAC/B,IAAI,CAACF,SAAS,EAAE;IACd,OAAO1C,EAAE,CAAC6C,MAAM,CAAC3C,IAAI,EAAE0C,EAAE,CAAC;EAC5B;EAEA,IAAME,IAAI,GAAG5C,IAAI,GAAG,UAAU,GAAGkC,MAAM,CAACW,WAAW,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,KAAK,CAAC;EACvEhD,EAAE,CAACiD,MAAM,CAAC/C,IAAI,EAAE4C,IAAI,EAAE,UAAAI,EAAE,EAAI;IAC1B,IAAIA,EAAE,EAAE;MACN,OAAON,EAAE,CAACM,EAAE,CAAC;IACf;IACAlD,EAAE,CAAC6C,MAAM,CAACC,IAAI,EAAEF,EAAE,CAAC;EACrB,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,IAAMO,cAAc,GAAG,SAAjBA,cAAcA,CAAGjD,IAAI,EAAI;EAC7B,IAAI,CAACwC,SAAS,EAAE;IACd,OAAO1C,EAAE,CAACoD,UAAU,CAAClD,IAAI,CAAC;EAC5B;EAEA,IAAM4C,IAAI,GAAG5C,IAAI,GAAG,UAAU,GAAGkC,MAAM,CAACW,WAAW,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,KAAK,CAAC;EACvEhD,EAAE,CAACqD,UAAU,CAACnD,IAAI,EAAE4C,IAAI,CAAC;EACzB9C,EAAE,CAACoD,UAAU,CAACN,IAAI,CAAC;AACrB,CAAC;;AAED;AACA,IAAMQ,MAAM,GAAG,SAATA,MAAMA,CAAIC,CAAC,EAAEC,CAAC,EAAEC,CAAC;EAAA,OACrBF,CAAC,KAAKA,CAAC,KAAK,CAAC,GAAGA,CAAC,GACfC,CAAC,KAAKA,CAAC,KAAK,CAAC,GAAGA,CAAC,GACjBC,CAAC;AAAA;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAGxD,IAAI;EAAA,OAAIM,UAAU,CAACD,QAAQ,CAACE,SAAS,CAACP,IAAI,CAAC,CAAC,CAAC,CACpEyD,WAAW,CAAC,CAAC;AAAA;AAEhB,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIC,KAAK,EAAEC,GAAG,EAAK;EACjCA,GAAG,GAAGJ,iBAAiB,CAACI,GAAG,CAAC;EAAA,IAAAC,SAAA,GAAAlE,0BAAA,CACTgE,KAAK,CAACG,IAAI,CAAC,CAAC;IAAAC,KAAA;EAAA;IAA/B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAiC;MAAA,IAAtBlE,KAAI,GAAA+D,KAAA,CAAAI,KAAA;MACb,IAAMC,KAAK,GAAGZ,iBAAiB,CAACxD,KAAI,CAAC;MACrC,IAAIoE,KAAK,KAAKR,GAAG,IAAIQ,KAAK,CAACC,OAAO,CAACT,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE;QACnDD,KAAK,CAACW,MAAM,CAACtE,KAAI,CAAC;MACpB;IACF;EAAC,SAAAuE,GAAA;IAAAV,SAAA,CAAAW,CAAA,CAAAD,GAAA;EAAA;IAAAV,SAAA,CAAAY,CAAA;EAAA;AACH,CAAC;AAED,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAAGf,KAAK,EAAI;EAAA,IAAAgB,UAAA,GAAAhF,0BAAA,CACPgE,KAAK,CAACG,IAAI,CAAC,CAAC;IAAAc,MAAA;EAAA;IAA9B,KAAAD,UAAA,CAAAX,CAAA,MAAAY,MAAA,GAAAD,UAAA,CAAAV,CAAA,IAAAC,IAAA,GAAgC;MAAA,IAArBW,GAAG,GAAAD,MAAA,CAAAT,KAAA;MACZR,KAAK,CAACW,MAAM,CAACO,GAAG,CAAC;IACnB;EAAC,SAAAN,GAAA;IAAAI,UAAA,CAAAH,CAAA,CAAAD,GAAA;EAAA;IAAAI,UAAA,CAAAF,CAAA;EAAA;AACH,CAAC;AAAA,IAEKK,MAAM,0BAAAC,OAAA;EAAAtF,SAAA,CAAAqF,MAAA,EAAAC,OAAA;EAAA,IAAAC,MAAA,GAAAtF,YAAA,CAAAoF,MAAA;EACV,SAAAA,OAAaG,GAAG,EAAE;IAAA,IAAAC,KAAA;IAAA7F,eAAA,OAAAyF,MAAA;IAChB,IAAI,CAACG,GAAG,EAAE;MACRA,GAAG,GAAG,CAAC,CAAC;IACV;IAEAA,GAAG,CAACE,MAAM,GAAG,UAAAC,CAAC,EAAI;MAChBF,KAAA,CAAKvD,KAAK,CAAC,GAAG,IAAI;MAClBuD,KAAA,CAAKtD,UAAU,CAAC,CAAC,CAAC;IACpB,CAAC;IAEDsD,KAAA,GAAAF,MAAA,CAAAK,IAAA,OAAMJ,GAAG;IAETC,KAAA,CAAKjD,WAAW,CAAC,GAAG,KAAK;IAEzBiD,KAAA,CAAKI,YAAY,GAAGnF,gBAAgB,CAAC,CAAC;IAEtC+E,KAAA,CAAKK,SAAS,GAAG,OAAON,GAAG,CAACM,SAAS,KAAK,UAAU,GAAGN,GAAG,CAACM,SAAS,GAAG,IAAI;IAE3EL,KAAA,CAAKM,QAAQ,GAAG,IAAI;IACpBN,KAAA,CAAKO,QAAQ,GAAG,KAAK;IAErBP,KAAA,CAAK1D,OAAO,CAAC,GAAG,CAAC;IACjB0D,KAAA,CAAKvD,KAAK,CAAC,GAAG,KAAK;IAEnBuD,KAAA,CAAKQ,QAAQ,GAAGT,GAAG,CAACS,QAAQ,IAAI,IAAIC,GAAG,CAAC,CAAC;IAEzC,IAAI,OAAOV,GAAG,CAACW,GAAG,KAAK,QAAQ,IAAI,OAAOX,GAAG,CAACY,GAAG,KAAK,QAAQ,EAAE;MAC9D;MACA,IAAI,OAAOZ,GAAG,CAACW,GAAG,KAAK,QAAQ,IAAI,OAAOX,GAAG,CAACY,GAAG,KAAK,QAAQ,EAAE;QAC9D,MAAM,IAAIC,SAAS,CAAC,6CAA6C,CAAC;MACpE;MACA,IAAIb,GAAG,CAACc,aAAa,EAAE;QACrB,MAAM,IAAID,SAAS,CACjB,gEAAgE,CAAC;MACrE;MACAZ,KAAA,CAAKU,GAAG,GAAGX,GAAG,CAACW,GAAG;MAClBV,KAAA,CAAKW,GAAG,GAAGZ,GAAG,CAACY,GAAG;MAClBX,KAAA,CAAKc,QAAQ,GAAG,IAAI;IACtB,CAAC,MAAM;MACLd,KAAA,CAAKU,GAAG,GAAG,IAAI;MACfV,KAAA,CAAKW,GAAG,GAAG,IAAI;MACfX,KAAA,CAAKc,QAAQ,GAAG,KAAK;IACvB;;IAEA;IACA,IAAIf,GAAG,CAACc,aAAa,KAAKE,SAAS,IAAI,OAAOhB,GAAG,CAACW,GAAG,KAAK,QAAQ,EAAE;MAClEV,KAAA,CAAKa,aAAa,GAAG1D,OAAO,CAAC6D,MAAM,IAAI7D,OAAO,CAAC6D,MAAM,CAAC,CAAC,KAAK,CAAC;IAC/D,CAAC,MAAM;MACLhB,KAAA,CAAKa,aAAa,GAAG,CAAC,CAACd,GAAG,CAACc,aAAa;IAC1C;IAEAb,KAAA,CAAKiB,UAAU,GAAG,CAACjB,KAAA,CAAKa,aAAa,IAAIb,KAAA,CAAKc,QAAQ,KAAK3D,OAAO,CAAC6D,MAAM,GACvE7D,OAAO,CAAC6D,MAAM,CAAC,CAAC,GAAG,IAAI;IACzBhB,KAAA,CAAKkB,UAAU,GAAG,CAAClB,KAAA,CAAKa,aAAa,IAAIb,KAAA,CAAKc,QAAQ,KAAK3D,OAAO,CAACgE,MAAM,GACvEhE,OAAO,CAACgE,MAAM,CAAC,CAAC,GAAG,IAAI;;IAEzB;IACA;IACAnB,KAAA,CAAKoB,UAAU,GAAGrB,GAAG,CAACqB,UAAU,KAAK,IAAI;;IAEzC;IACApB,KAAA,CAAKqB,KAAK,GAAG,CAAC,CAACtB,GAAG,CAACsB,KAAK,IAAI/D,SAAS;;IAErC;IACA0C,KAAA,CAAKsB,KAAK,GAAG,CAAC,CAACvB,GAAG,CAACuB,KAAK;;IAExB;IACAtB,KAAA,CAAKuB,IAAI,GAAG,CAAC,CAACxB,GAAG,CAACwB,IAAI;;IAEtB;IACAvB,KAAA,CAAKwB,OAAO,GAAG,CAAC,CAACzB,GAAG,CAACyB,OAAO;;IAE5B;IACA;IACA;IACAxB,KAAA,CAAKyB,aAAa,GAAG,CAAC,CAAC1B,GAAG,CAAC0B,aAAa;;IAExC;IACA;IACAzB,KAAA,CAAKvC,MAAM,GAAG,CAAC,CAACsC,GAAG,CAACtC,MAAM;IAE1BuC,KAAA,CAAK0B,GAAG,GAAGvG,QAAQ,CAACL,IAAI,CAAC6G,OAAO,CAAC5B,GAAG,CAAC2B,GAAG,IAAIvE,OAAO,CAACuE,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3D1B,KAAA,CAAK4B,KAAK,GAAG,CAAC7B,GAAG,CAAC6B,KAAK,IAAI,CAAC;IAC5B;IACA5B,KAAA,CAAK6B,YAAY,GAAG9B,GAAG,CAAC+B,OAAO,GAAG,CAAC,GAAG3E,OAAO,CAAC4E,KAAK,CAAC,CAAC;IACrD/B,KAAA,CAAK+B,KAAK,GAAG,OAAOhC,GAAG,CAACgC,KAAK,KAAK,QAAQ,GAAGhC,GAAG,CAACgC,KAAK,GAAG/B,KAAA,CAAK6B,YAAY;;IAE1E;IACA7B,KAAA,CAAKgC,KAAK,GAAGjC,GAAG,CAACiC,KAAK,IAAK,GAAM,GAAI,CAAChC,KAAA,CAAK+B,KAAO;IAClD/B,KAAA,CAAKiC,KAAK,GAAGlC,GAAG,CAACkC,KAAK,IAAK,GAAM,GAAI,CAACjC,KAAA,CAAK+B,KAAO;IAElD/B,KAAA,CAAKkC,EAAE,CAAC,OAAO,EAAE,UAAAC,KAAK;MAAA,OAAInC,KAAA,CAAK1E,OAAO,CAAC,CAAC6G,KAAK,CAAC;IAAA,EAAC;IAAA,OAAAnC,KAAA;EACjD;;EAEA;EACA;EACA;EAAA5F,YAAA,CAAAwF,MAAA;IAAAD,GAAA;IAAAV,KAAA,EACA,SAAAmD,KAAMC,IAAI,EAAEC,GAAG,EAAa;MAAA,IAAXC,IAAI,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAzB,SAAA,GAAAyB,SAAA,MAAG,CAAC,CAAC;MACxB,IAAIH,IAAI,KAAK,iBAAiB,IAAIA,IAAI,KAAK,WAAW,EAAE;QACtDE,IAAI,CAACG,WAAW,GAAG,KAAK;MAC1B;MACA,OAAArI,IAAA,CAAAC,eAAA,CAAAsF,MAAA,CAAA+C,SAAA,iBAAAxC,IAAA,OAAkBkC,IAAI,EAAEC,GAAG,EAAEC,IAAI;IACnC;EAAC;IAAA5C,GAAA,EAEAjD,UAAU;IAAAuC,KAAA,EAAX,SAAAA,MAAA,EAAgB;MACd,IAAI,IAAI,CAACxC,KAAK,CAAC,IAAI,IAAI,CAACH,OAAO,CAAC,KAAK,CAAC,EAAE;QACtC,IAAI,CAACsG,IAAI,CAAC,WAAW,CAAC;QACtB,IAAI,CAACA,IAAI,CAAC,QAAQ,CAAC;QACnB,IAAI,CAACA,IAAI,CAAC,KAAK,CAAC;MAClB;IACF;EAAC;IAAAjD,GAAA,EAEAxD,SAAS;IAAA8C,KAAA,EAAV,SAAAA,MAAakD,KAAK,EAAE;MAClB,IAAI,IAAI,CAACP,KAAK,EAAE;QACd,IAAMiB,KAAK,GAAG1H,QAAQ,CAACgH,KAAK,CAACrH,IAAI,CAAC,CAACgI,KAAK,CAAC,GAAG,CAAC;QAC7C,IAAID,KAAK,CAACJ,MAAM,GAAG,IAAI,CAACb,KAAK,EAAE;UAC7B,OAAO,KAAK;QACd;QACAO,KAAK,CAACrH,IAAI,GAAG+H,KAAK,CAACE,KAAK,CAAC,IAAI,CAACnB,KAAK,CAAC,CAACoB,IAAI,CAAC,GAAG,CAAC;QAE9C,IAAIb,KAAK,CAACc,IAAI,KAAK,MAAM,EAAE;UACzB,IAAMC,SAAS,GAAG/H,QAAQ,CAACgH,KAAK,CAACgB,QAAQ,CAAC,CAACL,KAAK,CAAC,GAAG,CAAC;UACrD,IAAII,SAAS,CAACT,MAAM,IAAI,IAAI,CAACb,KAAK,EAAE;YAClCO,KAAK,CAACgB,QAAQ,GAAGD,SAAS,CAACH,KAAK,CAAC,IAAI,CAACnB,KAAK,CAAC,CAACoB,IAAI,CAAC,GAAG,CAAC;UACxD,CAAC,MAAM;YACL,OAAO,KAAK;UACd;QACF;MACF;MAEA,IAAI,CAAC,IAAI,CAACvB,aAAa,EAAE;QACvB,IAAM2B,CAAC,GAAGjI,QAAQ,CAACgH,KAAK,CAACrH,IAAI,CAAC;QAC9B,IAAM+H,MAAK,GAAGO,CAAC,CAACN,KAAK,CAAC,GAAG,CAAC;QAC1B,IAAID,MAAK,CAACQ,QAAQ,CAAC,IAAI,CAAC,IAAI/F,SAAS,IAAI,eAAe,CAACgG,IAAI,CAACT,MAAK,CAAC,CAAC,CAAC,CAAC,EAAE;UACvE,IAAI,CAACT,IAAI,CAAC,iBAAiB,wBAAwB;YACjDD,KAAK,EAALA,KAAK;YACLrH,IAAI,EAAEsI;UACR,CAAC,CAAC;UACF,OAAO,KAAK;QACd;;QAEA;QACA,IAAAG,kBAAA,GAAyBrI,iBAAiB,CAACkI,CAAC,CAAC;UAAAI,mBAAA,GAAAxJ,cAAA,CAAAuJ,kBAAA;UAAtCE,IAAI,GAAAD,mBAAA;UAAEE,QAAQ,GAAAF,mBAAA;QACrB,IAAIC,IAAI,EAAE;UACRtB,KAAK,CAACrH,IAAI,GAAG4I,QAAQ;UACrB,IAAI,CAACtB,IAAI,CAAC,gBAAgB,eAAAuB,MAAA,CAAeF,IAAI,0BAAuB;YAClEtB,KAAK,EAALA,KAAK;YACLrH,IAAI,EAAEsI;UACR,CAAC,CAAC;QACJ;MACF;MAEA,IAAItI,IAAI,CAAC8I,UAAU,CAACzB,KAAK,CAACrH,IAAI,CAAC,EAAE;QAC/BqH,KAAK,CAAC0B,QAAQ,GAAG1I,QAAQ,CAACL,IAAI,CAAC6G,OAAO,CAACQ,KAAK,CAACrH,IAAI,CAAC,CAAC;MACrD,CAAC,MAAM;QACLqH,KAAK,CAAC0B,QAAQ,GAAG1I,QAAQ,CAACL,IAAI,CAAC6G,OAAO,CAAC,IAAI,CAACD,GAAG,EAAES,KAAK,CAACrH,IAAI,CAAC,CAAC;MAC/D;;MAEA;MACA;MACA;MACA;MACA,IAAI,CAAC,IAAI,CAAC2G,aAAa,IACnBU,KAAK,CAAC0B,QAAQ,CAAC1E,OAAO,CAAC,IAAI,CAACuC,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,IAC5CS,KAAK,CAAC0B,QAAQ,KAAK,IAAI,CAACnC,GAAG,EAAE;QAC/B,IAAI,CAACU,IAAI,CAAC,iBAAiB,EAAE,gCAAgC,EAAE;UAC7DD,KAAK,EAALA,KAAK;UACLrH,IAAI,EAAEK,QAAQ,CAACgH,KAAK,CAACrH,IAAI,CAAC;UAC1BgJ,YAAY,EAAE3B,KAAK,CAAC0B,QAAQ;UAC5BnC,GAAG,EAAE,IAAI,CAACA;QACZ,CAAC,CAAC;QACF,OAAO,KAAK;MACd;;MAEA;MACA;MACA,IAAIS,KAAK,CAAC0B,QAAQ,KAAK,IAAI,CAACnC,GAAG,IAC3BS,KAAK,CAACc,IAAI,KAAK,WAAW,IAC1Bd,KAAK,CAACc,IAAI,KAAK,YAAY,EAAE;QAC/B,OAAO,KAAK;MACd;;MAEA;MACA,IAAI,IAAI,CAAC5B,KAAK,EAAE;QACd,IAAA0C,iBAAA,GAAwBjJ,IAAI,CAACuG,KAAK,CAAC2C,KAAK,CAAC7B,KAAK,CAAC0B,QAAQ,CAAC;UAA1CI,KAAK,GAAAF,iBAAA,CAAXN,IAAI;QACZtB,KAAK,CAAC0B,QAAQ,GAAGI,KAAK,GAAGjJ,EAAE,CAACkJ,MAAM,CAAC/B,KAAK,CAAC0B,QAAQ,CAACd,KAAK,CAACkB,KAAK,CAACxB,MAAM,CAAC,CAAC;QACtE,IAAA0B,kBAAA,GAAwBrJ,IAAI,CAACuG,KAAK,CAAC2C,KAAK,CAAC7B,KAAK,CAACrH,IAAI,CAAC;UAAtCsJ,KAAK,GAAAD,kBAAA,CAAXV,IAAI;QACZtB,KAAK,CAACrH,IAAI,GAAGsJ,KAAK,GAAGpJ,EAAE,CAACkJ,MAAM,CAAC/B,KAAK,CAACrH,IAAI,CAACiI,KAAK,CAACqB,KAAK,CAAC3B,MAAM,CAAC,CAAC;MAChE;MAEA,OAAO,IAAI;IACb;EAAC;IAAA9C,GAAA,EAEArE,OAAO;IAAA2D,KAAA,EAAR,SAAAA,MAAWkD,KAAK,EAAE;MAChB,IAAI,CAAC,IAAI,CAAChG,SAAS,CAAC,CAACgG,KAAK,CAAC,EAAE;QAC3B,OAAOA,KAAK,CAACkC,MAAM,CAAC,CAAC;MACvB;MAEA3J,MAAM,CAAC4J,KAAK,CAAC,OAAOnC,KAAK,CAAC0B,QAAQ,EAAE,QAAQ,CAAC;MAE7C,QAAQ1B,KAAK,CAACc,IAAI;QAChB,KAAK,WAAW;QAChB,KAAK,YAAY;UACf,IAAId,KAAK,CAACoC,IAAI,EAAE;YACdpC,KAAK,CAACoC,IAAI,GAAGpC,KAAK,CAACoC,IAAI,GAAG,GAAK;UACjC;;QAEF;QACA,KAAK,MAAM;QACX,KAAK,SAAS;QACd,KAAK,gBAAgB;QACrB,KAAK,MAAM;QACX,KAAK,cAAc;UACjB,OAAO,IAAI,CAAC/I,OAAO,CAAC,CAAC2G,KAAK,CAAC;QAE7B,KAAK,iBAAiB;QACtB,KAAK,aAAa;QAClB,KAAK,MAAM;QACX;UACE,OAAO,IAAI,CAACjG,WAAW,CAAC,CAACiG,KAAK,CAAC;MACnC;IACF;EAAC;IAAAxC,GAAA,EAEAtD,OAAO;IAAA4C,KAAA,EAAR,SAAAA,MAAWnB,EAAE,EAAEqE,KAAK,EAAE;MACpB;MACA;MACA;MACA,IAAIrE,EAAE,CAACJ,IAAI,KAAK,UAAU,EAAE;QAC1B,IAAI,CAACkF,IAAI,CAAC,OAAO,EAAE9E,EAAE,CAAC;MACxB,CAAC,MAAM;QACL,IAAI,CAACsE,IAAI,CAAC,iBAAiB,EAAEtE,EAAE,EAAE;UAAEqE,KAAK,EAALA;QAAM,CAAC,CAAC;QAC3C,IAAI,CAAC3F,MAAM,CAAC,CAAC,CAAC;QACd2F,KAAK,CAACkC,MAAM,CAAC,CAAC;MAChB;IACF;EAAC;IAAA1E,GAAA,EAEAvD,KAAK;IAAA6C,KAAA,EAAN,SAAAA,MAASuF,GAAG,EAAED,IAAI,EAAE/G,EAAE,EAAE;MACtBzC,KAAK,CAACI,QAAQ,CAACqJ,GAAG,CAAC,EAAE;QACnB9D,GAAG,EAAE,IAAI,CAACA,GAAG;QACbC,GAAG,EAAE,IAAI,CAACA,GAAG;QACbM,UAAU,EAAE,IAAI,CAACA,UAAU;QAC3BC,UAAU,EAAE,IAAI,CAACA,UAAU;QAC3Ba,KAAK,EAAE,IAAI,CAACF,YAAY;QACxB4C,QAAQ,EAAE,IAAI,CAAChD,aAAa;QAC5BhE,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBgB,KAAK,EAAE,IAAI,CAAC+B,QAAQ;QACpBkB,GAAG,EAAE,IAAI,CAACA,GAAG;QACb6C,IAAI,EAAEA,IAAI;QACVzC,OAAO,EAAE,IAAI,CAACA;MAChB,CAAC,EAAEtE,EAAE,CAAC;IACR;EAAC;IAAAmC,GAAA,EAEA/C,OAAO;IAAAqC,KAAA,EAAR,SAAAA,MAAWkD,KAAK,EAAE;MAChB;MACA;MACA,OAAO,IAAI,CAACf,UAAU,IACpB,IAAI,CAACP,aAAa,KACjB,OAAOsB,KAAK,CAACzB,GAAG,KAAK,QAAQ,IAAIyB,KAAK,CAACzB,GAAG,KAAK,IAAI,CAACO,UAAU,IAC7D,OAAOkB,KAAK,CAACxB,GAAG,KAAK,QAAQ,IAAIwB,KAAK,CAACxB,GAAG,KAAK,IAAI,CAACO,UAAU,CAAC,IAEhE,OAAO,IAAI,CAACR,GAAG,KAAK,QAAQ,IAAI,IAAI,CAACA,GAAG,KAAK,IAAI,CAACO,UAAU,IAC3D,OAAO,IAAI,CAACN,GAAG,KAAK,QAAQ,IAAI,IAAI,CAACA,GAAG,KAAK,IAAI,CAACO,UAAW;IACnE;EAAC;IAAAvB,GAAA,EAEA9C,GAAG;IAAAoC,KAAA,EAAJ,SAAAA,MAAOkD,KAAK,EAAE;MACZ,OAAOjE,MAAM,CAAC,IAAI,CAACwC,GAAG,EAAEyB,KAAK,CAACzB,GAAG,EAAE,IAAI,CAACO,UAAU,CAAC;IACrD;EAAC;IAAAtB,GAAA,EAEA7C,GAAG;IAAAmC,KAAA,EAAJ,SAAAA,MAAOkD,KAAK,EAAE;MACZ,OAAOjE,MAAM,CAAC,IAAI,CAACyC,GAAG,EAAEwB,KAAK,CAACxB,GAAG,EAAE,IAAI,CAACO,UAAU,CAAC;IACrD;EAAC;IAAAvB,GAAA,EAEA9D,IAAI;IAAAoD,KAAA,EAAL,SAAAA,MAAQkD,KAAK,EAAEuC,SAAS,EAAE;MAAA,IAAAC,MAAA;MACxB,IAAMJ,IAAI,GAAGpC,KAAK,CAACoC,IAAI,GAAG,IAAM,IAAI,IAAI,CAACtC,KAAK;MAC9C,IAAM2C,MAAM,GAAG,IAAI/J,GAAG,CAACgK,WAAW,CAAC1C,KAAK,CAAC0B,QAAQ,EAAE;QACjDiB,KAAK,EAAE7H,OAAO,CAACkF,KAAK,CAAC4C,IAAI,CAAC;QAC1BR,IAAI,EAAEA,IAAI;QACVS,SAAS,EAAE;MACb,CAAC,CAAC;MACFJ,MAAM,CAAC1C,EAAE,CAAC,OAAO,EAAE,UAAApE,EAAE,EAAI;QACvB,IAAI8G,MAAM,CAACK,EAAE,EAAE;UACbrK,EAAE,CAACsK,KAAK,CAACN,MAAM,CAACK,EAAE,EAAE,YAAM,CAAC,CAAC,CAAC;QAC/B;;QAEA;QACA;QACA;QACAL,MAAM,CAACO,KAAK,GAAG;UAAA,OAAM,IAAI;QAAA;QACzBR,MAAI,CAACtI,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;QACxBuC,SAAS,CAAC,CAAC;MACb,CAAC,CAAC;MAEF,IAAIU,OAAO,GAAG,CAAC;MACf,IAAMpG,IAAI,GAAG,SAAPA,IAAIA,CAAGlB,EAAE,EAAI;QACjB,IAAIA,EAAE,EAAE;UACN;UACA,IAAI8G,MAAM,CAACK,EAAE,EAAE;YACbrK,EAAE,CAACsK,KAAK,CAACN,MAAM,CAACK,EAAE,EAAE,YAAM,CAAC,CAAC,CAAC;UAC/B;UAEAN,MAAI,CAACtI,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;UACxBuC,SAAS,CAAC,CAAC;UACX;QACF;QAEA,IAAI,EAAEU,OAAO,KAAK,CAAC,EAAE;UACnBxK,EAAE,CAACsK,KAAK,CAACN,MAAM,CAACK,EAAE,EAAE,UAAAnH,EAAE,EAAI;YACxB,IAAIA,EAAE,EAAE;cACN6G,MAAI,CAACtI,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;YAC1B,CAAC,MAAM;cACLwC,MAAI,CAACnI,MAAM,CAAC,CAAC,CAAC;YAChB;YACAkI,SAAS,CAAC,CAAC;UACb,CAAC,CAAC;QACJ;MACF,CAAC;MAEDE,MAAM,CAAC1C,EAAE,CAAC,QAAQ,EAAE,UAAAhC,CAAC,EAAI;QACvB;QACA;QACA;QACA,IAAMxB,GAAG,GAAGyD,KAAK,CAAC0B,QAAQ;QAC1B,IAAMoB,EAAE,GAAGL,MAAM,CAACK,EAAE;QAEpB,IAAI9C,KAAK,CAACkD,KAAK,IAAI,CAACV,MAAI,CAACnD,OAAO,EAAE;UAChC4D,OAAO,EAAE;UACT,IAAME,KAAK,GAAGnD,KAAK,CAACmD,KAAK,IAAI,IAAIC,IAAI,CAAC,CAAC;UACvC,IAAMF,KAAK,GAAGlD,KAAK,CAACkD,KAAK;UACzBzK,EAAE,CAAC4K,OAAO,CAACP,EAAE,EAAEK,KAAK,EAAED,KAAK,EAAE,UAAAvH,EAAE;YAAA,OAC7BA,EAAE,GAAGlD,EAAE,CAAC6K,MAAM,CAAC/G,GAAG,EAAE4G,KAAK,EAAED,KAAK,EAAE,UAAAK,GAAG;cAAA,OAAI1G,IAAI,CAAC0G,GAAG,IAAI5H,EAAE,CAAC;YAAA,EAAC,GACvDkB,IAAI,CAAC,CAAC;UAAA,EAAC;QACb;QAEA,IAAI2F,MAAI,CAAC/H,OAAO,CAAC,CAACuF,KAAK,CAAC,EAAE;UACxBiD,OAAO,EAAE;UACT,IAAM1E,GAAG,GAAGiE,MAAI,CAAC9H,GAAG,CAAC,CAACsF,KAAK,CAAC;UAC5B,IAAMxB,GAAG,GAAGgE,MAAI,CAAC7H,GAAG,CAAC,CAACqF,KAAK,CAAC;UAC5BvH,EAAE,CAAC+K,MAAM,CAACV,EAAE,EAAEvE,GAAG,EAAEC,GAAG,EAAE,UAAA7C,EAAE;YAAA,OACxBA,EAAE,GAAGlD,EAAE,CAACgL,KAAK,CAAClH,GAAG,EAAEgC,GAAG,EAAEC,GAAG,EAAE,UAAA+E,GAAG;cAAA,OAAI1G,IAAI,CAAC0G,GAAG,IAAI5H,EAAE,CAAC;YAAA,EAAC,GAClDkB,IAAI,CAAC,CAAC;UAAA,EAAC;QACb;QAEAA,IAAI,CAAC,CAAC;MACR,CAAC,CAAC;MAEF,IAAM6G,EAAE,GAAG,IAAI,CAACxF,SAAS,GAAG,IAAI,CAACA,SAAS,CAAC8B,KAAK,CAAC,IAAIA,KAAK,GAAGA,KAAK;MAClE,IAAI0D,EAAE,KAAK1D,KAAK,EAAE;QAChB0D,EAAE,CAAC3D,EAAE,CAAC,OAAO,EAAE,UAAApE,EAAE,EAAI;UACnB6G,MAAI,CAACtI,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;UACxBuC,SAAS,CAAC,CAAC;QACb,CAAC,CAAC;QACFvC,KAAK,CAAC2D,IAAI,CAACD,EAAE,CAAC;MAChB;MACAA,EAAE,CAACC,IAAI,CAAClB,MAAM,CAAC;IACjB;EAAC;IAAAjF,GAAA,EAEA7D,SAAS;IAAAmD,KAAA,EAAV,SAAAA,MAAakD,KAAK,EAAEuC,SAAS,EAAE;MAAA,IAAAqB,MAAA;MAC7B,IAAMxB,IAAI,GAAGpC,KAAK,CAACoC,IAAI,GAAG,IAAM,IAAI,IAAI,CAACvC,KAAK;MAC9C,IAAI,CAAC5F,KAAK,CAAC,CAAC+F,KAAK,CAAC0B,QAAQ,EAAEU,IAAI,EAAE,UAAAzG,EAAE,EAAI;QACtC,IAAIA,EAAE,EAAE;UACNiI,MAAI,CAAC1J,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;UACxBuC,SAAS,CAAC,CAAC;UACX;QACF;QAEA,IAAIU,OAAO,GAAG,CAAC;QACf,IAAMpG,IAAI,GAAG,SAAPA,IAAIA,CAAGkB,CAAC,EAAI;UAChB,IAAI,EAAEkF,OAAO,KAAK,CAAC,EAAE;YACnBV,SAAS,CAAC,CAAC;YACXqB,MAAI,CAACvJ,MAAM,CAAC,CAAC,CAAC;YACd2F,KAAK,CAACkC,MAAM,CAAC,CAAC;UAChB;QACF,CAAC;QAED,IAAIlC,KAAK,CAACkD,KAAK,IAAI,CAACU,MAAI,CAACvE,OAAO,EAAE;UAChC4D,OAAO,EAAE;UACTxK,EAAE,CAAC6K,MAAM,CAACtD,KAAK,CAAC0B,QAAQ,EAAE1B,KAAK,CAACmD,KAAK,IAAI,IAAIC,IAAI,CAAC,CAAC,EAAEpD,KAAK,CAACkD,KAAK,EAAErG,IAAI,CAAC;QACzE;QAEA,IAAI+G,MAAI,CAACnJ,OAAO,CAAC,CAACuF,KAAK,CAAC,EAAE;UACxBiD,OAAO,EAAE;UACTxK,EAAE,CAACgL,KAAK,CAACzD,KAAK,CAAC0B,QAAQ,EAAEkC,MAAI,CAAClJ,GAAG,CAAC,CAACsF,KAAK,CAAC,EAAE4D,MAAI,CAACjJ,GAAG,CAAC,CAACqF,KAAK,CAAC,EAAEnD,IAAI,CAAC;QACpE;QAEAA,IAAI,CAAC,CAAC;MACR,CAAC,CAAC;IACJ;EAAC;IAAAW,GAAA,EAEAzD,WAAW;IAAA+C,KAAA,EAAZ,SAAAA,MAAekD,KAAK,EAAE;MACpBA,KAAK,CAAC6D,WAAW,GAAG,IAAI;MACxB,IAAI,CAAC5D,IAAI,CAAC,uBAAuB,6BAAAuB,MAAA,CACJxB,KAAK,CAACc,IAAI,GAAI;QAAEd,KAAK,EAALA;MAAM,CAAC,CAAC;MACrDA,KAAK,CAACkC,MAAM,CAAC,CAAC;IAChB;EAAC;IAAA1E,GAAA,EAEA3D,OAAO;IAAAiD,KAAA,EAAR,SAAAA,MAAWkD,KAAK,EAAEnD,IAAI,EAAE;MACtB,IAAI,CAACjD,IAAI,CAAC,CAACoG,KAAK,EAAEA,KAAK,CAACgB,QAAQ,EAAE,SAAS,EAAEnE,IAAI,CAAC;IACpD;EAAC;IAAAW,GAAA,EAEA1D,QAAQ;IAAAgD,KAAA,EAAT,SAAAA,MAAYkD,KAAK,EAAEnD,IAAI,EAAE;MACvB,IAAMmE,QAAQ,GAAGhI,QAAQ,CAACL,IAAI,CAAC6G,OAAO,CAAC,IAAI,CAACD,GAAG,EAAES,KAAK,CAACgB,QAAQ,CAAC,CAAC;MACjE,IAAI,CAACpH,IAAI,CAAC,CAACoG,KAAK,EAAEgB,QAAQ,EAAE,MAAM,EAAEnE,IAAI,CAAC;IAC3C;EAAC;IAAAW,GAAA,EAEApD,IAAI;IAAA0C,KAAA,EAAL,SAAAA,MAAA,EAAU;MACR,IAAI,CAAC3C,OAAO,CAAC,EAAE;IACjB;EAAC;IAAAqD,GAAA,EAEAnD,MAAM;IAAAyC,KAAA,EAAP,SAAAA,MAAA,EAAY;MACV,IAAI,CAAC3C,OAAO,CAAC,EAAE;MACf,IAAI,CAACI,UAAU,CAAC,CAAC,CAAC;IACpB;EAAC;IAAAiD,GAAA,EAEAhD,IAAI;IAAAsC,KAAA,EAAL,SAAAA,MAAQkD,KAAK,EAAE;MACb,IAAI,CAAC3F,MAAM,CAAC,CAAC,CAAC;MACd2F,KAAK,CAACkC,MAAM,CAAC,CAAC;IAChB;;IAEA;IACA;IACA;EAAA;IAAA1E,GAAA,EACChE,UAAU;IAAAsD,KAAA,EAAX,SAAAA,MAAckD,KAAK,EAAE8D,EAAE,EAAE;MACvB,OAAO9D,KAAK,CAACc,IAAI,KAAK,MAAM,IAC1B,CAAC,IAAI,CAACxF,MAAM,IACZwI,EAAE,CAACC,MAAM,CAAC,CAAC,IACXD,EAAE,CAACE,KAAK,IAAI,CAAC,IACb,CAAC7I,SAAS;IACd;;IAEA;EAAA;IAAAqC,GAAA,EACCnE,OAAO;IAAAyD,KAAA,EAAR,SAAAA,MAAWkD,KAAK,EAAE;MAAA,IAAAiE,MAAA;MAChB,IAAI,CAAC7J,IAAI,CAAC,CAAC,CAAC;MACZ,IAAM8J,KAAK,GAAG,CAAClE,KAAK,CAACrH,IAAI,CAAC;MAC1B,IAAIqH,KAAK,CAACgB,QAAQ,EAAE;QAClBkD,KAAK,CAACC,IAAI,CAACnE,KAAK,CAACgB,QAAQ,CAAC;MAC5B;MACA,IAAI,CAAC/C,YAAY,CAACmG,OAAO,CAACF,KAAK,EAAE,UAAArH,IAAI;QAAA,OAAIoH,MAAI,CAAC3K,QAAQ,CAAC,CAAC0G,KAAK,EAAEnD,IAAI,CAAC;MAAA,EAAC;IACvE;EAAC;IAAAW,GAAA,EAEAjE,UAAU;IAAAuD,KAAA,EAAX,SAAAA,MAAckD,KAAK,EAAE;MACnB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIA,KAAK,CAACc,IAAI,KAAK,cAAc,EAAE;QACjCzD,SAAS,CAAC,IAAI,CAACgB,QAAQ,CAAC;MAC1B,CAAC,MAAM,IAAI2B,KAAK,CAACc,IAAI,KAAK,WAAW,EAAE;QACrCzE,UAAU,CAAC,IAAI,CAACgC,QAAQ,EAAE2B,KAAK,CAAC0B,QAAQ,CAAC;MAC3C;IACF;EAAC;IAAAlE,GAAA,EAEAlE,QAAQ;IAAAwD,KAAA,EAAT,SAAAA,MAAYkD,KAAK,EAAEuC,SAAS,EAAE;MAAA,IAAA8B,MAAA;MAC5B,IAAI,CAAC9K,UAAU,CAAC,CAACyG,KAAK,CAAC;MAEvB,IAAMnD,IAAI,GAAG,SAAPA,IAAIA,CAAGlB,EAAE,EAAI;QACjB0I,MAAI,CAAC9K,UAAU,CAAC,CAACyG,KAAK,CAAC;QACvBuC,SAAS,CAAC5G,EAAE,CAAC;MACf,CAAC;MAED,IAAM2I,QAAQ,GAAG,SAAXA,QAAQA,CAAA,EAAS;QACrBD,MAAI,CAACpK,KAAK,CAAC,CAACoK,MAAI,CAAC9E,GAAG,EAAE8E,MAAI,CAACxE,KAAK,EAAE,UAAAlE,EAAE,EAAI;UACtC,IAAIA,EAAE,EAAE;YACN0I,MAAI,CAACnK,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;YACxBnD,IAAI,CAAC,CAAC;YACN;UACF;UACAwH,MAAI,CAACzJ,WAAW,CAAC,GAAG,IAAI;UACxB2J,KAAK,CAAC,CAAC;QACT,CAAC,CAAC;MACJ,CAAC;MAED,IAAMA,KAAK,GAAG,SAARA,KAAKA,CAAA,EAAS;QAClB,IAAIvE,KAAK,CAAC0B,QAAQ,KAAK2C,MAAI,CAAC9E,GAAG,EAAE;UAC/B,IAAMiF,MAAM,GAAGxL,QAAQ,CAACL,IAAI,CAAC8L,OAAO,CAACzE,KAAK,CAAC0B,QAAQ,CAAC,CAAC;UACrD,IAAI8C,MAAM,KAAKH,MAAI,CAAC9E,GAAG,EAAE;YACvB,OAAO8E,MAAI,CAACpK,KAAK,CAAC,CAACuK,MAAM,EAAEH,MAAI,CAACxE,KAAK,EAAE,UAAAlE,EAAE,EAAI;cAC3C,IAAIA,EAAE,EAAE;gBACN0I,MAAI,CAACnK,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;gBACxBnD,IAAI,CAAC,CAAC;gBACN;cACF;cACA6H,eAAe,CAAC,CAAC;YACnB,CAAC,CAAC;UACJ;QACF;QACAA,eAAe,CAAC,CAAC;MACnB,CAAC;MAED,IAAMA,eAAe,GAAG,SAAlBA,eAAeA,CAAA,EAAS;QAC5BjM,EAAE,CAACkM,KAAK,CAAC3E,KAAK,CAAC0B,QAAQ,EAAE,UAACkD,OAAO,EAAEd,EAAE,EAAK;UACxC,IAAIA,EAAE,KAAKO,MAAI,CAACjF,IAAI,IAAIiF,MAAI,CAAClF,KAAK,IAAI2E,EAAE,CAACZ,KAAK,GAAGlD,KAAK,CAACkD,KAAK,CAAC,EAAE;YAC7DmB,MAAI,CAAC7J,IAAI,CAAC,CAACwF,KAAK,CAAC;YACjBnD,IAAI,CAAC,CAAC;YACN;UACF;UACA,IAAI+H,OAAO,IAAIP,MAAI,CAAC7K,UAAU,CAAC,CAACwG,KAAK,EAAE8D,EAAE,CAAC,EAAE;YAC1C,OAAOO,MAAI,CAAC5K,MAAM,CAAC,CAAC,IAAI,EAAEuG,KAAK,EAAEnD,IAAI,CAAC;UACxC;UAEA,IAAIiH,EAAE,CAACe,WAAW,CAAC,CAAC,EAAE;YACpB,IAAI7E,KAAK,CAACc,IAAI,KAAK,WAAW,EAAE;cAC9B,IAAMgE,SAAS,GAAG,CAACT,MAAI,CAAC1E,OAAO,IAC7BK,KAAK,CAACoC,IAAI,IACV,CAAC0B,EAAE,CAAC1B,IAAI,GAAG,IAAM,MAAMpC,KAAK,CAACoC,IAAI;cACnC,IAAM2C,UAAU,GAAG,SAAbA,UAAUA,CAAGpJ,EAAE;gBAAA,OAAI0I,MAAI,CAAC5K,MAAM,CAAC,CAACkC,EAAE,EAAEqE,KAAK,EAAEnD,IAAI,CAAC;cAAA;cACtD,IAAI,CAACiI,SAAS,EAAE;gBACd,OAAOC,UAAU,CAAC,CAAC;cACrB;cACA,OAAOtM,EAAE,CAACuM,KAAK,CAAChF,KAAK,CAAC0B,QAAQ,EAAE1B,KAAK,CAACoC,IAAI,EAAE2C,UAAU,CAAC;YACzD;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA,IAAI/E,KAAK,CAAC0B,QAAQ,KAAK2C,MAAI,CAAC9E,GAAG,EAAE;cAC/B,OAAO9G,EAAE,CAACwM,KAAK,CAACjF,KAAK,CAAC0B,QAAQ,EAAE,UAAA/F,EAAE;gBAAA,OAChC0I,MAAI,CAAC5K,MAAM,CAAC,CAACkC,EAAE,EAAEqE,KAAK,EAAEnD,IAAI,CAAC;cAAA,EAAC;YAClC;UACF;;UAEA;UACA;UACA,IAAImD,KAAK,CAAC0B,QAAQ,KAAK2C,MAAI,CAAC9E,GAAG,EAAE;YAC/B,OAAO8E,MAAI,CAAC5K,MAAM,CAAC,CAAC,IAAI,EAAEuG,KAAK,EAAEnD,IAAI,CAAC;UACxC;UAEAzB,UAAU,CAAC4E,KAAK,CAAC0B,QAAQ,EAAE,UAAA/F,EAAE;YAAA,OAC3B0I,MAAI,CAAC5K,MAAM,CAAC,CAACkC,EAAE,EAAEqE,KAAK,EAAEnD,IAAI,CAAC;UAAA,EAAC;QAClC,CAAC,CAAC;MACJ,CAAC;MAED,IAAI,IAAI,CAACjC,WAAW,CAAC,EAAE;QACrB2J,KAAK,CAAC,CAAC;MACT,CAAC,MAAM;QACLD,QAAQ,CAAC,CAAC;MACZ;IACF;EAAC;IAAA9G,GAAA,EAEA/D,MAAM;IAAAqD,KAAA,EAAP,SAAAA,MAAUnB,EAAE,EAAEqE,KAAK,EAAEnD,IAAI,EAAE;MACzB,IAAIlB,EAAE,EAAE;QACN,IAAI,CAACzB,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;QACxBnD,IAAI,CAAC,CAAC;QACN;MACF;MAEA,QAAQmD,KAAK,CAACc,IAAI;QAChB,KAAK,MAAM;QACX,KAAK,SAAS;QACd,KAAK,gBAAgB;UACnB,OAAO,IAAI,CAACpH,IAAI,CAAC,CAACsG,KAAK,EAAEnD,IAAI,CAAC;QAEhC,KAAK,MAAM;UACT,OAAO,IAAI,CAAC/C,QAAQ,CAAC,CAACkG,KAAK,EAAEnD,IAAI,CAAC;QAEpC,KAAK,cAAc;UACjB,OAAO,IAAI,CAAChD,OAAO,CAAC,CAACmG,KAAK,EAAEnD,IAAI,CAAC;QAEnC,KAAK,WAAW;QAChB,KAAK,YAAY;UACf,OAAO,IAAI,CAAClD,SAAS,CAAC,CAACqG,KAAK,EAAEnD,IAAI,CAAC;MACvC;IACF;EAAC;IAAAW,GAAA,EAEA5D,IAAI;IAAAkD,KAAA,EAAL,SAAAA,MAAQkD,KAAK,EAAEgB,QAAQ,EAAEkE,IAAI,EAAErI,IAAI,EAAE;MAAA,IAAAsI,MAAA;MACnC;MACA1M,EAAE,CAACyM,IAAI,CAAC,CAAClE,QAAQ,EAAEhB,KAAK,CAAC0B,QAAQ,EAAE,UAAA/F,EAAE,EAAI;QACvC,IAAIA,EAAE,EAAE;UACNwJ,MAAI,CAACjL,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;QAC1B,CAAC,MAAM;UACLmF,MAAI,CAAC9K,MAAM,CAAC,CAAC,CAAC;UACd2F,KAAK,CAACkC,MAAM,CAAC,CAAC;QAChB;QACArF,IAAI,CAAC,CAAC;MACR,CAAC,CAAC;IACJ;EAAC;EAAA,OAAAY,MAAA;AAAA,EAxkBkBjF,MAAM;AA2kB3B,IAAM4M,QAAQ,GAAG,SAAXA,QAAQA,CAAGC,EAAE,EAAI;EACrB,IAAI;IACF,OAAO,CAAC,IAAI,EAAEA,EAAE,CAAC,CAAC,CAAC;EACrB,CAAC,CAAC,OAAO1J,EAAE,EAAE;IACX,OAAO,CAACA,EAAE,EAAE,IAAI,CAAC;EACnB;AACF,CAAC;AAAA,IACK2J,UAAU,0BAAAC,OAAA;EAAAnN,SAAA,CAAAkN,UAAA,EAAAC,OAAA;EAAA,IAAAC,OAAA,GAAAnN,YAAA,CAAAiN,UAAA;EAAA,SAAAA,WAAA;IAAAtN,eAAA,OAAAsN,UAAA;IAAA,OAAAE,OAAA,CAAAC,KAAA,OAAApF,SAAA;EAAA;EAAApI,YAAA,CAAAqN,UAAA;IAAA9H,GAAA,EACb/D,MAAM;IAAAqD,KAAA,EAAP,SAAAA,MAAUnB,EAAE,EAAEqE,KAAK,EAAE;MACnB,OAAA9H,IAAA,CAAAC,eAAA,CAAAmN,UAAA,CAAA9E,SAAA,GAAa/G,MAAM,QAAAuE,IAAA,OAAErC,EAAE,EAAEqE,KAAK,EAAE,YAAM,CAAC,CAAC;IAC1C;EAAC;IAAAxC,GAAA,EAEAnE,OAAO;IAAAyD,KAAA,EAAR,SAAAA,MAAWkD,KAAK,EAAE;MAChB,IAAI,CAACzG,UAAU,CAAC,CAACyG,KAAK,CAAC;MAEvB,IAAI,CAAC,IAAI,CAACpF,WAAW,CAAC,EAAE;QACtB,IAAMe,GAAE,GAAG,IAAI,CAAC1B,KAAK,CAAC,CAAC,IAAI,CAACsF,GAAG,EAAE,IAAI,CAACM,KAAK,CAAC;QAC5C,IAAIlE,GAAE,EAAE;UACN,OAAO,IAAI,CAACzB,OAAO,CAAC,CAACyB,GAAE,EAAEqE,KAAK,CAAC;QACjC;QACA,IAAI,CAACpF,WAAW,CAAC,GAAG,IAAI;MAC1B;;MAEA;MACA;MACA,IAAIoF,KAAK,CAAC0B,QAAQ,KAAK,IAAI,CAACnC,GAAG,EAAE;QAC/B,IAAMiF,MAAM,GAAGxL,QAAQ,CAACL,IAAI,CAAC8L,OAAO,CAACzE,KAAK,CAAC0B,QAAQ,CAAC,CAAC;QACrD,IAAI8C,MAAM,KAAK,IAAI,CAACjF,GAAG,EAAE;UACvB,IAAMmG,QAAQ,GAAG,IAAI,CAACzL,KAAK,CAAC,CAACuK,MAAM,EAAE,IAAI,CAAC3E,KAAK,CAAC;UAChD,IAAI6F,QAAQ,EAAE;YACZ,OAAO,IAAI,CAACxL,OAAO,CAAC,CAACwL,QAAQ,EAAE1F,KAAK,CAAC;UACvC;QACF;MACF;MAEA,IAAA2F,SAAA,GAAsBP,QAAQ,CAAC;UAAA,OAAM3M,EAAE,CAACmN,SAAS,CAAC5F,KAAK,CAAC0B,QAAQ,CAAC;QAAA,EAAC;QAAAmE,UAAA,GAAAhO,cAAA,CAAA8N,SAAA;QAA3Df,OAAO,GAAAiB,UAAA;QAAE/B,EAAE,GAAA+B,UAAA;MAClB,IAAI/B,EAAE,KAAK,IAAI,CAAC1E,IAAI,IAAI,IAAI,CAACD,KAAK,IAAI2E,EAAE,CAACZ,KAAK,GAAGlD,KAAK,CAACkD,KAAK,CAAC,EAAE;QAC7D,OAAO,IAAI,CAAC1I,IAAI,CAAC,CAACwF,KAAK,CAAC;MAC1B;MAEA,IAAI4E,OAAO,IAAI,IAAI,CAACpL,UAAU,CAAC,CAACwG,KAAK,EAAE8D,EAAE,CAAC,EAAE;QAC1C,OAAO,IAAI,CAACrK,MAAM,CAAC,CAAC,IAAI,EAAEuG,KAAK,CAAC;MAClC;MAEA,IAAI8D,EAAE,CAACe,WAAW,CAAC,CAAC,EAAE;QACpB,IAAI7E,KAAK,CAACc,IAAI,KAAK,WAAW,EAAE;UAC9B,IAAMgE,SAAS,GAAG,CAAC,IAAI,CAACnF,OAAO,IAC7BK,KAAK,CAACoC,IAAI,IACV,CAAC0B,EAAE,CAAC1B,IAAI,GAAG,IAAM,MAAMpC,KAAK,CAACoC,IAAI;UACnC,IAAA0D,IAAA,GAAahB,SAAS,GAAGM,QAAQ,CAAC,YAAM;cACtC3M,EAAE,CAACsN,SAAS,CAAC/F,KAAK,CAAC0B,QAAQ,EAAE1B,KAAK,CAACoC,IAAI,CAAC;YAC1C,CAAC,CAAC,GAAG,EAAE;YAAA4D,KAAA,GAAAnO,cAAA,CAAAiO,IAAA;YAFAnK,IAAE,GAAAqK,KAAA;UAGT,OAAO,IAAI,CAACvM,MAAM,CAAC,CAACkC,IAAE,EAAEqE,KAAK,CAAC;QAChC;QACA;QACA,IAAAiG,UAAA,GAAab,QAAQ,CAAC;YAAA,OAAM3M,EAAE,CAACyN,SAAS,CAAClG,KAAK,CAAC0B,QAAQ,CAAC;UAAA,EAAC;UAAAyE,UAAA,GAAAtO,cAAA,CAAAoO,UAAA;UAAlDtK,IAAE,GAAAwK,UAAA;QACT,IAAI,CAAC1M,MAAM,CAAC,CAACkC,IAAE,EAAEqE,KAAK,CAAC;MACzB;;MAEA;MACA;MACA,IAAAoG,KAAA,GAAapG,KAAK,CAAC0B,QAAQ,KAAK,IAAI,CAACnC,GAAG,GAAG,EAAE,GACzC6F,QAAQ,CAAC;UAAA,OAAMxJ,cAAc,CAACoE,KAAK,CAAC0B,QAAQ,CAAC;QAAA,EAAC;QAAA2E,KAAA,GAAAxO,cAAA,CAAAuO,KAAA;QAD3CzK,EAAE,GAAA0K,KAAA;MAET,IAAI,CAAC5M,MAAM,CAAC,CAACkC,EAAE,EAAEqE,KAAK,CAAC;IACzB;EAAC;IAAAxC,GAAA,EAEA9D,IAAI;IAAAoD,KAAA,EAAL,SAAAA,MAAQkD,KAAK,EAAEnD,IAAI,EAAE;MAAA,IAAAyJ,MAAA;MACnB,IAAMlE,IAAI,GAAGpC,KAAK,CAACoC,IAAI,GAAG,IAAM,IAAI,IAAI,CAACtC,KAAK;MAE9C,IAAMyG,IAAI,GAAG,SAAPA,IAAIA,CAAG5K,EAAE,EAAI;QACjB,IAAI6K,UAAU;QACd,IAAI;UACF/N,EAAE,CAACgO,SAAS,CAAC3D,EAAE,CAAC;QAClB,CAAC,CAAC,OAAO3F,CAAC,EAAE;UACVqJ,UAAU,GAAGrJ,CAAC;QAChB;QACA,IAAIxB,EAAE,IAAI6K,UAAU,EAAE;UACpBF,MAAI,CAACpM,OAAO,CAAC,CAACyB,EAAE,IAAI6K,UAAU,EAAExG,KAAK,CAAC;QACxC;QACAnD,IAAI,CAAC,CAAC;MACR,CAAC;MAED,IAAIiG,EAAE;MACN,IAAI;QACFA,EAAE,GAAGrK,EAAE,CAACiO,QAAQ,CAAC1G,KAAK,CAAC0B,QAAQ,EAAE5G,OAAO,CAACkF,KAAK,CAAC4C,IAAI,CAAC,EAAER,IAAI,CAAC;MAC7D,CAAC,CAAC,OAAOzG,EAAE,EAAE;QACX,OAAO4K,IAAI,CAAC5K,EAAE,CAAC;MACjB;MACA,IAAM+H,EAAE,GAAG,IAAI,CAACxF,SAAS,GAAG,IAAI,CAACA,SAAS,CAAC8B,KAAK,CAAC,IAAIA,KAAK,GAAGA,KAAK;MAClE,IAAI0D,EAAE,KAAK1D,KAAK,EAAE;QAChB0D,EAAE,CAAC3D,EAAE,CAAC,OAAO,EAAE,UAAApE,EAAE;UAAA,OAAI2K,MAAI,CAACpM,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;QAAA,EAAC;QAC9CA,KAAK,CAAC2D,IAAI,CAACD,EAAE,CAAC;MAChB;MAEAA,EAAE,CAAC3D,EAAE,CAAC,MAAM,EAAE,UAAA4G,KAAK,EAAI;QACrB,IAAI;UACFlO,EAAE,CAACmO,SAAS,CAAC9D,EAAE,EAAE6D,KAAK,EAAE,CAAC,EAAEA,KAAK,CAACrG,MAAM,CAAC;QAC1C,CAAC,CAAC,OAAO3E,EAAE,EAAE;UACX4K,IAAI,CAAC5K,EAAE,CAAC;QACV;MACF,CAAC,CAAC;MAEF+H,EAAE,CAAC3D,EAAE,CAAC,KAAK,EAAE,UAAAhC,CAAC,EAAI;QAChB,IAAIpC,EAAE,GAAG,IAAI;QACb;QACA;QACA,IAAIqE,KAAK,CAACkD,KAAK,IAAI,CAACoD,MAAI,CAACjH,OAAO,EAAE;UAChC,IAAM8D,KAAK,GAAGnD,KAAK,CAACmD,KAAK,IAAI,IAAIC,IAAI,CAAC,CAAC;UACvC,IAAMF,KAAK,GAAGlD,KAAK,CAACkD,KAAK;UACzB,IAAI;YACFzK,EAAE,CAACoO,WAAW,CAAC/D,EAAE,EAAEK,KAAK,EAAED,KAAK,CAAC;UAClC,CAAC,CAAC,OAAO4D,SAAS,EAAE;YAClB,IAAI;cACFrO,EAAE,CAACsO,UAAU,CAAC/G,KAAK,CAAC0B,QAAQ,EAAEyB,KAAK,EAAED,KAAK,CAAC;YAC7C,CAAC,CAAC,OAAO8D,QAAQ,EAAE;cACjBrL,EAAE,GAAGmL,SAAS;YAChB;UACF;QACF;QAEA,IAAIR,MAAI,CAAC7L,OAAO,CAAC,CAACuF,KAAK,CAAC,EAAE;UACxB,IAAMzB,GAAG,GAAG+H,MAAI,CAAC5L,GAAG,CAAC,CAACsF,KAAK,CAAC;UAC5B,IAAMxB,GAAG,GAAG8H,MAAI,CAAC3L,GAAG,CAAC,CAACqF,KAAK,CAAC;UAE5B,IAAI;YACFvH,EAAE,CAACwO,UAAU,CAACnE,EAAE,EAAEvE,GAAG,EAAEC,GAAG,CAAC;UAC7B,CAAC,CAAC,OAAO0I,QAAQ,EAAE;YACjB,IAAI;cACFzO,EAAE,CAAC0O,SAAS,CAACnH,KAAK,CAAC0B,QAAQ,EAAEnD,GAAG,EAAEC,GAAG,CAAC;YACxC,CAAC,CAAC,OAAO4I,OAAO,EAAE;cAChBzL,EAAE,GAAGA,EAAE,IAAIuL,QAAQ;YACrB;UACF;QACF;QAEAX,IAAI,CAAC5K,EAAE,CAAC;MACV,CAAC,CAAC;IACJ;EAAC;IAAA6B,GAAA,EAEA7D,SAAS;IAAAmD,KAAA,EAAV,SAAAA,MAAakD,KAAK,EAAEnD,IAAI,EAAE;MACxB,IAAMuF,IAAI,GAAGpC,KAAK,CAACoC,IAAI,GAAG,IAAM,IAAI,IAAI,CAACvC,KAAK;MAC9C,IAAMlE,EAAE,GAAG,IAAI,CAAC1B,KAAK,CAAC,CAAC+F,KAAK,CAAC0B,QAAQ,EAAEU,IAAI,CAAC;MAC5C,IAAIzG,EAAE,EAAE;QACN,IAAI,CAACzB,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;QACxBnD,IAAI,CAAC,CAAC;QACN;MACF;MACA,IAAImD,KAAK,CAACkD,KAAK,IAAI,CAAC,IAAI,CAAC7D,OAAO,EAAE;QAChC,IAAI;UACF5G,EAAE,CAACsO,UAAU,CAAC/G,KAAK,CAAC0B,QAAQ,EAAE1B,KAAK,CAACmD,KAAK,IAAI,IAAIC,IAAI,CAAC,CAAC,EAAEpD,KAAK,CAACkD,KAAK,CAAC;QACvE,CAAC,CAAC,OAAOvH,EAAE,EAAE,CAAC;MAChB;MACA,IAAI,IAAI,CAAClB,OAAO,CAAC,CAACuF,KAAK,CAAC,EAAE;QACxB,IAAI;UACFvH,EAAE,CAAC0O,SAAS,CAACnH,KAAK,CAAC0B,QAAQ,EAAE,IAAI,CAAChH,GAAG,CAAC,CAACsF,KAAK,CAAC,EAAE,IAAI,CAACrF,GAAG,CAAC,CAACqF,KAAK,CAAC,CAAC;QAClE,CAAC,CAAC,OAAOrE,EAAE,EAAE,CAAC;MAChB;MACAkB,IAAI,CAAC,CAAC;MACNmD,KAAK,CAACkC,MAAM,CAAC,CAAC;IAChB;EAAC;IAAA1E,GAAA,EAEAvD,KAAK;IAAA6C,KAAA,EAAN,SAAAA,MAASuF,GAAG,EAAED,IAAI,EAAE;MAClB,IAAI;QACF,OAAOxJ,KAAK,CAACyO,IAAI,CAACrO,QAAQ,CAACqJ,GAAG,CAAC,EAAE;UAC/B9D,GAAG,EAAE,IAAI,CAACA,GAAG;UACbC,GAAG,EAAE,IAAI,CAACA,GAAG;UACbM,UAAU,EAAE,IAAI,CAACA,UAAU;UAC3BC,UAAU,EAAE,IAAI,CAACA,UAAU;UAC3Ba,KAAK,EAAE,IAAI,CAACF,YAAY;UACxB4C,QAAQ,EAAE,IAAI,CAAChD,aAAa;UAC5BhE,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBgB,KAAK,EAAE,IAAI,CAAC+B,QAAQ;UACpBkB,GAAG,EAAE,IAAI,CAACA,GAAG;UACb6C,IAAI,EAAEA;QACR,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOzG,EAAE,EAAE;QACX,OAAOA,EAAE;MACX;IACF;EAAC;IAAA6B,GAAA,EAEA5D,IAAI;IAAAkD,KAAA,EAAL,SAAAA,MAAQkD,KAAK,EAAEgB,QAAQ,EAAEkE,IAAI,EAAErI,IAAI,EAAE;MACnC,IAAI;QACFpE,EAAE,CAACyM,IAAI,GAAG,MAAM,CAAC,CAAClE,QAAQ,EAAEhB,KAAK,CAAC0B,QAAQ,CAAC;QAC3C7E,IAAI,CAAC,CAAC;QACNmD,KAAK,CAACkC,MAAM,CAAC,CAAC;MAChB,CAAC,CAAC,OAAOvG,EAAE,EAAE;QACX,OAAO,IAAI,CAACzB,OAAO,CAAC,CAACyB,EAAE,EAAEqE,KAAK,CAAC;MACjC;IACF;EAAC;EAAA,OAAAsF,UAAA;AAAA,EArLsB7H,MAAM;AAwL/BA,MAAM,CAAC6J,IAAI,GAAGhC,UAAU;AACxBiC,MAAM,CAACC,OAAO,GAAG/J,MAAM"},"metadata":{},"sourceType":"script"}