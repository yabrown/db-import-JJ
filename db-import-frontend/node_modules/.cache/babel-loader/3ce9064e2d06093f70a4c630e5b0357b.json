{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport debug from \"./debug\";\nvar registeredLoggers = new Set();\nvar logLevelFromEnv = typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL || undefined;\nvar azureLogLevel;\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport var AzureLogger = debug(\"azure\");\nAzureLogger.log = function () {\n  debug.log.apply(debug, arguments);\n};\nvar AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\nif (logLevelFromEnv) {\n  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n  if (isAzureLogLevel(logLevelFromEnv)) {\n    setLogLevel(logLevelFromEnv);\n  } else {\n    console.error(\"AZURE_LOG_LEVEL set to unknown log level '\".concat(logLevelFromEnv, \"'; logging is not enabled. Acceptable values: \").concat(AZURE_LOG_LEVELS.join(\", \"), \".\"));\n  }\n}\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level) {\n  if (level && !isAzureLogLevel(level)) {\n    throw new Error(\"Unknown log level '\".concat(level, \"'. Acceptable values: \").concat(AZURE_LOG_LEVELS.join(\",\")));\n  }\n  azureLogLevel = level;\n  var enabledNamespaces = [];\n  var _iterator = _createForOfIteratorHelper(registeredLoggers),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var logger = _step.value;\n      if (shouldEnable(logger)) {\n        enabledNamespaces.push(logger.namespace);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  debug.enable(enabledNamespaces.join(\",\"));\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n  return azureLogLevel;\n}\nvar levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100\n};\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace) {\n  var clientRootLogger = AzureLogger.extend(namespace);\n  patchLogMethod(AzureLogger, clientRootLogger);\n  return {\n    error: createLogger(clientRootLogger, \"error\"),\n    warning: createLogger(clientRootLogger, \"warning\"),\n    info: createLogger(clientRootLogger, \"info\"),\n    verbose: createLogger(clientRootLogger, \"verbose\")\n  };\n}\nfunction patchLogMethod(parent, child) {\n  child.log = function () {\n    parent.log.apply(parent, arguments);\n  };\n}\nfunction createLogger(parent, level) {\n  var logger = Object.assign(parent.extend(level), {\n    level: level\n  });\n  patchLogMethod(parent, logger);\n  if (shouldEnable(logger)) {\n    var enabledNamespaces = debug.disable();\n    debug.enable(enabledNamespaces + \",\" + logger.namespace);\n  }\n  registeredLoggers.add(logger);\n  return logger;\n}\nfunction shouldEnable(logger) {\n  return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);\n}\nfunction isAzureLogLevel(logLevel) {\n  return AZURE_LOG_LEVELS.includes(logLevel);\n}","map":{"version":3,"names":["debug","registeredLoggers","Set","logLevelFromEnv","process","env","AZURE_LOG_LEVEL","undefined","azureLogLevel","AzureLogger","log","apply","arguments","AZURE_LOG_LEVELS","isAzureLogLevel","setLogLevel","console","error","concat","join","level","Error","enabledNamespaces","_iterator","_createForOfIteratorHelper","_step","s","n","done","logger","value","shouldEnable","push","namespace","err","e","f","enable","getLogLevel","levelMap","verbose","info","warning","createClientLogger","clientRootLogger","extend","patchLogMethod","createLogger","parent","child","Object","assign","disable","add","Boolean","logLevel","includes"],"sources":["../../src/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport debug, { Debugger } from \"./debug\";\nexport { Debugger } from \"./debug\";\n\nconst registeredLoggers = new Set<AzureDebugger>();\nconst logLevelFromEnv =\n  (typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;\n\nlet azureLogLevel: AzureLogLevel | undefined;\n\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport const AzureLogger: AzureClientLogger = debug(\"azure\");\nAzureLogger.log = (...args) => {\n  debug.log(...args);\n};\n\n/**\n * The log levels supported by the logger.\n * The log levels in order of most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport type AzureLogLevel = \"verbose\" | \"info\" | \"warning\" | \"error\";\nconst AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\n\ntype AzureDebugger = Debugger & { level: AzureLogLevel };\n\n/**\n * An AzureClientLogger is a function that can log to an appropriate severity level.\n */\nexport type AzureClientLogger = Debugger;\n\nif (logLevelFromEnv) {\n  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n  if (isAzureLogLevel(logLevelFromEnv)) {\n    setLogLevel(logLevelFromEnv);\n  } else {\n    console.error(\n      `AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(\n        \", \"\n      )}.`\n    );\n  }\n}\n\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level?: AzureLogLevel): void {\n  if (level && !isAzureLogLevel(level)) {\n    throw new Error(\n      `Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(\",\")}`\n    );\n  }\n  azureLogLevel = level;\n\n  const enabledNamespaces = [];\n  for (const logger of registeredLoggers) {\n    if (shouldEnable(logger)) {\n      enabledNamespaces.push(logger.namespace);\n    }\n  }\n\n  debug.enable(enabledNamespaces.join(\",\"));\n}\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel(): AzureLogLevel | undefined {\n  return azureLogLevel;\n}\n\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100,\n};\n\n/**\n * Defines the methods available on the SDK-facing logger.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface AzureLogger {\n  /**\n   * Used for failures the program is unlikely to recover from,\n   * such as Out of Memory.\n   */\n  error: Debugger;\n  /**\n   * Used when a function fails to perform its intended task.\n   * Usually this means the function will throw an exception.\n   * Not used for self-healing events (e.g. automatic retry)\n   */\n  warning: Debugger;\n  /**\n   * Used when a function operates normally.\n   */\n  info: Debugger;\n  /**\n   * Used for detailed troubleshooting scenarios. This is\n   * intended for use by developers / system administrators\n   * for diagnosing specific failures.\n   */\n  verbose: Debugger;\n}\n\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace: string): AzureLogger {\n  const clientRootLogger: AzureClientLogger = AzureLogger.extend(namespace);\n  patchLogMethod(AzureLogger, clientRootLogger);\n  return {\n    error: createLogger(clientRootLogger, \"error\"),\n    warning: createLogger(clientRootLogger, \"warning\"),\n    info: createLogger(clientRootLogger, \"info\"),\n    verbose: createLogger(clientRootLogger, \"verbose\"),\n  };\n}\n\nfunction patchLogMethod(parent: AzureClientLogger, child: AzureClientLogger | AzureDebugger): void {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\n\nfunction createLogger(parent: AzureClientLogger, level: AzureLogLevel): AzureDebugger {\n  const logger: AzureDebugger = Object.assign(parent.extend(level), {\n    level,\n  });\n\n  patchLogMethod(parent, logger);\n\n  if (shouldEnable(logger)) {\n    const enabledNamespaces = debug.disable();\n    debug.enable(enabledNamespaces + \",\" + logger.namespace);\n  }\n\n  registeredLoggers.add(logger);\n\n  return logger;\n}\n\nfunction shouldEnable(logger: AzureDebugger): boolean {\n  return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);\n}\n\nfunction isAzureLogLevel(logLevel: string): logLevel is AzureLogLevel {\n  return AZURE_LOG_LEVELS.includes(logLevel as any);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}