{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _asyncIterator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _nativeDuplexpair = _interopRequireDefault(require(\"native-duplexpair\"));\nvar tls = _interopRequireWildcard(require(\"tls\"));\nvar _events = require(\"events\");\nvar _message = _interopRequireDefault(require(\"./message\"));\nvar _packet = require(\"./packet\");\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar MessageIO = /*#__PURE__*/function (_events$EventEmitter) {\n  _inherits(MessageIO, _events$EventEmitter);\n  var _super = _createSuper(MessageIO);\n  function MessageIO(socket, packetSize, debug) {\n    var _this;\n    _classCallCheck(this, MessageIO);\n    _this = _super.call(this);\n    _this.socket = void 0;\n    _this.debug = void 0;\n    _this.tlsNegotiationComplete = void 0;\n    _this.incomingMessageStream = void 0;\n    _this.outgoingMessageStream = void 0;\n    _this.securePair = void 0;\n    _this.incomingMessageIterator = void 0;\n    _this.socket = socket;\n    _this.debug = debug;\n    _this.tlsNegotiationComplete = false;\n    _this.incomingMessageStream = new _incomingMessageStream.default(_this.debug);\n    _this.incomingMessageIterator = _this.incomingMessageStream[Symbol.asyncIterator]();\n    _this.outgoingMessageStream = new _outgoingMessageStream.default(_this.debug, {\n      packetSize: packetSize\n    });\n    _this.socket.pipe(_this.incomingMessageStream);\n    _this.outgoingMessageStream.pipe(_this.socket);\n    return _this;\n  }\n  _createClass(MessageIO, [{\n    key: \"packetSize\",\n    value: function packetSize() {\n      if (arguments.length > 0) {\n        var packetSize = arguments.length <= 0 ? undefined : arguments[0];\n        this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n        this.outgoingMessageStream.packetSize = packetSize;\n      }\n      if (this.securePair) {\n        this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n      }\n      return this.outgoingMessageStream.packetSize;\n    } // Negotiate TLS encryption.\n  }, {\n    key: \"startTls\",\n    value: function startTls(credentialsDetails, hostname, trustServerCertificate) {\n      var _this2 = this;\n      if (!credentialsDetails.maxVersion || !['TLSv1.2', 'TLSv1.1', 'TLSv1'].includes(credentialsDetails.maxVersion)) {\n        credentialsDetails.maxVersion = 'TLSv1.2';\n      }\n      var secureContext = tls.createSecureContext(credentialsDetails);\n      return new Promise(function (resolve, reject) {\n        var duplexpair = new _nativeDuplexpair.default();\n        var securePair = _this2.securePair = {\n          cleartext: tls.connect({\n            socket: duplexpair.socket1,\n            servername: hostname,\n            secureContext: secureContext,\n            rejectUnauthorized: !trustServerCertificate\n          }),\n          encrypted: duplexpair.socket2\n        };\n        var onSecureConnect = function onSecureConnect() {\n          securePair.encrypted.removeListener('readable', onReadable);\n          securePair.cleartext.removeListener('error', onError);\n          securePair.cleartext.removeListener('secureConnect', onSecureConnect); // If we encounter any errors from this point on,\n          // we just forward them to the actual network socket.\n\n          securePair.cleartext.once('error', function (err) {\n            _this2.socket.destroy(err);\n          });\n          var cipher = securePair.cleartext.getCipher();\n          if (cipher) {\n            _this2.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n          }\n          _this2.emit('secure', securePair.cleartext);\n          securePair.cleartext.setMaxSendFragment(_this2.outgoingMessageStream.packetSize);\n          _this2.outgoingMessageStream.unpipe(_this2.socket);\n          _this2.socket.unpipe(_this2.incomingMessageStream);\n          _this2.socket.pipe(securePair.encrypted);\n          securePair.encrypted.pipe(_this2.socket);\n          securePair.cleartext.pipe(_this2.incomingMessageStream);\n          _this2.outgoingMessageStream.pipe(securePair.cleartext);\n          _this2.tlsNegotiationComplete = true;\n          resolve();\n        };\n        var onError = function onError(err) {\n          securePair.encrypted.removeListener('readable', onReadable);\n          securePair.cleartext.removeListener('error', onError);\n          securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n          securePair.cleartext.destroy();\n          securePair.encrypted.destroy();\n          reject(err);\n        };\n        var onReadable = function onReadable() {\n          // When there is handshake data on the encryped stream of the secure pair,\n          // we wrap it into a `PRELOGIN` message and send it to the server.\n          //\n          // For each `PRELOGIN` message we sent we get back exactly one response message\n          // that contains the server's handshake response data.\n          var message = new _message.default({\n            type: _packet.TYPE.PRELOGIN,\n            resetConnection: false\n          });\n          var chunk;\n          while (chunk = securePair.encrypted.read()) {\n            message.write(chunk);\n          }\n          _this2.outgoingMessageStream.write(message);\n          message.end();\n          _this2.readMessage().then( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(response) {\n              var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, data;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    // Setup readable handler for the next round of handshaking.\n                    // If we encounter a `secureConnect` on the cleartext side\n                    // of the secure pair, the `readable` handler is cleared\n                    // and no further handshake handling will happen.\n                    securePair.encrypted.once('readable', onReadable);\n                    _iteratorAbruptCompletion = false;\n                    _didIteratorError = false;\n                    _context.prev = 3;\n                    _iterator = _asyncIterator(response);\n                  case 5:\n                    _context.next = 7;\n                    return _iterator.next();\n                  case 7:\n                    if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                      _context.next = 13;\n                      break;\n                    }\n                    data = _step.value;\n                    // We feed the server's handshake response back into the\n                    // encrypted end of the secure pair.\n                    securePair.encrypted.write(data);\n                  case 10:\n                    _iteratorAbruptCompletion = false;\n                    _context.next = 5;\n                    break;\n                  case 13:\n                    _context.next = 19;\n                    break;\n                  case 15:\n                    _context.prev = 15;\n                    _context.t0 = _context[\"catch\"](3);\n                    _didIteratorError = true;\n                    _iteratorError = _context.t0;\n                  case 19:\n                    _context.prev = 19;\n                    _context.prev = 20;\n                    if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                      _context.next = 24;\n                      break;\n                    }\n                    _context.next = 24;\n                    return _iterator.return();\n                  case 24:\n                    _context.prev = 24;\n                    if (!_didIteratorError) {\n                      _context.next = 27;\n                      break;\n                    }\n                    throw _iteratorError;\n                  case 27:\n                    return _context.finish(24);\n                  case 28:\n                    return _context.finish(19);\n                  case 29:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, null, [[3, 15, 19, 29], [20,, 24, 28]]);\n            }));\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }()).catch(onError);\n        };\n        securePair.cleartext.once('error', onError);\n        securePair.cleartext.once('secureConnect', onSecureConnect);\n        securePair.encrypted.once('readable', onReadable);\n      });\n    } // TODO listen for 'drain' event when socket.write returns false.\n    // TODO implement incomplete request cancelation (2.2.1.6)\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(packetType, data, resetConnection) {\n      var message = new _message.default({\n        type: packetType,\n        resetConnection: resetConnection\n      });\n      message.end(data);\n      this.outgoingMessageStream.write(message);\n      return message;\n    }\n    /**\n     * Read the next incoming message from the socket.\n     */\n  }, {\n    key: \"readMessage\",\n    value: function () {\n      var _readMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.incomingMessageIterator.next();\n            case 2:\n              result = _context2.sent;\n              if (!result.done) {\n                _context2.next = 5;\n                break;\n              }\n              throw new Error('unexpected end of message stream');\n            case 5:\n              return _context2.abrupt(\"return\", result.value);\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function readMessage() {\n        return _readMessage.apply(this, arguments);\n      }\n      return readMessage;\n    }()\n  }]);\n  return MessageIO;\n}(_events.EventEmitter);\nvar _default = MessageIO;\nexports.default = _default;\nmodule.exports = MessageIO;","map":{"version":3,"names":["_nativeDuplexpair","_interopRequireDefault","require","tls","_interopRequireWildcard","_events","_message","_packet","_incomingMessageStream","_outgoingMessageStream","MessageIO","_events$EventEmitter","_inherits","_super","_createSuper","socket","packetSize","debug","_this","_classCallCheck","call","tlsNegotiationComplete","incomingMessageStream","outgoingMessageStream","securePair","incomingMessageIterator","default","Symbol","asyncIterator","pipe","_createClass","key","value","arguments","length","undefined","log","cleartext","setMaxSendFragment","startTls","credentialsDetails","hostname","trustServerCertificate","_this2","maxVersion","includes","secureContext","createSecureContext","Promise","resolve","reject","duplexpair","connect","socket1","servername","rejectUnauthorized","encrypted","socket2","onSecureConnect","removeListener","onReadable","onError","once","err","destroy","cipher","getCipher","name","version","emit","unpipe","message","type","TYPE","PRELOGIN","resetConnection","chunk","read","write","end","readMessage","then","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","response","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","data","wrap","_callee$","_context","prev","next","_asyncIterator","sent","done","t0","return","finish","stop","_x","apply","catch","sendMessage","packetType","_readMessage","_callee2","result","_callee2$","_context2","Error","abrupt","EventEmitter","module","exports"],"sources":["../src/message-io.ts"],"sourcesContent":["import DuplexPair from 'native-duplexpair';\n\nimport { Duplex } from 'stream';\nimport * as tls from 'tls';\nimport { Socket } from 'net';\nimport { EventEmitter } from 'events';\n\nimport Debug from './debug';\n\nimport Message from './message';\nimport { TYPE } from './packet';\n\nimport IncomingMessageStream from './incoming-message-stream';\nimport OutgoingMessageStream from './outgoing-message-stream';\n\nclass MessageIO extends EventEmitter {\n  socket: Socket;\n  debug: Debug;\n\n  tlsNegotiationComplete: boolean;\n\n  private incomingMessageStream: IncomingMessageStream;\n  outgoingMessageStream: OutgoingMessageStream;\n\n  securePair?: {\n    cleartext: tls.TLSSocket;\n    encrypted: Duplex;\n  }\n\n  incomingMessageIterator: AsyncIterableIterator<Message>;\n\n  constructor(socket: Socket, packetSize: number, debug: Debug) {\n    super();\n\n    this.socket = socket;\n    this.debug = debug;\n\n    this.tlsNegotiationComplete = false;\n\n    this.incomingMessageStream = new IncomingMessageStream(this.debug);\n    this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();\n\n    this.outgoingMessageStream = new OutgoingMessageStream(this.debug, { packetSize: packetSize });\n\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n\n  packetSize(...args: [number]) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n\n    return this.outgoingMessageStream.packetSize;\n  }\n\n  // Negotiate TLS encryption.\n  startTls(credentialsDetails: tls.SecureContextOptions, hostname: string, trustServerCertificate: boolean) {\n    if (!credentialsDetails.maxVersion || !['TLSv1.2', 'TLSv1.1', 'TLSv1'].includes(credentialsDetails.maxVersion)) {\n      credentialsDetails.maxVersion = 'TLSv1.2';\n    }\n\n    const secureContext = tls.createSecureContext(credentialsDetails);\n\n    return new Promise<void>((resolve, reject) => {\n      const duplexpair = new DuplexPair();\n      const securePair = this.securePair = {\n        cleartext: tls.connect({\n          socket: duplexpair.socket1 as Socket,\n          servername: hostname,\n          secureContext: secureContext,\n          rejectUnauthorized: !trustServerCertificate\n        }),\n        encrypted: duplexpair.socket2\n      };\n\n      const onSecureConnect = () => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n\n        // If we encounter any errors from this point on,\n        // we just forward them to the actual network socket.\n        securePair.cleartext.once('error', (err) => {\n          this.socket.destroy(err);\n        });\n\n        const cipher = securePair.cleartext.getCipher();\n        if (cipher) {\n          this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n        }\n\n        this.emit('secure', securePair.cleartext);\n\n        securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n\n        this.outgoingMessageStream.unpipe(this.socket);\n        this.socket.unpipe(this.incomingMessageStream);\n\n        this.socket.pipe(securePair.encrypted);\n        securePair.encrypted.pipe(this.socket);\n\n        securePair.cleartext.pipe(this.incomingMessageStream);\n        this.outgoingMessageStream.pipe(securePair.cleartext);\n\n        this.tlsNegotiationComplete = true;\n\n        resolve();\n      };\n\n      const onError = (err?: Error) => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n\n        securePair.cleartext.destroy();\n        securePair.encrypted.destroy();\n\n        reject(err);\n      };\n\n      const onReadable = () => {\n        // When there is handshake data on the encryped stream of the secure pair,\n        // we wrap it into a `PRELOGIN` message and send it to the server.\n        //\n        // For each `PRELOGIN` message we sent we get back exactly one response message\n        // that contains the server's handshake response data.\n        const message = new Message({ type: TYPE.PRELOGIN, resetConnection: false });\n\n        let chunk;\n        while (chunk = securePair.encrypted.read()) {\n          message.write(chunk);\n        }\n        this.outgoingMessageStream.write(message);\n        message.end();\n\n        this.readMessage().then(async (response) => {\n          // Setup readable handler for the next round of handshaking.\n          // If we encounter a `secureConnect` on the cleartext side\n          // of the secure pair, the `readable` handler is cleared\n          // and no further handshake handling will happen.\n          securePair.encrypted.once('readable', onReadable);\n\n          for await (const data of response) {\n            // We feed the server's handshake response back into the\n            // encrypted end of the secure pair.\n            securePair.encrypted.write(data);\n          }\n        }).catch(onError);\n      };\n\n      securePair.cleartext.once('error', onError);\n      securePair.cleartext.once('secureConnect', onSecureConnect);\n      securePair.encrypted.once('readable', onReadable);\n    });\n  }\n\n  // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n  sendMessage(packetType: number, data?: Buffer, resetConnection?: boolean) {\n    const message = new Message({ type: packetType, resetConnection: resetConnection });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  }\n\n  /**\n   * Read the next incoming message from the socket.\n   */\n  async readMessage(): Promise<Message> {\n    const result = await this.incomingMessageIterator.next();\n\n    if (result.done) {\n      throw new Error('unexpected end of message stream');\n    }\n\n    return result.value;\n  }\n}\n\nexport default MessageIO;\nmodule.exports = MessageIO;\n"],"mappings":";;;;;;;;;;;;;AAAA,IAAAA,iBAAA,GAAAC,sBAAA,CAAAC,OAAA;AAGA,IAAAC,GAAA,GAAAC,uBAAA,CAAAF,OAAA;AAEA,IAAAG,OAAA,GAAAH,OAAA;AAIA,IAAAI,QAAA,GAAAL,sBAAA,CAAAC,OAAA;AACA,IAAAK,OAAA,GAAAL,OAAA;AAEA,IAAAM,sBAAA,GAAAP,sBAAA,CAAAC,OAAA;AACA,IAAAO,sBAAA,GAAAR,sBAAA,CAAAC,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAEMQ,SAAN,0BAAAC,oBAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,oBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EAgBE,SAAAA,UAAYK,MAAD,EAAiBC,UAAjB,EAAqCC,KAArC,EAAmD;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAT,SAAA;IAC5DQ,KAAA,GAAAL,MAAA,CAAAO,IAAA;IAD4DF,KAAA,CAf9DH,MAe8D;IAAAG,KAAA,CAd9DD,KAc8D;IAAAC,KAAA,CAZ9DG,sBAY8D;IAAAH,KAAA,CAVtDI,qBAUsD;IAAAJ,KAAA,CAT9DK,qBAS8D;IAAAL,KAAA,CAP9DM,UAO8D;IAAAN,KAAA,CAF9DO,uBAE8D;IAG5DP,KAAA,CAAKH,MAAL,GAAcA,MAAd;IACAG,KAAA,CAAKD,KAAL,GAAaA,KAAb;IAEAC,KAAA,CAAKG,sBAAL,GAA8B,KAA9B;IAEAH,KAAA,CAAKI,qBAAL,GAA6B,IAAId,sBAAA,CAAAkB,OAAJ,CAA0BR,KAAA,CAAKD,KAA/B,CAA7B;IACAC,KAAA,CAAKO,uBAAL,GAA+BP,KAAA,CAAKI,qBAAL,CAA2BK,MAAM,CAACC,aAAlC,GAA/B;IAEAV,KAAA,CAAKK,qBAAL,GAA6B,IAAId,sBAAA,CAAAiB,OAAJ,CAA0BR,KAAA,CAAKD,KAA/B,EAAsC;MAAED,UAAU,EAAEA;IAAd,CAAtC,CAA7B;IAEAE,KAAA,CAAKH,MAAL,CAAYc,IAAZ,CAAiBX,KAAA,CAAKI,qBAAtB;IACAJ,KAAA,CAAKK,qBAAL,CAA2BM,IAA3B,CAAgCX,KAAA,CAAKH,MAArC;IAAA,OAAAG,KAAA;EACD;EAAAY,YAAA,CAAApB,SAAA;IAAAqB,GAAA;IAAAC,KAAA,EAED,SAAAhB,WAAA,EAA8B;MAC5B,IAAIiB,SAAA,CAAKC,MAAL,GAAc,CAAlB,EAAqB;QACnB,IAAMlB,UAAU,GAAAiB,SAAA,CAAAC,MAAA,QAAAC,SAAA,GAAAF,SAAA,GAAhB;QACA,KAAKhB,KAAL,CAAWmB,GAAX,CAAe,8BAA8B,KAAKb,qBAAL,CAA2BP,UAAzD,GAAsE,MAAtE,GAA+EA,UAA9F;QACA,KAAKO,qBAAL,CAA2BP,UAA3B,GAAwCA,UAAxC;MACD;MAED,IAAI,KAAKQ,UAAT,EAAqB;QACnB,KAAKA,UAAL,CAAgBa,SAAhB,CAA0BC,kBAA1B,CAA6C,KAAKf,qBAAL,CAA2BP,UAAxE;MACD;MAED,OAAO,KAAKO,qBAAL,CAA2BP,UAAlC;IACD,CA7CkC,CA+CnC;EAAA;IAAAe,GAAA;IAAAC,KAAA,EACA,SAAAO,SAASC,kBAAD,EAA+CC,QAA/C,EAAiEC,sBAAjE,EAAkG;MAAA,IAAAC,MAAA;MACxG,IAAI,CAACH,kBAAkB,CAACI,UAApB,IAAkC,CAAC,CAAC,SAAD,EAAY,SAAZ,EAAuB,OAAvB,EAAgCC,QAAhC,CAAyCL,kBAAkB,CAACI,UAA5D,CAAvC,EAAgH;QAC9GJ,kBAAkB,CAACI,UAAnB,GAAgC,SAAhC;MACD;MAED,IAAME,aAAa,GAAG3C,GAAG,CAAC4C,mBAAJ,CAAwBP,kBAAxB,CAAtB;MAEA,OAAO,IAAIQ,OAAJ,CAAkB,UAACC,OAAD,EAAUC,MAAV,EAAqB;QAC5C,IAAMC,UAAU,GAAG,IAAInD,iBAAA,CAAA0B,OAAJ,EAAnB;QACA,IAAMF,UAAU,GAAGmB,MAAA,CAAKnB,UAAL,GAAkB;UACnCa,SAAS,EAAElC,GAAG,CAACiD,OAAJ,CAAY;YACrBrC,MAAM,EAAEoC,UAAU,CAACE,OADE;YAErBC,UAAU,EAAEb,QAFS;YAGrBK,aAAa,EAAEA,aAHM;YAIrBS,kBAAkB,EAAE,CAACb;UAJA,CAAZ,CADwB;UAOnCc,SAAS,EAAEL,UAAU,CAACM;QAPa,CAArC;QAUA,IAAMC,eAAe,GAAG,SAAlBA,eAAeA,CAAA,EAAS;UAC5BlC,UAAU,CAACgC,SAAX,CAAqBG,cAArB,CAAoC,UAApC,EAAgDC,UAAhD;UACApC,UAAU,CAACa,SAAX,CAAqBsB,cAArB,CAAoC,OAApC,EAA6CE,OAA7C;UACArC,UAAU,CAACa,SAAX,CAAqBsB,cAArB,CAAoC,eAApC,EAAqDD,eAArD,EAH4B,CAK5B;UACA;;UACAlC,UAAU,CAACa,SAAX,CAAqByB,IAArB,CAA0B,OAA1B,EAAoC,UAAAC,GAAD,EAAS;YAC1CpB,MAAA,CAAK5B,MAAL,CAAYiD,OAAZ,CAAoBD,GAApB;UACD,CAFD;UAIA,IAAME,MAAM,GAAGzC,UAAU,CAACa,SAAX,CAAqB6B,SAArB,EAAf;UACA,IAAID,MAAJ,EAAY;YACVtB,MAAA,CAAK1B,KAAL,CAAWmB,GAAX,CAAe,qBAAqB6B,MAAM,CAACE,IAA5B,GAAmC,IAAnC,GAA0CF,MAAM,CAACG,OAAjD,GAA2D,GAA1E;UACD;UAEDzB,MAAA,CAAK0B,IAAL,CAAU,QAAV,EAAoB7C,UAAU,CAACa,SAA/B;UAEAb,UAAU,CAACa,SAAX,CAAqBC,kBAArB,CAAwCK,MAAA,CAAKpB,qBAAL,CAA2BP,UAAnE;UAEA2B,MAAA,CAAKpB,qBAAL,CAA2B+C,MAA3B,CAAkC3B,MAAA,CAAK5B,MAAvC;UACA4B,MAAA,CAAK5B,MAAL,CAAYuD,MAAZ,CAAmB3B,MAAA,CAAKrB,qBAAxB;UAEAqB,MAAA,CAAK5B,MAAL,CAAYc,IAAZ,CAAiBL,UAAU,CAACgC,SAA5B;UACAhC,UAAU,CAACgC,SAAX,CAAqB3B,IAArB,CAA0Bc,MAAA,CAAK5B,MAA/B;UAEAS,UAAU,CAACa,SAAX,CAAqBR,IAArB,CAA0Bc,MAAA,CAAKrB,qBAA/B;UACAqB,MAAA,CAAKpB,qBAAL,CAA2BM,IAA3B,CAAgCL,UAAU,CAACa,SAA3C;UAEAM,MAAA,CAAKtB,sBAAL,GAA8B,IAA9B;UAEA4B,OAAO;QACR,CAhCD;QAkCA,IAAMY,OAAO,GAAI,SAAXA,OAAOA,CAAIE,GAAD,EAAiB;UAC/BvC,UAAU,CAACgC,SAAX,CAAqBG,cAArB,CAAoC,UAApC,EAAgDC,UAAhD;UACApC,UAAU,CAACa,SAAX,CAAqBsB,cAArB,CAAoC,OAApC,EAA6CE,OAA7C;UACArC,UAAU,CAACa,SAAX,CAAqBsB,cAArB,CAAoC,eAApC,EAAqDD,eAArD;UAEAlC,UAAU,CAACa,SAAX,CAAqB2B,OAArB;UACAxC,UAAU,CAACgC,SAAX,CAAqBQ,OAArB;UAEAd,MAAM,CAACa,GAAD,CAAN;QACD,CATD;QAWA,IAAMH,UAAU,GAAG,SAAbA,UAAUA,CAAA,EAAS;UACvB;UACA;UACA;UACA;UACA;UACA,IAAMW,OAAO,GAAG,IAAIjE,QAAA,CAAAoB,OAAJ,CAAY;YAAE8C,IAAI,EAAEjE,OAAA,CAAAkE,IAAA,CAAKC,QAAb;YAAuBC,eAAe,EAAE;UAAxC,CAAZ,CAAhB;UAEA,IAAIC,KAAJ;UACA,OAAOA,KAAK,GAAGpD,UAAU,CAACgC,SAAX,CAAqBqB,IAArB,EAAf,EAA4C;YAC1CN,OAAO,CAACO,KAAR,CAAcF,KAAd;UACD;UACDjC,MAAA,CAAKpB,qBAAL,CAA2BuD,KAA3B,CAAiCP,OAAjC;UACAA,OAAO,CAACQ,GAAR;UAEApC,MAAA,CAAKqC,WAAL,GAAmBC,IAAnB;YAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAwB,SAAAC,QAAOC,QAAP;cAAA,IAAAC,yBAAA,EAAAC,iBAAA,EAAAC,cAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAC,IAAA;cAAA,OAAAT,mBAAA,GAAAU,IAAA,UAAAC,SAAAC,QAAA;gBAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;kBAAA;oBACtB;oBACA;oBACA;oBACA;oBACA1E,UAAU,CAACgC,SAAX,CAAqBM,IAArB,CAA0B,UAA1B,EAAsCF,UAAtC;oBAAA4B,yBAAA;oBAAAC,iBAAA;oBAAAO,QAAA,CAAAC,IAAA;oBAAAN,SAAA,GAAAQ,cAAA,CAEyBZ,QAAzB;kBAAA;oBAAAS,QAAA,CAAAE,IAAA;oBAAA,OAAAP,SAAA,CAAAO,IAAA;kBAAA;oBAAA,MAAAV,yBAAA,KAAAI,KAAA,GAAAI,QAAA,CAAAI,IAAA,EAAAC,IAAA;sBAAAL,QAAA,CAAAE,IAAA;sBAAA;oBAAA;oBAAiBL,IAAjB,GAAAD,KAAA,CAAA5D,KAAA;oBACE;oBACA;oBACAR,UAAU,CAACgC,SAAX,CAAqBsB,KAArB,CAA2Be,IAA3B;kBAAA;oBAAAL,yBAAA;oBAAAQ,QAAA,CAAAE,IAAA;oBAAA;kBAAA;oBAAAF,QAAA,CAAAE,IAAA;oBAAA;kBAAA;oBAAAF,QAAA,CAAAC,IAAA;oBAAAD,QAAA,CAAAM,EAAA,GAAAN,QAAA;oBAAAP,iBAAA;oBAAAC,cAAA,GAAAM,QAAA,CAAAM,EAAA;kBAAA;oBAAAN,QAAA,CAAAC,IAAA;oBAAAD,QAAA,CAAAC,IAAA;oBAAA,MAAAT,yBAAA,IAAAG,SAAA,CAAAY,MAAA;sBAAAP,QAAA,CAAAE,IAAA;sBAAA;oBAAA;oBAAAF,QAAA,CAAAE,IAAA;oBAAA,OAAAP,SAAA,CAAAY,MAAA;kBAAA;oBAAAP,QAAA,CAAAC,IAAA;oBAAA,KAAAR,iBAAA;sBAAAO,QAAA,CAAAE,IAAA;sBAAA;oBAAA;oBAAA,MAAAR,cAAA;kBAAA;oBAAA,OAAAM,QAAA,CAAAQ,MAAA;kBAAA;oBAAA,OAAAR,QAAA,CAAAQ,MAAA;kBAAA;kBAAA;oBAAA,OAAAR,QAAA,CAAAS,IAAA;gBAAA;cAAA,GAAAnB,OAAA;YAAA,CAVJ;YAAA,iBAAAoB,EAAA;cAAA,OAAAxB,IAAA,CAAAyB,KAAA,OAAA1E,SAAA;YAAA;UAAA,KAYG2E,KAZH,CAYS/C,OAZT;QAaD,CA5BD;QA8BArC,UAAU,CAACa,SAAX,CAAqByB,IAArB,CAA0B,OAA1B,EAAmCD,OAAnC;QACArC,UAAU,CAACa,SAAX,CAAqByB,IAArB,CAA0B,eAA1B,EAA2CJ,eAA3C;QACAlC,UAAU,CAACgC,SAAX,CAAqBM,IAArB,CAA0B,UAA1B,EAAsCF,UAAtC;MACD,CA1FM,CAAP;IA2FD,CAlJkC,CAoJnC;IACA;EAAA;IAAA7B,GAAA;IAAAC,KAAA,EACA,SAAA6E,YAAYC,UAAD,EAAqBjB,IAArB,EAAoClB,eAApC,EAA+D;MACxE,IAAMJ,OAAO,GAAG,IAAIjE,QAAA,CAAAoB,OAAJ,CAAY;QAAE8C,IAAI,EAAEsC,UAAR;QAAoBnC,eAAe,EAAEA;MAArC,CAAZ,CAAhB;MACAJ,OAAO,CAACQ,GAAR,CAAYc,IAAZ;MACA,KAAKtE,qBAAL,CAA2BuD,KAA3B,CAAiCP,OAAjC;MACA,OAAOA,OAAP;IACD;IAED;AACF;AACA;EAFE;IAAAxC,GAAA;IAAAC,KAAA;MAAA,IAAA+E,YAAA,GAAA5B,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGiB,SAAA2B,SAAA;QAAA,IAAAC,MAAA;QAAA,OAAA7B,mBAAA,GAAAU,IAAA,UAAAoB,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAlB,IAAA,GAAAkB,SAAA,CAAAjB,IAAA;YAAA;cAAAiB,SAAA,CAAAjB,IAAA;cAAA,OACM,KAAKzE,uBAAL,CAA6ByE,IAA7B,EAArB;YAAA;cAAMe,MAAM,GAAAE,SAAA,CAAAf,IAAA;cAAA,KAERa,MAAM,CAACZ,IAAX;gBAAAc,SAAA,CAAAjB,IAAA;gBAAA;cAAA;cAAA,MACQ,IAAIkB,KAAJ,CAAU,kCAAV,CAAN;YAAA;cAAA,OAAAD,SAAA,CAAAE,MAAA,WAGKJ,MAAM,CAACjF,KAAd;YAAA;YAAA;cAAA,OAAAmF,SAAA,CAAAV,IAAA;UAAA;QAAA,GAAAO,QAAA;MAAA,CACD;MAAA,SAAAhC,YAAA;QAAA,OAAA+B,YAAA,CAAAJ,KAAA,OAAA1E,SAAA;MAAA;MAAA,OAAA+C,WAAA;IAAA;EAAA;EAAA,OAAAtE,SAAA;AAAA,EAxKqBL,OAAA,CAAAiH,YAAxB;eA2Ke5G,S;;AACf6G,MAAM,CAACC,OAAP,GAAiB9G,SAAjB"},"metadata":{},"sourceType":"script"}