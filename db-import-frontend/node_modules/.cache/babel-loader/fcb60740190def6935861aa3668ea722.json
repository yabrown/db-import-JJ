{"ast":null,"code":"import _slicedToArray from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nvar noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  var authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n  }\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport var IdentityClient = /*#__PURE__*/function (_ServiceClient) {\n  _inherits(IdentityClient, _ServiceClient);\n  var _super = _createSuper(IdentityClient);\n  function IdentityClient(options) {\n    var _this;\n    _classCallCheck(this, IdentityClient);\n    var _a, _b;\n    var packageDetails = \"azsdk-js-identity/\".concat(SDK_VERSION);\n    var userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix) ? \"\".concat(options.userAgentOptions.userAgentPrefix, \" \").concat(packageDetails) : \"\".concat(packageDetails);\n    var baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n    _this = _super.call(this, Object.assign(Object.assign({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3\n      }\n    }, options), {\n      userAgentOptions: {\n        userAgentPrefix: userAgentPrefix\n      },\n      baseUri: baseUri\n    }));\n    _this.authorityHost = baseUri;\n    _this.abortControllers = new Map();\n    _this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n    return _this;\n  }\n  _createClass(IdentityClient, [{\n    key: \"sendTokenRequest\",\n    value: function () {\n      var _sendTokenRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, expiresOnParser) {\n        var response, parsedBody, token, error;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              logger.info(\"IdentityClient: sending token request to [\".concat(request.url, \"]\"));\n              _context.next = 3;\n              return this.sendRequest(request);\n            case 3:\n              response = _context.sent;\n              expiresOnParser = expiresOnParser || function (responseBody) {\n                return Date.now() + responseBody.expires_in * 1000;\n              };\n              if (!(response.bodyAsText && (response.status === 200 || response.status === 201))) {\n                _context.next = 15;\n                break;\n              }\n              parsedBody = JSON.parse(response.bodyAsText);\n              if (parsedBody.access_token) {\n                _context.next = 9;\n                break;\n              }\n              return _context.abrupt(\"return\", null);\n            case 9:\n              this.logIdentifiers(response);\n              token = {\n                accessToken: {\n                  token: parsedBody.access_token,\n                  expiresOnTimestamp: expiresOnParser(parsedBody)\n                },\n                refreshToken: parsedBody.refresh_token\n              };\n              logger.info(\"IdentityClient: [\".concat(request.url, \"] token acquired, expires on \").concat(token.accessToken.expiresOnTimestamp));\n              return _context.abrupt(\"return\", token);\n            case 15:\n              error = new AuthenticationError(response.status, response.bodyAsText);\n              logger.warning(\"IdentityClient: authentication error. HTTP status: \".concat(response.status, \", \").concat(error.errorResponse.errorDescription));\n              throw error;\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function sendTokenRequest(_x, _x2) {\n        return _sendTokenRequest.apply(this, arguments);\n      }\n      return sendTokenRequest;\n    }()\n  }, {\n    key: \"refreshAccessToken\",\n    value: function () {\n      var _refreshAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser) {\n        var _this2 = this;\n        var options,\n          refreshParams,\n          query,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : {};\n              if (!(refreshToken === undefined)) {\n                _context3.next = 3;\n                break;\n              }\n              return _context3.abrupt(\"return\", null);\n            case 3:\n              logger.info(\"IdentityClient: refreshing access token with client ID: \".concat(clientId, \", scopes: \").concat(scopes, \" started\"));\n              refreshParams = {\n                grant_type: \"refresh_token\",\n                client_id: clientId,\n                refresh_token: refreshToken,\n                scope: scopes\n              };\n              if (clientSecret !== undefined) {\n                refreshParams.client_secret = clientSecret;\n              }\n              query = new URLSearchParams(refreshParams);\n              return _context3.abrupt(\"return\", tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(updatedOptions) {\n                  var urlSuffix, request, response;\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.prev = 0;\n                        urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n                        request = createPipelineRequest({\n                          url: \"\".concat(_this2.authorityHost, \"/\").concat(tenantId, \"/\").concat(urlSuffix),\n                          method: \"POST\",\n                          body: query.toString(),\n                          abortSignal: options.abortSignal,\n                          headers: createHttpHeaders({\n                            Accept: \"application/json\",\n                            \"Content-Type\": \"application/x-www-form-urlencoded\"\n                          }),\n                          tracingOptions: updatedOptions.tracingOptions\n                        });\n                        _context2.next = 5;\n                        return _this2.sendTokenRequest(request, expiresOnParser);\n                      case 5:\n                        response = _context2.sent;\n                        logger.info(\"IdentityClient: refreshed token for client ID: \".concat(clientId));\n                        return _context2.abrupt(\"return\", response);\n                      case 10:\n                        _context2.prev = 10;\n                        _context2.t0 = _context2[\"catch\"](0);\n                        if (!(_context2.t0.name === AuthenticationErrorName && _context2.t0.errorResponse.error === \"interaction_required\")) {\n                          _context2.next = 17;\n                          break;\n                        }\n                        // It's likely that the refresh token has expired, so\n                        // return null so that the credential implementation will\n                        // initiate the authentication flow again.\n                        logger.info(\"IdentityClient: interaction required for client ID: \".concat(clientId));\n                        return _context2.abrupt(\"return\", null);\n                      case 17:\n                        logger.warning(\"IdentityClient: failed refreshing token for client ID: \".concat(clientId, \": \").concat(_context2.t0));\n                        throw _context2.t0;\n                      case 19:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2, null, [[0, 10]]);\n                }));\n                return function (_x9) {\n                  return _ref.apply(this, arguments);\n                };\n              }()));\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function refreshAccessToken(_x3, _x4, _x5, _x6, _x7, _x8) {\n        return _refreshAccessToken.apply(this, arguments);\n      }\n      return refreshAccessToken;\n    }() // Here is a custom layer that allows us to abort requests that go through MSAL,\n    // since MSAL doesn't allow us to pass options all the way through.\n  }, {\n    key: \"generateAbortSignal\",\n    value: function generateAbortSignal(correlationId) {\n      var _this3 = this;\n      var controller = new AbortController();\n      var controllers = this.abortControllers.get(correlationId) || [];\n      controllers.push(controller);\n      this.abortControllers.set(correlationId, controllers);\n      var existingOnAbort = controller.signal.onabort;\n      controller.signal.onabort = function () {\n        _this3.abortControllers.set(correlationId, undefined);\n        if (existingOnAbort) {\n          existingOnAbort.apply(void 0, arguments);\n        }\n      };\n      return controller.signal;\n    }\n  }, {\n    key: \"abortRequests\",\n    value: function abortRequests(correlationId) {\n      var key = correlationId || noCorrelationId;\n      var controllers = [].concat(_toConsumableArray(this.abortControllers.get(key) || []), _toConsumableArray(this.abortControllers.get(noCorrelationId) || []));\n      if (!controllers.length) {\n        return;\n      }\n      var _iterator = _createForOfIteratorHelper(controllers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var controller = _step.value;\n          controller.abort();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.abortControllers.set(key, undefined);\n    }\n  }, {\n    key: \"getCorrelationId\",\n    value: function getCorrelationId(options) {\n      var _a;\n      var parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map(function (part) {\n        return part.split(\"=\");\n      }).find(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 1),\n          key = _ref3[0];\n        return key === \"client-request-id\";\n      });\n      return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n    }\n    // The MSAL network module methods follow\n  }, {\n    key: \"sendGetRequestAsync\",\n    value: function () {\n      var _sendGetRequestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(url, options) {\n        var request, response;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              request = createPipelineRequest({\n                url: url,\n                method: \"GET\",\n                body: options === null || options === void 0 ? void 0 : options.body,\n                headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n                abortSignal: this.generateAbortSignal(noCorrelationId)\n              });\n              _context4.next = 3;\n              return this.sendRequest(request);\n            case 3:\n              response = _context4.sent;\n              this.logIdentifiers(response);\n              return _context4.abrupt(\"return\", {\n                body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n                headers: response.headers.toJSON(),\n                status: response.status\n              });\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function sendGetRequestAsync(_x10, _x11) {\n        return _sendGetRequestAsync.apply(this, arguments);\n      }\n      return sendGetRequestAsync;\n    }()\n  }, {\n    key: \"sendPostRequestAsync\",\n    value: function () {\n      var _sendPostRequestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(url, options) {\n        var request, response;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              request = createPipelineRequest({\n                url: url,\n                method: \"POST\",\n                body: options === null || options === void 0 ? void 0 : options.body,\n                headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n                // MSAL doesn't send the correlation ID on the get requests.\n                abortSignal: this.generateAbortSignal(this.getCorrelationId(options))\n              });\n              _context5.next = 3;\n              return this.sendRequest(request);\n            case 3:\n              response = _context5.sent;\n              this.logIdentifiers(response);\n              return _context5.abrupt(\"return\", {\n                body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n                headers: response.headers.toJSON(),\n                status: response.status\n              });\n            case 6:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function sendPostRequestAsync(_x12, _x13) {\n        return _sendPostRequestAsync.apply(this, arguments);\n      }\n      return sendPostRequestAsync;\n    }()\n    /**\n     * If allowLoggingAccountIdentifiers was set on the constructor options\n     * we try to log the account identifiers by parsing the received access token.\n     *\n     * The account identifiers we try to log are:\n     * - `appid`: The application or Client Identifier.\n     * - `upn`: User Principal Name.\n     *   - It might not be available in some authentication scenarios.\n     *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n     * - `tid`: Tenant Identifier.\n     * - `oid`: Object Identifier of the authenticated user.\n     */\n  }, {\n    key: \"logIdentifiers\",\n    value: function logIdentifiers(response) {\n      if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n        return;\n      }\n      var unavailableUpn = \"No User Principal Name available\";\n      try {\n        var parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n        var accessToken = parsed.access_token;\n        if (!accessToken) {\n          // Without an access token allowLoggingAccountIdentifiers isn't useful.\n          return;\n        }\n        var base64Metadata = accessToken.split(\".\")[1];\n        var _JSON$parse = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\")),\n          appid = _JSON$parse.appid,\n          upn = _JSON$parse.upn,\n          tid = _JSON$parse.tid,\n          oid = _JSON$parse.oid;\n        logger.info(\"[Authenticated account] Client ID: \".concat(appid, \". Tenant ID: \").concat(tid, \". User Principal Name: \").concat(upn || unavailableUpn, \". Object ID (user): \").concat(oid));\n      } catch (e) {\n        logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n      }\n    }\n  }]);\n  return IdentityClient;\n}(ServiceClient);","map":{"version":3,"names":["ServiceClient","isNode","createHttpHeaders","createPipelineRequest","AbortController","AuthenticationError","AuthenticationErrorName","getIdentityTokenEndpointSuffix","DefaultAuthorityHost","SDK_VERSION","tracingClient","logger","noCorrelationId","getIdentityClientAuthorityHost","options","authorityHost","process","env","AZURE_AUTHORITY_HOST","IdentityClient","_ServiceClient","_inherits","_super","_createSuper","_this","_classCallCheck","packageDetails","concat","userAgentPrefix","_a","userAgentOptions","baseUri","startsWith","Error","call","Object","assign","requestContentType","retryOptions","maxRetries","abortControllers","Map","allowLoggingAccountIdentifiers","_b","loggingOptions","_createClass","key","value","_sendTokenRequest","_asyncToGenerator","_regeneratorRuntime","mark","_callee","request","expiresOnParser","response","parsedBody","token","error","wrap","_callee$","_context","prev","next","info","url","sendRequest","sent","responseBody","Date","now","expires_in","bodyAsText","status","JSON","parse","access_token","abrupt","logIdentifiers","accessToken","expiresOnTimestamp","refreshToken","refresh_token","warning","errorResponse","errorDescription","stop","sendTokenRequest","_x","_x2","apply","arguments","_refreshAccessToken","_callee3","tenantId","clientId","scopes","clientSecret","_this2","refreshParams","query","_args3","_callee3$","_context3","length","undefined","grant_type","client_id","scope","client_secret","URLSearchParams","withSpan","_ref","_callee2","updatedOptions","urlSuffix","_callee2$","_context2","method","body","toString","abortSignal","headers","Accept","tracingOptions","t0","name","_x9","refreshAccessToken","_x3","_x4","_x5","_x6","_x7","_x8","generateAbortSignal","correlationId","_this3","controller","controllers","get","push","set","existingOnAbort","signal","onabort","abortRequests","_toConsumableArray","_iterator","_createForOfIteratorHelper","_step","s","n","done","abort","err","e","f","getCorrelationId","parameter","split","map","part","find","_ref2","_ref3","_slicedToArray","_sendGetRequestAsync","_callee4","_callee4$","_context4","toJSON","sendGetRequestAsync","_x10","_x11","_sendPostRequestAsync","_callee5","_callee5$","_context5","sendPostRequestAsync","_x12","_x13","unavailableUpn","parsed","base64Metadata","_JSON$parse","Buffer","from","appid","upn","tid","oid","message"],"sources":["../../../src/client/identityClient.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { INetworkModule, NetworkRequestOptions, NetworkResponse } from \"@azure/msal-common\";\nimport { AccessToken, GetTokenOptions } from \"@azure/core-auth\";\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport {\n  PipelineRequest,\n  PipelineResponse,\n  createHttpHeaders,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nimport { TokenCredentialOptions } from \"../tokenCredentialOptions\";\n\nconst noCorrelationId = \"noCorrelationId\";\n\n/**\n * An internal type used to communicate details of a token request's\n * response that should not be sent back as part of the access token.\n */\nexport interface TokenResponse {\n  /**\n   * The AccessToken to be returned from getToken.\n   */\n  accessToken: AccessToken;\n\n  /**\n   * The refresh token if the 'offline_access' scope was used.\n   */\n  refreshToken?: string;\n}\n\n/**\n * Internal type roughly matching the raw responses of the authentication endpoints.\n *\n * @internal\n */\nexport interface TokenResponseParsedBody {\n  token?: string;\n  access_token?: string;\n  refresh_token?: string;\n  expires_in: number;\n  expires_on?: number | string;\n}\n\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options?: TokenCredentialOptions): string {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options?.authorityHost;\n\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost ?? process.env.AZURE_AUTHORITY_HOST;\n  }\n\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost ?? DefaultAuthorityHost;\n}\n\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient implements INetworkModule {\n  public authorityHost: string;\n  private allowLoggingAccountIdentifiers?: boolean;\n  private abortControllers: Map<string, AbortController[] | undefined>;\n\n  constructor(options?: TokenCredentialOptions) {\n    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n    const userAgentPrefix = options?.userAgentOptions?.userAgentPrefix\n      ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n      : `${packageDetails}`;\n\n    const baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n\n    super({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3,\n      },\n      ...options,\n      userAgentOptions: {\n        userAgentPrefix,\n      },\n      baseUri,\n    });\n\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n    this.allowLoggingAccountIdentifiers = options?.loggingOptions?.allowLoggingAccountIdentifiers;\n  }\n\n  async sendTokenRequest(\n    request: PipelineRequest,\n    expiresOnParser?: (responseBody: TokenResponseParsedBody) => number\n  ): Promise<TokenResponse | null> {\n    logger.info(`IdentityClient: sending token request to [${request.url}]`);\n    const response = await this.sendRequest(request);\n\n    expiresOnParser =\n      expiresOnParser ||\n      ((responseBody: TokenResponseParsedBody) => {\n        return Date.now() + responseBody.expires_in * 1000;\n      });\n\n    if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n      const parsedBody: TokenResponseParsedBody = JSON.parse(response.bodyAsText);\n\n      if (!parsedBody.access_token) {\n        return null;\n      }\n\n      this.logIdentifiers(response);\n\n      const token = {\n        accessToken: {\n          token: parsedBody.access_token,\n          expiresOnTimestamp: expiresOnParser(parsedBody),\n        },\n        refreshToken: parsedBody.refresh_token,\n      };\n\n      logger.info(\n        `IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`\n      );\n      return token;\n    } else {\n      const error = new AuthenticationError(response.status, response.bodyAsText);\n      logger.warning(\n        `IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`\n      );\n      throw error;\n    }\n  }\n\n  async refreshAccessToken(\n    tenantId: string,\n    clientId: string,\n    scopes: string,\n    refreshToken: string | undefined,\n    clientSecret: string | undefined,\n    expiresOnParser?: (responseBody: TokenResponseParsedBody) => number,\n    options: GetTokenOptions = {}\n  ): Promise<TokenResponse | null> {\n    if (refreshToken === undefined) {\n      return null;\n    }\n    logger.info(\n      `IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`\n    );\n\n    const refreshParams = {\n      grant_type: \"refresh_token\",\n      client_id: clientId,\n      refresh_token: refreshToken,\n      scope: scopes,\n    };\n\n    if (clientSecret !== undefined) {\n      (refreshParams as any).client_secret = clientSecret;\n    }\n\n    const query = new URLSearchParams(refreshParams);\n\n    return tracingClient.withSpan(\n      \"IdentityClient.refreshAccessToken\",\n      options,\n      async (updatedOptions) => {\n        try {\n          const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n          const request = createPipelineRequest({\n            url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n            method: \"POST\",\n            body: query.toString(),\n            abortSignal: options.abortSignal,\n            headers: createHttpHeaders({\n              Accept: \"application/json\",\n              \"Content-Type\": \"application/x-www-form-urlencoded\",\n            }),\n            tracingOptions: updatedOptions.tracingOptions,\n          });\n\n          const response = await this.sendTokenRequest(request, expiresOnParser);\n          logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n          return response;\n        } catch (err: any) {\n          if (\n            err.name === AuthenticationErrorName &&\n            err.errorResponse.error === \"interaction_required\"\n          ) {\n            // It's likely that the refresh token has expired, so\n            // return null so that the credential implementation will\n            // initiate the authentication flow again.\n            logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n            return null;\n          } else {\n            logger.warning(\n              `IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`\n            );\n            throw err;\n          }\n        }\n      }\n    );\n  }\n\n  // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n\n  generateAbortSignal(correlationId: string): AbortSignalLike {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n      if (existingOnAbort) {\n        existingOnAbort(...params);\n      }\n    };\n    return controller.signal;\n  }\n\n  abortRequests(correlationId?: string): void {\n    const key = correlationId || noCorrelationId;\n    const controllers = [\n      ...(this.abortControllers.get(key) || []),\n      // MSAL passes no correlation ID to the get requests...\n      ...(this.abortControllers.get(noCorrelationId) || []),\n    ];\n    if (!controllers.length) {\n      return;\n    }\n    for (const controller of controllers) {\n      controller.abort();\n    }\n    this.abortControllers.set(key, undefined);\n  }\n\n  getCorrelationId(options?: NetworkRequestOptions): string {\n    const parameter = options?.body\n      ?.split(\"&\")\n      .map((part) => part.split(\"=\"))\n      .find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  }\n\n  // The MSAL network module methods follow\n\n  async sendGetRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions\n  ): Promise<NetworkResponse<T>> {\n    const request = createPipelineRequest({\n      url,\n      method: \"GET\",\n      body: options?.body,\n      headers: createHttpHeaders(options?.headers),\n      abortSignal: this.generateAbortSignal(noCorrelationId),\n    });\n\n    const response = await this.sendRequest(request);\n\n    this.logIdentifiers(response);\n\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status,\n    };\n  }\n\n  async sendPostRequestAsync<T>(\n    url: string,\n    options?: NetworkRequestOptions\n  ): Promise<NetworkResponse<T>> {\n    const request = createPipelineRequest({\n      url,\n      method: \"POST\",\n      body: options?.body,\n      headers: createHttpHeaders(options?.headers),\n      // MSAL doesn't send the correlation ID on the get requests.\n      abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),\n    });\n\n    const response = await this.sendRequest(request);\n\n    this.logIdentifiers(response);\n\n    return {\n      body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n      headers: response.headers.toJSON(),\n      status: response.status,\n    };\n  }\n\n  /**\n   * If allowLoggingAccountIdentifiers was set on the constructor options\n   * we try to log the account identifiers by parsing the received access token.\n   *\n   * The account identifiers we try to log are:\n   * - `appid`: The application or Client Identifier.\n   * - `upn`: User Principal Name.\n   *   - It might not be available in some authentication scenarios.\n   *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n   * - `tid`: Tenant Identifier.\n   * - `oid`: Object Identifier of the authenticated user.\n   */\n  private logIdentifiers(response: PipelineResponse): void {\n    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n      return;\n    }\n    const unavailableUpn = \"No User Principal Name available\";\n    try {\n      const parsed = (response as any).parsedBody || JSON.parse(response.bodyAsText);\n      const accessToken = parsed.access_token;\n      if (!accessToken) {\n        // Without an access token allowLoggingAccountIdentifiers isn't useful.\n        return;\n      }\n      const base64Metadata = accessToken.split(\".\")[1];\n      const { appid, upn, tid, oid } = JSON.parse(\n        Buffer.from(base64Metadata, \"base64\").toString(\"utf8\")\n      );\n\n      logger.info(\n        `[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${\n          upn || unavailableUpn\n        }. Object ID (user): ${oid}`\n      );\n    } catch (e: any) {\n      logger.warning(\n        \"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\",\n        e.message\n      );\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}