{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nvar SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nvar UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nvar ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n\n/**\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\nvar WritableTrackingBuffer = /*#__PURE__*/function () {\n  function WritableTrackingBuffer(initialSize, encoding, doubleSizeGrowth) {\n    _classCallCheck(this, WritableTrackingBuffer);\n    this.initialSize = void 0;\n    this.encoding = void 0;\n    this.doubleSizeGrowth = void 0;\n    this.buffer = void 0;\n    this.compositeBuffer = void 0;\n    this.position = void 0;\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  }\n  _createClass(WritableTrackingBuffer, [{\n    key: \"data\",\n    get: function get() {\n      this.newBuffer(0);\n      return this.compositeBuffer;\n    }\n  }, {\n    key: \"copyFrom\",\n    value: function copyFrom(buffer) {\n      var length = buffer.length;\n      this.makeRoomFor(length);\n      buffer.copy(this.buffer, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"makeRoomFor\",\n    value: function makeRoomFor(requiredLength) {\n      if (this.buffer.length - this.position < requiredLength) {\n        if (this.doubleSizeGrowth) {\n          var size = Math.max(128, this.buffer.length * 2);\n          while (size < requiredLength) {\n            size *= 2;\n          }\n          this.newBuffer(size);\n        } else {\n          this.newBuffer(requiredLength);\n        }\n      }\n    }\n  }, {\n    key: \"newBuffer\",\n    value: function newBuffer(size) {\n      var buffer = this.buffer.slice(0, this.position);\n      this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n      this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n      this.position = 0;\n    }\n  }, {\n    key: \"writeUInt8\",\n    value: function writeUInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt8(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt16LE\",\n    value: function writeUInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUShort\",\n    value: function writeUShort(value) {\n      this.writeUInt16LE(value);\n    }\n  }, {\n    key: \"writeUInt16BE\",\n    value: function writeUInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt24LE\",\n    value: function writeUInt24LE(value) {\n      var length = 3;\n      this.makeRoomFor(length);\n      this.buffer[this.position + 2] = value >>> 16 & 0xff;\n      this.buffer[this.position + 1] = value >>> 8 & 0xff;\n      this.buffer[this.position] = value & 0xff;\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt32LE\",\n    value: function writeUInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeBigInt64LE\",\n    value: function writeBigInt64LE(value) {\n      var length = 8;\n      this.makeRoomFor(length);\n      this.buffer.writeBigInt64LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt64LE\",\n    value: function writeInt64LE(value) {\n      this.writeBigInt64LE(BigInt(value));\n    }\n  }, {\n    key: \"writeUInt64LE\",\n    value: function writeUInt64LE(value) {\n      this.writeBigUInt64LE(BigInt(value));\n    }\n  }, {\n    key: \"writeBigUInt64LE\",\n    value: function writeBigUInt64LE(value) {\n      var length = 8;\n      this.makeRoomFor(length);\n      this.buffer.writeBigUInt64LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt32BE\",\n    value: function writeUInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt40LE\",\n    value: function writeUInt40LE(value) {\n      // inspired by https://github.com/dpw/node-buffer-more-ints\n      this.writeInt32LE(value & -1);\n      this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeInt8(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt16LE\",\n    value: function writeInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt16BE\",\n    value: function writeInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt32LE\",\n    value: function writeInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt32BE\",\n    value: function writeInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeFloatLE\",\n    value: function writeFloatLE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeFloatLE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeDoubleLE\",\n    value: function writeDoubleLE(value) {\n      var length = 8;\n      this.makeRoomFor(length);\n      this.buffer.writeDoubleLE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n      var length = Buffer.byteLength(value, encoding);\n      this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }, {\n    key: \"writeBVarchar\",\n    value: function writeBVarchar(value, encoding) {\n      this.writeUInt8(value.length);\n      this.writeString(value, encoding);\n    }\n  }, {\n    key: \"writeUsVarchar\",\n    value: function writeUsVarchar(value, encoding) {\n      this.writeUInt16LE(value.length);\n      this.writeString(value, encoding);\n    } // TODO: Figure out what types are passed in other than `Buffer`\n  }, {\n    key: \"writeUsVarbyte\",\n    value: function writeUsVarbyte(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n      var length;\n      if (value instanceof Buffer) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      }\n      this.writeUInt16LE(length);\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    }\n  }, {\n    key: \"writePLPBody\",\n    value: function writePLPBody(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n      var length;\n      if (value instanceof Buffer) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      } // Length of all chunks.\n      // this.writeUInt64LE(length);\n      // unknown seems to work better here - might revisit later.\n\n      this.writeBuffer(UNKNOWN_PLP_LEN); // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n\n      if (length > 0) {\n        // One chunk.\n        this.writeUInt32LE(length);\n        if (value instanceof Buffer) {\n          this.writeBuffer(value);\n        } else {\n          this.makeRoomFor(length);\n          this.buffer.write(value, this.position, encoding);\n          this.position += length;\n        }\n      } // PLP_TERMINATOR (no more chunks).\n\n      this.writeUInt32LE(0);\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(value) {\n      var length = value.length;\n      this.makeRoomFor(length);\n      value.copy(this.buffer, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeMoney\",\n    value: function writeMoney(value) {\n      this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n      this.writeInt32LE(value & -1);\n    }\n  }]);\n  return WritableTrackingBuffer;\n}();\nvar _default = WritableTrackingBuffer;\nexports.default = _default;\nmodule.exports = WritableTrackingBuffer;","map":{"version":3,"names":["SHIFT_LEFT_32","SHIFT_RIGHT_32","UNKNOWN_PLP_LEN","Buffer","from","ZERO_LENGTH_BUFFER","alloc","WritableTrackingBuffer","initialSize","encoding","doubleSizeGrowth","_classCallCheck","buffer","compositeBuffer","position","_createClass","key","get","newBuffer","value","copyFrom","length","makeRoomFor","copy","requiredLength","size","Math","max","slice","concat","writeUInt8","writeUInt16LE","writeUShort","writeUInt16BE","writeUInt24LE","writeUInt32LE","writeBigInt64LE","writeInt64LE","BigInt","writeUInt64LE","writeBigUInt64LE","writeUInt32BE","writeUInt40LE","writeInt32LE","floor","writeInt8","writeInt16LE","writeInt16BE","writeInt32BE","writeFloatLE","writeDoubleLE","writeString","byteLength","write","writeBVarchar","writeUsVarchar","writeUsVarbyte","toString","writeBuffer","writePLPBody","writeMoney","module","exports"],"sources":["../../src/tracking-buffer/writable-tracking-buffer.ts"],"sourcesContent":["const SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nconst UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nconst ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n\nexport type Encoding = 'utf8' | 'ucs2' | 'ascii';\n\n/**\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\nclass WritableTrackingBuffer {\n  initialSize: number;\n  encoding: Encoding;\n  doubleSizeGrowth: boolean;\n\n  buffer: Buffer;\n  compositeBuffer: Buffer;\n\n  position: number;\n\n  constructor(initialSize: number, encoding?: Encoding | null, doubleSizeGrowth?: boolean) {\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  }\n\n  get data() {\n    this.newBuffer(0);\n    return this.compositeBuffer;\n  }\n\n  copyFrom(buffer: Buffer) {\n    const length = buffer.length;\n    this.makeRoomFor(length);\n    buffer.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  makeRoomFor(requiredLength: number) {\n    if (this.buffer.length - this.position < requiredLength) {\n      if (this.doubleSizeGrowth) {\n        let size = Math.max(128, this.buffer.length * 2);\n        while (size < requiredLength) {\n          size *= 2;\n        }\n        this.newBuffer(size);\n      } else {\n        this.newBuffer(requiredLength);\n      }\n    }\n  }\n\n  newBuffer(size: number) {\n    const buffer = this.buffer.slice(0, this.position);\n    this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n    this.buffer = (size === 0) ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n    this.position = 0;\n  }\n\n  writeUInt8(value: number) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt16LE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeUShort(value: number) {\n    this.writeUInt16LE(value);\n  }\n\n  writeUInt16BE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt24LE(value: number) {\n    const length = 3;\n    this.makeRoomFor(length);\n    this.buffer[this.position + 2] = (value >>> 16) & 0xff;\n    this.buffer[this.position + 1] = (value >>> 8) & 0xff;\n    this.buffer[this.position] = value & 0xff;\n    this.position += length;\n  }\n\n  writeUInt32LE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeBigInt64LE(value: bigint) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeBigInt64LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt64LE(value: number) {\n    this.writeBigInt64LE(BigInt(value));\n  }\n\n  writeUInt64LE(value: number) {\n    this.writeBigUInt64LE(BigInt(value));\n  }\n\n  writeBigUInt64LE(value: bigint) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeBigUInt64LE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt32BE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeUInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeUInt40LE(value: number) {\n    // inspired by https://github.com/dpw/node-buffer-more-ints\n    this.writeInt32LE(value & -1);\n    this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n  }\n\n  writeInt8(value: number) {\n    const length = 1;\n    this.makeRoomFor(length);\n    this.buffer.writeInt8(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16LE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt16BE(value: number) {\n    const length = 2;\n    this.makeRoomFor(length);\n    this.buffer.writeInt16BE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32LE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32LE(value, this.position);\n    this.position += length;\n  }\n\n  writeInt32BE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeInt32BE(value, this.position);\n    this.position += length;\n  }\n\n  writeFloatLE(value: number) {\n    const length = 4;\n    this.makeRoomFor(length);\n    this.buffer.writeFloatLE(value, this.position);\n    this.position += length;\n  }\n\n  writeDoubleLE(value: number) {\n    const length = 8;\n    this.makeRoomFor(length);\n    this.buffer.writeDoubleLE(value, this.position);\n    this.position += length;\n  }\n\n  writeString(value: string, encoding?: Encoding | null) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    const length = Buffer.byteLength(value, encoding);\n    this.makeRoomFor(length);\n\n    // $FlowFixMe https://github.com/facebook/flow/pull/5398\n    this.buffer.write(value, this.position, encoding);\n    this.position += length;\n  }\n\n  writeBVarchar(value: string, encoding?: Encoding | null) {\n    this.writeUInt8(value.length);\n    this.writeString(value, encoding);\n  }\n\n  writeUsVarchar(value: string, encoding?: Encoding | null) {\n    this.writeUInt16LE(value.length);\n    this.writeString(value, encoding);\n  }\n\n  // TODO: Figure out what types are passed in other than `Buffer`\n  writeUsVarbyte(value: any, encoding?: Encoding | null) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n    this.writeUInt16LE(length);\n\n    if (value instanceof Buffer) {\n      this.writeBuffer(value);\n    } else {\n      this.makeRoomFor(length);\n      // $FlowFixMe https://github.com/facebook/flow/pull/5398\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }\n\n  writePLPBody(value: any, encoding?: Encoding | null) {\n    if (encoding == null) {\n      encoding = this.encoding;\n    }\n\n    let length;\n    if (value instanceof Buffer) {\n      length = value.length;\n    } else {\n      value = value.toString();\n      length = Buffer.byteLength(value, encoding);\n    }\n\n    // Length of all chunks.\n    // this.writeUInt64LE(length);\n    // unknown seems to work better here - might revisit later.\n    this.writeBuffer(UNKNOWN_PLP_LEN);\n\n    // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n    if (length > 0) {\n      // One chunk.\n      this.writeUInt32LE(length);\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length);\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    }\n\n    // PLP_TERMINATOR (no more chunks).\n    this.writeUInt32LE(0);\n  }\n\n  writeBuffer(value: Buffer) {\n    const length = value.length;\n    this.makeRoomFor(length);\n    value.copy(this.buffer, this.position);\n    this.position += length;\n  }\n\n  writeMoney(value: number) {\n    this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n    this.writeInt32LE(value & -1);\n  }\n}\n\nexport default WritableTrackingBuffer;\nmodule.exports = WritableTrackingBuffer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}