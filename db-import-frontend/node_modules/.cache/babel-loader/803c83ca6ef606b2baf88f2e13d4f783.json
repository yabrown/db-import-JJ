{"ast":null,"code":"'use strict';\n\nmodule.exports = validate;\nfunction isArguments(thingy) {\n  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee');\n}\nvar types = {\n  '*': {\n    label: 'any',\n    check: function check() {\n      return true;\n    }\n  },\n  A: {\n    label: 'array',\n    check: function check(_) {\n      return Array.isArray(_) || isArguments(_);\n    }\n  },\n  S: {\n    label: 'string',\n    check: function check(_) {\n      return typeof _ === 'string';\n    }\n  },\n  N: {\n    label: 'number',\n    check: function check(_) {\n      return typeof _ === 'number';\n    }\n  },\n  F: {\n    label: 'function',\n    check: function check(_) {\n      return typeof _ === 'function';\n    }\n  },\n  O: {\n    label: 'object',\n    check: function check(_) {\n      return typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_);\n    }\n  },\n  B: {\n    label: 'boolean',\n    check: function check(_) {\n      return typeof _ === 'boolean';\n    }\n  },\n  E: {\n    label: 'error',\n    check: function check(_) {\n      return _ instanceof Error;\n    }\n  },\n  Z: {\n    label: 'null',\n    check: function check(_) {\n      return _ == null;\n    }\n  }\n};\nfunction addSchema(schema, arity) {\n  var group = arity[schema.length] = arity[schema.length] || [];\n  if (group.indexOf(schema) === -1) group.push(schema);\n}\nfunction validate(rawSchemas, args) {\n  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length);\n  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas');\n  if (!args) throw missingRequiredArg(1, 'args');\n  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas);\n  if (!types.A.check(args)) throw invalidType(1, ['array'], args);\n  var schemas = rawSchemas.split('|');\n  var arity = {};\n  schemas.forEach(function (schema) {\n    for (var ii = 0; ii < schema.length; ++ii) {\n      var type = schema[ii];\n      if (!types[type]) throw unknownType(ii, type);\n    }\n    if (/E.*E/.test(schema)) throw moreThanOneError(schema);\n    addSchema(schema, arity);\n    if (/E/.test(schema)) {\n      addSchema(schema.replace(/E.*$/, 'E'), arity);\n      addSchema(schema.replace(/E/, 'Z'), arity);\n      if (schema.length === 1) addSchema('', arity);\n    }\n  });\n  var matching = arity[args.length];\n  if (!matching) {\n    throw wrongNumberOfArgs(Object.keys(arity), args.length);\n  }\n  var _loop = function _loop(ii) {\n    var newMatching = matching.filter(function (schema) {\n      var type = schema[ii];\n      var typeCheck = types[type].check;\n      return typeCheck(args[ii]);\n    });\n    if (!newMatching.length) {\n      var labels = matching.map(function (_) {\n        return types[_[ii]].label;\n      }).filter(function (_) {\n        return _ != null;\n      });\n      throw invalidType(ii, labels, args[ii]);\n    }\n    matching = newMatching;\n  };\n  for (var ii = 0; ii < args.length; ++ii) {\n    _loop(ii);\n  }\n}\nfunction missingRequiredArg(num) {\n  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1));\n}\nfunction unknownType(num, type) {\n  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1));\n}\nfunction invalidType(num, expectedTypes, value) {\n  var valueType;\n  Object.keys(types).forEach(function (typeCode) {\n    if (types[typeCode].check(value)) valueType = types[typeCode].label;\n  });\n  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' + englishList(expectedTypes) + ' but got ' + valueType);\n}\nfunction englishList(list) {\n  return list.join(', ').replace(/, ([^,]+)$/, ' or $1');\n}\nfunction wrongNumberOfArgs(expected, got) {\n  var english = englishList(expected);\n  var args = expected.every(function (ex) {\n    return ex.length === 1;\n  }) ? 'argument' : 'arguments';\n  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got);\n}\nfunction moreThanOneError(schema) {\n  return newException('ETOOMANYERRORTYPES', 'Only one error type per argument signature is allowed, more than one found in \"' + schema + '\"');\n}\nfunction newException(code, msg) {\n  var err = new Error(msg);\n  err.code = code;\n  /* istanbul ignore else */\n  if (Error.captureStackTrace) Error.captureStackTrace(err, validate);\n  return err;\n}","map":{"version":3,"names":["module","exports","validate","isArguments","thingy","hasOwnProperty","types","label","check","A","_","Array","isArray","S","N","F","O","E","B","Error","Z","addSchema","schema","arity","group","length","indexOf","push","rawSchemas","args","arguments","wrongNumberOfArgs","missingRequiredArg","invalidType","schemas","split","forEach","ii","type","unknownType","test","moreThanOneError","replace","matching","Object","keys","_loop","newMatching","filter","typeCheck","labels","map","num","newException","expectedTypes","value","valueType","typeCode","englishList","list","join","expected","got","english","every","ex","code","msg","err","captureStackTrace"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/aproba/index.js"],"sourcesContent":["'use strict'\nmodule.exports = validate\n\nfunction isArguments (thingy) {\n  return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee')\n}\n\nconst types = {\n  '*': {label: 'any', check: () => true},\n  A: {label: 'array', check: _ => Array.isArray(_) || isArguments(_)},\n  S: {label: 'string', check: _ => typeof _ === 'string'},\n  N: {label: 'number', check: _ => typeof _ === 'number'},\n  F: {label: 'function', check: _ => typeof _ === 'function'},\n  O: {label: 'object', check: _ => typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_)},\n  B: {label: 'boolean', check: _ => typeof _ === 'boolean'},\n  E: {label: 'error', check: _ => _ instanceof Error},\n  Z: {label: 'null', check: _ => _ == null}\n}\n\nfunction addSchema (schema, arity) {\n  const group = arity[schema.length] = arity[schema.length] || []\n  if (group.indexOf(schema) === -1) group.push(schema)\n}\n\nfunction validate (rawSchemas, args) {\n  if (arguments.length !== 2) throw wrongNumberOfArgs(['SA'], arguments.length)\n  if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas')\n  if (!args) throw missingRequiredArg(1, 'args')\n  if (!types.S.check(rawSchemas)) throw invalidType(0, ['string'], rawSchemas)\n  if (!types.A.check(args)) throw invalidType(1, ['array'], args)\n  const schemas = rawSchemas.split('|')\n  const arity = {}\n\n  schemas.forEach(schema => {\n    for (let ii = 0; ii < schema.length; ++ii) {\n      const type = schema[ii]\n      if (!types[type]) throw unknownType(ii, type)\n    }\n    if (/E.*E/.test(schema)) throw moreThanOneError(schema)\n    addSchema(schema, arity)\n    if (/E/.test(schema)) {\n      addSchema(schema.replace(/E.*$/, 'E'), arity)\n      addSchema(schema.replace(/E/, 'Z'), arity)\n      if (schema.length === 1) addSchema('', arity)\n    }\n  })\n  let matching = arity[args.length]\n  if (!matching) {\n    throw wrongNumberOfArgs(Object.keys(arity), args.length)\n  }\n  for (let ii = 0; ii < args.length; ++ii) {\n    let newMatching = matching.filter(schema => {\n      const type = schema[ii]\n      const typeCheck = types[type].check\n      return typeCheck(args[ii])\n    })\n    if (!newMatching.length) {\n      const labels = matching.map(_ => types[_[ii]].label).filter(_ => _ != null)\n      throw invalidType(ii, labels, args[ii])\n    }\n    matching = newMatching\n  }\n}\n\nfunction missingRequiredArg (num) {\n  return newException('EMISSINGARG', 'Missing required argument #' + (num + 1))\n}\n\nfunction unknownType (num, type) {\n  return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1))\n}\n\nfunction invalidType (num, expectedTypes, value) {\n  let valueType\n  Object.keys(types).forEach(typeCode => {\n    if (types[typeCode].check(value)) valueType = types[typeCode].label\n  })\n  return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' +\n    englishList(expectedTypes) + ' but got ' + valueType)\n}\n\nfunction englishList (list) {\n  return list.join(', ').replace(/, ([^,]+)$/, ' or $1')\n}\n\nfunction wrongNumberOfArgs (expected, got) {\n  const english = englishList(expected)\n  const args = expected.every(ex => ex.length === 1)\n    ? 'argument'\n    : 'arguments'\n  return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got)\n}\n\nfunction moreThanOneError (schema) {\n  return newException('ETOOMANYERRORTYPES',\n    'Only one error type per argument signature is allowed, more than one found in \"' + schema + '\"')\n}\n\nfunction newException (code, msg) {\n  const err = new Error(msg)\n  err.code = code\n  /* istanbul ignore else */\n  if (Error.captureStackTrace) Error.captureStackTrace(err, validate)\n  return err\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,OAAO,GAAGC,QAAQ;AAEzB,SAASC,WAAWA,CAAEC,MAAM,EAAE;EAC5B,OAAOA,MAAM,IAAI,IAAI,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACC,cAAc,CAAC,QAAQ,CAAC;AACxF;AAEA,IAAMC,KAAK,GAAG;EACZ,GAAG,EAAE;IAACC,KAAK,EAAE,KAAK;IAAEC,KAAK,EAAE,SAAAA,MAAA;MAAA,OAAM,IAAI;IAAA;EAAA,CAAC;EACtCC,CAAC,EAAE;IAACF,KAAK,EAAE,OAAO;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAIC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,IAAIP,WAAW,CAACO,CAAC,CAAC;IAAA;EAAA,CAAC;EACnEG,CAAC,EAAE;IAACN,KAAK,EAAE,QAAQ;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAI,OAAOA,CAAC,KAAK,QAAQ;IAAA;EAAA,CAAC;EACvDI,CAAC,EAAE;IAACP,KAAK,EAAE,QAAQ;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAI,OAAOA,CAAC,KAAK,QAAQ;IAAA;EAAA,CAAC;EACvDK,CAAC,EAAE;IAACR,KAAK,EAAE,UAAU;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAI,OAAOA,CAAC,KAAK,UAAU;IAAA;EAAA,CAAC;EAC3DM,CAAC,EAAE;IAACT,KAAK,EAAE,QAAQ;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAI,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,IAAI,IAAI,IAAI,CAACJ,KAAK,CAACG,CAAC,CAACD,KAAK,CAACE,CAAC,CAAC,IAAI,CAACJ,KAAK,CAACW,CAAC,CAACT,KAAK,CAACE,CAAC,CAAC;IAAA;EAAA,CAAC;EAC9GQ,CAAC,EAAE;IAACX,KAAK,EAAE,SAAS;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAI,OAAOA,CAAC,KAAK,SAAS;IAAA;EAAA,CAAC;EACzDO,CAAC,EAAE;IAACV,KAAK,EAAE,OAAO;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAIA,CAAC,YAAYS,KAAK;IAAA;EAAA,CAAC;EACnDC,CAAC,EAAE;IAACb,KAAK,EAAE,MAAM;IAAEC,KAAK,EAAE,SAAAA,MAAAE,CAAC;MAAA,OAAIA,CAAC,IAAI,IAAI;IAAA;EAAA;AAC1C,CAAC;AAED,SAASW,SAASA,CAAEC,MAAM,EAAEC,KAAK,EAAE;EACjC,IAAMC,KAAK,GAAGD,KAAK,CAACD,MAAM,CAACG,MAAM,CAAC,GAAGF,KAAK,CAACD,MAAM,CAACG,MAAM,CAAC,IAAI,EAAE;EAC/D,IAAID,KAAK,CAACE,OAAO,CAACJ,MAAM,CAAC,KAAK,CAAC,CAAC,EAAEE,KAAK,CAACG,IAAI,CAACL,MAAM,CAAC;AACtD;AAEA,SAASpB,QAAQA,CAAE0B,UAAU,EAAEC,IAAI,EAAE;EACnC,IAAIC,SAAS,CAACL,MAAM,KAAK,CAAC,EAAE,MAAMM,iBAAiB,CAAC,CAAC,IAAI,CAAC,EAAED,SAAS,CAACL,MAAM,CAAC;EAC7E,IAAI,CAACG,UAAU,EAAE,MAAMI,kBAAkB,CAAC,CAAC,EAAE,YAAY,CAAC;EAC1D,IAAI,CAACH,IAAI,EAAE,MAAMG,kBAAkB,CAAC,CAAC,EAAE,MAAM,CAAC;EAC9C,IAAI,CAAC1B,KAAK,CAACO,CAAC,CAACL,KAAK,CAACoB,UAAU,CAAC,EAAE,MAAMK,WAAW,CAAC,CAAC,EAAE,CAAC,QAAQ,CAAC,EAAEL,UAAU,CAAC;EAC5E,IAAI,CAACtB,KAAK,CAACG,CAAC,CAACD,KAAK,CAACqB,IAAI,CAAC,EAAE,MAAMI,WAAW,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,EAAEJ,IAAI,CAAC;EAC/D,IAAMK,OAAO,GAAGN,UAAU,CAACO,KAAK,CAAC,GAAG,CAAC;EACrC,IAAMZ,KAAK,GAAG,CAAC,CAAC;EAEhBW,OAAO,CAACE,OAAO,CAAC,UAAAd,MAAM,EAAI;IACxB,KAAK,IAAIe,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGf,MAAM,CAACG,MAAM,EAAE,EAAEY,EAAE,EAAE;MACzC,IAAMC,IAAI,GAAGhB,MAAM,CAACe,EAAE,CAAC;MACvB,IAAI,CAAC/B,KAAK,CAACgC,IAAI,CAAC,EAAE,MAAMC,WAAW,CAACF,EAAE,EAAEC,IAAI,CAAC;IAC/C;IACA,IAAI,MAAM,CAACE,IAAI,CAAClB,MAAM,CAAC,EAAE,MAAMmB,gBAAgB,CAACnB,MAAM,CAAC;IACvDD,SAAS,CAACC,MAAM,EAAEC,KAAK,CAAC;IACxB,IAAI,GAAG,CAACiB,IAAI,CAAClB,MAAM,CAAC,EAAE;MACpBD,SAAS,CAACC,MAAM,CAACoB,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,EAAEnB,KAAK,CAAC;MAC7CF,SAAS,CAACC,MAAM,CAACoB,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,EAAEnB,KAAK,CAAC;MAC1C,IAAID,MAAM,CAACG,MAAM,KAAK,CAAC,EAAEJ,SAAS,CAAC,EAAE,EAAEE,KAAK,CAAC;IAC/C;EACF,CAAC,CAAC;EACF,IAAIoB,QAAQ,GAAGpB,KAAK,CAACM,IAAI,CAACJ,MAAM,CAAC;EACjC,IAAI,CAACkB,QAAQ,EAAE;IACb,MAAMZ,iBAAiB,CAACa,MAAM,CAACC,IAAI,CAACtB,KAAK,CAAC,EAAEM,IAAI,CAACJ,MAAM,CAAC;EAC1D;EAAC,IAAAqB,KAAA,YAAAA,MAAAT,EAAA,EACwC;IACvC,IAAIU,WAAW,GAAGJ,QAAQ,CAACK,MAAM,CAAC,UAAA1B,MAAM,EAAI;MAC1C,IAAMgB,IAAI,GAAGhB,MAAM,CAACe,EAAE,CAAC;MACvB,IAAMY,SAAS,GAAG3C,KAAK,CAACgC,IAAI,CAAC,CAAC9B,KAAK;MACnC,OAAOyC,SAAS,CAACpB,IAAI,CAACQ,EAAE,CAAC,CAAC;IAC5B,CAAC,CAAC;IACF,IAAI,CAACU,WAAW,CAACtB,MAAM,EAAE;MACvB,IAAMyB,MAAM,GAAGP,QAAQ,CAACQ,GAAG,CAAC,UAAAzC,CAAC;QAAA,OAAIJ,KAAK,CAACI,CAAC,CAAC2B,EAAE,CAAC,CAAC,CAAC9B,KAAK;MAAA,EAAC,CAACyC,MAAM,CAAC,UAAAtC,CAAC;QAAA,OAAIA,CAAC,IAAI,IAAI;MAAA,EAAC;MAC3E,MAAMuB,WAAW,CAACI,EAAE,EAAEa,MAAM,EAAErB,IAAI,CAACQ,EAAE,CAAC,CAAC;IACzC;IACAM,QAAQ,GAAGI,WAAW;EACxB,CAAC;EAXD,KAAK,IAAIV,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGR,IAAI,CAACJ,MAAM,EAAE,EAAEY,EAAE;IAAAS,KAAA,CAAAT,EAAA;EAAA;AAYzC;AAEA,SAASL,kBAAkBA,CAAEoB,GAAG,EAAE;EAChC,OAAOC,YAAY,CAAC,aAAa,EAAE,6BAA6B,IAAID,GAAG,GAAG,CAAC,CAAC,CAAC;AAC/E;AAEA,SAASb,WAAWA,CAAEa,GAAG,EAAEd,IAAI,EAAE;EAC/B,OAAOe,YAAY,CAAC,cAAc,EAAE,eAAe,GAAGf,IAAI,GAAG,gBAAgB,IAAIc,GAAG,GAAG,CAAC,CAAC,CAAC;AAC5F;AAEA,SAASnB,WAAWA,CAAEmB,GAAG,EAAEE,aAAa,EAAEC,KAAK,EAAE;EAC/C,IAAIC,SAAS;EACbZ,MAAM,CAACC,IAAI,CAACvC,KAAK,CAAC,CAAC8B,OAAO,CAAC,UAAAqB,QAAQ,EAAI;IACrC,IAAInD,KAAK,CAACmD,QAAQ,CAAC,CAACjD,KAAK,CAAC+C,KAAK,CAAC,EAAEC,SAAS,GAAGlD,KAAK,CAACmD,QAAQ,CAAC,CAAClD,KAAK;EACrE,CAAC,CAAC;EACF,OAAO8C,YAAY,CAAC,cAAc,EAAE,YAAY,IAAID,GAAG,GAAG,CAAC,CAAC,GAAG,aAAa,GAC1EM,WAAW,CAACJ,aAAa,CAAC,GAAG,WAAW,GAAGE,SAAS,CAAC;AACzD;AAEA,SAASE,WAAWA,CAAEC,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACC,IAAI,CAAC,IAAI,CAAC,CAAClB,OAAO,CAAC,YAAY,EAAE,QAAQ,CAAC;AACxD;AAEA,SAASX,iBAAiBA,CAAE8B,QAAQ,EAAEC,GAAG,EAAE;EACzC,IAAMC,OAAO,GAAGL,WAAW,CAACG,QAAQ,CAAC;EACrC,IAAMhC,IAAI,GAAGgC,QAAQ,CAACG,KAAK,CAAC,UAAAC,EAAE;IAAA,OAAIA,EAAE,CAACxC,MAAM,KAAK,CAAC;EAAA,EAAC,GAC9C,UAAU,GACV,WAAW;EACf,OAAO4B,YAAY,CAAC,gBAAgB,EAAE,WAAW,GAAGU,OAAO,GAAG,GAAG,GAAGlC,IAAI,GAAG,WAAW,GAAGiC,GAAG,CAAC;AAC/F;AAEA,SAASrB,gBAAgBA,CAAEnB,MAAM,EAAE;EACjC,OAAO+B,YAAY,CAAC,oBAAoB,EACtC,iFAAiF,GAAG/B,MAAM,GAAG,GAAG,CAAC;AACrG;AAEA,SAAS+B,YAAYA,CAAEa,IAAI,EAAEC,GAAG,EAAE;EAChC,IAAMC,GAAG,GAAG,IAAIjD,KAAK,CAACgD,GAAG,CAAC;EAC1BC,GAAG,CAACF,IAAI,GAAGA,IAAI;EACf;EACA,IAAI/C,KAAK,CAACkD,iBAAiB,EAAElD,KAAK,CAACkD,iBAAiB,CAACD,GAAG,EAAElE,QAAQ,CAAC;EACnE,OAAOkE,GAAG;AACZ"},"metadata":{},"sourceType":"script"}