{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar AbstractConnectionManager = require(\"../abstract/connection-manager\");\nvar sequelizeErrors = require(\"../../errors\");\nvar _require = require(\"../../utils/logger\"),\n  logger = _require.logger;\nvar DataTypes = require(\"../../data-types\").db2;\nvar debug = logger.debugContext(\"connection:db2\");\nvar parserStore = require(\"../parserStore\")(\"db2\");\nvar ConnectionManager = /*#__PURE__*/function (_AbstractConnectionMa) {\n  _inherits(ConnectionManager, _AbstractConnectionMa);\n  var _super = _createSuper(ConnectionManager);\n  function ConnectionManager(dialect, sequelize) {\n    var _this;\n    _classCallCheck(this, ConnectionManager);\n    sequelize.config.port = sequelize.config.port || 3306;\n    _this = _super.call(this, dialect, sequelize);\n    _this.lib = _this._loadDialectModule(\"ibm_db\");\n    _this.refreshTypeParser(DataTypes);\n    return _this;\n  }\n  _createClass(ConnectionManager, [{\n    key: \"_refreshTypeParser\",\n    value: function _refreshTypeParser(dataType) {\n      parserStore.refresh(dataType);\n    }\n  }, {\n    key: \"_clearTypeParser\",\n    value: function _clearTypeParser() {\n      parserStore.clear();\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {\n        var _this2 = this;\n        var connectionConfig, _i, _Object$keys, key, connection;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              connectionConfig = {\n                database: config.database,\n                hostname: config.host,\n                port: config.port,\n                uid: config.username,\n                pwd: config.password\n              };\n              if (config.ssl) {\n                connectionConfig[\"security\"] = config.ssl;\n              }\n              if (config.sslcertificate) {\n                connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n              }\n              if (config.dialectOptions) {\n                for (_i = 0, _Object$keys = Object.keys(config.dialectOptions); _i < _Object$keys.length; _i++) {\n                  key = _Object$keys[_i];\n                  connectionConfig[key] = config.dialectOptions[key];\n                }\n              }\n              _context.prev = 4;\n              _context.next = 7;\n              return new Promise(function (resolve, reject) {\n                var connection2 = new _this2.lib.Database();\n                connection2.lib = _this2.lib;\n                connection2.open(connectionConfig, function (error) {\n                  if (error) {\n                    if (error.message && error.message.includes(\"SQL30081N\")) {\n                      return reject(new sequelizeErrors.ConnectionRefusedError(error));\n                    }\n                    return reject(new sequelizeErrors.ConnectionError(error));\n                  }\n                  return resolve(connection2);\n                });\n              });\n            case 7:\n              connection = _context.sent;\n              return _context.abrupt(\"return\", connection);\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](4);\n              throw new sequelizeErrors.ConnectionError(_context.t0);\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[4, 11]]);\n      }));\n      function connect(_x) {\n        return _connect.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(connection) {\n      if (connection.connected) {\n        connection.close(function (error) {\n          if (error) {\n            debug(error);\n          } else {\n            debug(\"connection closed\");\n          }\n        });\n      }\n      return Promise.resolve();\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(connection) {\n      return connection && connection.connected;\n    }\n  }, {\n    key: \"_disconnect\",\n    value: function _disconnect(connection) {\n      return this.dialect.connectionManager.disconnect(connection);\n    }\n  }], [{\n    key: \"_typecast\",\n    value: function _typecast(field, next) {\n      if (parserStore.get(field.type)) {\n        return parserStore.get(field.type)(field, this.sequelize.options, next);\n      }\n      return next();\n    }\n  }]);\n  return ConnectionManager;\n}(AbstractConnectionManager);\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["AbstractConnectionManager","require","sequelizeErrors","_require","logger","DataTypes","db2","debug","debugContext","parserStore","ConnectionManager","_AbstractConnectionMa","_inherits","_super","_createSuper","dialect","sequelize","_this","_classCallCheck","config","port","call","lib","_loadDialectModule","refreshTypeParser","_createClass","key","value","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","_connect","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this2","connectionConfig","_i","_Object$keys","connection","wrap","_callee$","_context","prev","next","database","hostname","host","uid","username","pwd","password","ssl","sslcertificate","dialectOptions","Object","keys","length","Promise","resolve","reject","connection2","Database","open","error","message","includes","ConnectionRefusedError","ConnectionError","sent","abrupt","t0","stop","connect","_x","apply","arguments","disconnect","connected","close","validate","_disconnect","connectionManager","_typecast","field","get","type","options","module","exports","default"],"sources":["../../../src/dialects/db2/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst sequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').db2;\nconst debug = logger.debugContext('connection:db2');\nconst parserStore = require('../parserStore')('db2');\n\n/**\n * DB2 Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle DB2 specific connections\n * Use https://github.com/ibmdb/node-ibm_db to connect with DB2 server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('ibm_db');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with DB2 database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n\n    if (config.ssl) {\n      connectionConfig['security'] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig['SSLServerCertificate'] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection = new this.lib.Database();\n        connection.lib = this.lib;\n        connection.open(connectionConfig, error => {\n          if (error) {\n            if (error.message && error.message.includes('SQL30081N')) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n\n  disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.connected) {\n      connection.close(error => {\n        if (error) { debug(error); }\n        else { debug('connection closed'); }\n      });\n    }\n    return Promise.resolve();\n  }\n\n  validate(connection) {\n    return connection && connection.connected;\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}