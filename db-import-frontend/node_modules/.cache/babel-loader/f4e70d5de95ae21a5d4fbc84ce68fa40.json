{"ast":null,"code":"var _toConsumableArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nvar assert = require('assert');\nvar normalize = require('./normalize-unicode.js');\nvar stripSlashes = require('./strip-trailing-slashes.js');\nvar _require = require('path'),\n  join = _require.join;\nvar platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nvar isWindows = platform === 'win32';\nmodule.exports = function () {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  var queues = new Map();\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  var reservations = new Map();\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  var getDirs = function getDirs(path) {\n    var dirs = path.split('/').slice(0, -1).reduce(function (set, path) {\n      if (set.length) {\n        path = join(set[set.length - 1], path);\n      }\n      set.push(path || '/');\n      return set;\n    }, []);\n    return dirs;\n  };\n\n  // functions currently running\n  var running = new Set();\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  var getQueues = function getQueues(fn) {\n    var res = reservations.get(fn);\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations');\n    }\n    return {\n      paths: res.paths.map(function (path) {\n        return queues.get(path);\n      }),\n      dirs: _toConsumableArray(res.dirs).map(function (path) {\n        return queues.get(path);\n      })\n    };\n  };\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  var check = function check(fn) {\n    var _getQueues = getQueues(fn),\n      paths = _getQueues.paths,\n      dirs = _getQueues.dirs;\n    return paths.every(function (q) {\n      return q[0] === fn;\n    }) && dirs.every(function (q) {\n      return q[0] instanceof Set && q[0].has(fn);\n    });\n  };\n\n  // run the function if it's first in line and not already running\n  var run = function run(fn) {\n    if (running.has(fn) || !check(fn)) {\n      return false;\n    }\n    running.add(fn);\n    fn(function () {\n      return clear(fn);\n    });\n    return true;\n  };\n  var clear = function clear(fn) {\n    if (!running.has(fn)) {\n      return false;\n    }\n    var _reservations$get = reservations.get(fn),\n      paths = _reservations$get.paths,\n      dirs = _reservations$get.dirs;\n    var next = new Set();\n    paths.forEach(function (path) {\n      var q = queues.get(path);\n      assert.equal(q[0], fn);\n      if (q.length === 1) {\n        queues.delete(path);\n      } else {\n        q.shift();\n        if (typeof q[0] === 'function') {\n          next.add(q[0]);\n        } else {\n          q[0].forEach(function (fn) {\n            return next.add(fn);\n          });\n        }\n      }\n    });\n    dirs.forEach(function (dir) {\n      var q = queues.get(dir);\n      assert(q[0] instanceof Set);\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir);\n      } else if (q[0].size === 1) {\n        q.shift();\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0]);\n      } else {\n        q[0].delete(fn);\n      }\n    });\n    running.delete(fn);\n    next.forEach(function (fn) {\n      return run(fn);\n    });\n    return true;\n  };\n  var reserve = function reserve(paths, fn) {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(function (p) {\n      // don't need normPath, because we skip this entirely for windows\n      return stripSlashes(join(normalize(p))).toLowerCase();\n    });\n    var dirs = new Set(paths.map(function (path) {\n      return getDirs(path);\n    }).reduce(function (a, b) {\n      return a.concat(b);\n    }));\n    reservations.set(fn, {\n      dirs: dirs,\n      paths: paths\n    });\n    paths.forEach(function (path) {\n      var q = queues.get(path);\n      if (!q) {\n        queues.set(path, [fn]);\n      } else {\n        q.push(fn);\n      }\n    });\n    dirs.forEach(function (dir) {\n      var q = queues.get(dir);\n      if (!q) {\n        queues.set(dir, [new Set([fn])]);\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn);\n      } else {\n        q.push(new Set([fn]));\n      }\n    });\n    return run(fn);\n  };\n  return {\n    check: check,\n    reserve: reserve\n  };\n};","map":{"version":3,"names":["assert","require","normalize","stripSlashes","_require","join","platform","process","env","TESTING_TAR_FAKE_PLATFORM","isWindows","module","exports","queues","Map","reservations","getDirs","path","dirs","split","slice","reduce","set","length","push","running","Set","getQueues","fn","res","get","Error","paths","map","_toConsumableArray","check","_getQueues","every","q","has","run","add","clear","_reservations$get","next","forEach","equal","delete","shift","dir","size","reserve","p","toLowerCase","a","b","concat"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/tar/lib/path-reservations.js"],"sourcesContent":["// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\nconst normalize = require('./normalize-unicode.js')\nconst stripSlashes = require('./strip-trailing-slashes.js')\nconst { join } = require('path')\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const { paths, dirs } = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false\n    }\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false\n    }\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1) {\n        queues.delete(path)\n      } else {\n        q.shift()\n        if (typeof q[0] === 'function') {\n          next.add(q[0])\n        } else {\n          q[0].forEach(fn => next.add(fn))\n        }\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else {\n        q[0].delete(fn)\n      }\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return stripSlashes(join(normalize(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, { dirs, paths })\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q) {\n        queues.set(path, [fn])\n      } else {\n        q.push(fn)\n      }\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q) {\n        queues.set(dir, [new Set([fn])])\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn)\n      } else {\n        q.push(new Set([fn]))\n      }\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}