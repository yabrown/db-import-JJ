{"ast":null,"code":"'use strict';\n\n/**\n * @module nock/intercept\n */\nvar _toConsumableArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require('./intercepted_request_router'),\n  InterceptedRequestRouter = _require.InterceptedRequestRouter;\nvar common = require('./common');\nvar _require2 = require('util'),\n  inherits = _require2.inherits;\nvar http = require('http');\nvar debug = require('debug')('nock.intercept');\nvar globalEmitter = require('./global_emitter');\n\n/**\n * @name NetConnectNotAllowedError\n * @private\n * @desc Error trying to make a connection when disabled external access.\n * @class\n * @example\n * nock.disableNetConnect();\n * http.get('http://zombo.com');\n * // throw NetConnectNotAllowedError\n */\nfunction NetConnectNotAllowedError(host, path) {\n  Error.call(this);\n  this.name = 'NetConnectNotAllowedError';\n  this.code = 'ENETUNREACH';\n  this.message = \"Nock: Disallowed net connect for \\\"\".concat(host).concat(path, \"\\\"\");\n  Error.captureStackTrace(this, this.constructor);\n}\ninherits(NetConnectNotAllowedError, Error);\nvar allInterceptors = {};\nvar allowNetConnect;\n\n/**\n * Enabled real request.\n * @public\n * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match\n * @example\n * // Enables all real requests\n * nock.enableNetConnect();\n * @example\n * // Enables real requests for url that matches google\n * nock.enableNetConnect('google');\n * @example\n * // Enables real requests for url that matches google and amazon\n * nock.enableNetConnect(/(google|amazon)/);\n * @example\n * // Enables real requests for url that includes google\n * nock.enableNetConnect(host => host.includes('google'));\n */\nfunction enableNetConnect(matcher) {\n  if (typeof matcher === 'string') {\n    allowNetConnect = new RegExp(matcher);\n  } else if (matcher instanceof RegExp) {\n    allowNetConnect = matcher;\n  } else if (typeof matcher === 'function') {\n    allowNetConnect = {\n      test: matcher\n    };\n  } else {\n    allowNetConnect = /.*/;\n  }\n}\nfunction isEnabledForNetConnect(options) {\n  common.normalizeRequestOptions(options);\n  var enabled = allowNetConnect && allowNetConnect.test(options.host);\n  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host);\n  return enabled;\n}\n\n/**\n * Disable all real requests.\n * @public\n * @example\n * nock.disableNetConnect();\n */\nfunction disableNetConnect() {\n  allowNetConnect = undefined;\n}\nfunction isOn() {\n  return !isOff();\n}\nfunction isOff() {\n  return process.env.NOCK_OFF === 'true';\n}\nfunction addInterceptor(key, interceptor, scope, scopeOptions, host) {\n  if (!(key in allInterceptors)) {\n    allInterceptors[key] = {\n      key: key,\n      interceptors: []\n    };\n  }\n  interceptor.__nock_scope = scope;\n\n  //  We need scope's key and scope options for scope filtering function (if defined)\n  interceptor.__nock_scopeKey = key;\n  interceptor.__nock_scopeOptions = scopeOptions;\n  //  We need scope's host for setting correct request headers for filtered scopes.\n  interceptor.__nock_scopeHost = host;\n  interceptor.interceptionCounter = 0;\n  if (scopeOptions.allowUnmocked) allInterceptors[key].allowUnmocked = true;\n  allInterceptors[key].interceptors.push(interceptor);\n}\nfunction remove(interceptor) {\n  if (interceptor.__nock_scope.shouldPersist() || --interceptor.counter > 0) {\n    return;\n  }\n  var basePath = interceptor.basePath;\n  var interceptors = allInterceptors[basePath] && allInterceptors[basePath].interceptors || [];\n\n  // TODO: There is a clearer way to write that we want to delete the first\n  // matching instance. I'm also not sure why we couldn't delete _all_\n  // matching instances.\n  interceptors.some(function (thisInterceptor, i) {\n    return thisInterceptor === interceptor ? interceptors.splice(i, 1) : false;\n  });\n}\nfunction removeAll() {\n  Object.keys(allInterceptors).forEach(function (key) {\n    allInterceptors[key].interceptors.forEach(function (interceptor) {\n      interceptor.scope.keyedInterceptors = {};\n    });\n  });\n  allInterceptors = {};\n}\n\n/**\n * Return all the Interceptors whose Scopes match against the base path of the provided options.\n *\n * @returns {Interceptor[]}\n */\nfunction interceptorsFor(options) {\n  common.normalizeRequestOptions(options);\n  debug('interceptors for %j', options.host);\n  var basePath = \"\".concat(options.proto, \"://\").concat(options.host);\n  debug('filtering interceptors for basepath', basePath);\n\n  // First try to use filteringScope if any of the interceptors has it defined.\n  for (var _i = 0, _Object$values = Object.values(allInterceptors); _i < _Object$values.length; _i++) {\n    var _Object$values$_i = _Object$values[_i],\n      key = _Object$values$_i.key,\n      interceptors = _Object$values$_i.interceptors,\n      allowUnmocked = _Object$values$_i.allowUnmocked;\n    var _iterator = _createForOfIteratorHelper(interceptors),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var interceptor = _step.value;\n        var filteringScope = interceptor.__nock_scopeOptions.filteringScope;\n\n        // If scope filtering function is defined and returns a truthy value then\n        // we have to treat this as a match.\n        if (filteringScope && filteringScope(basePath)) {\n          interceptor.scope.logger('found matching scope interceptor');\n\n          // Keep the filtered scope (its key) to signal the rest of the module\n          // that this wasn't an exact but filtered match.\n          interceptors.forEach(function (ic) {\n            ic.__nock_filteredScope = ic.__nock_scopeKey;\n          });\n          return interceptors;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (common.matchStringOrRegexp(basePath, key)) {\n      if (allowUnmocked && interceptors.length === 0) {\n        debug('matched base path with allowUnmocked (no matching interceptors)');\n        return [{\n          options: {\n            allowUnmocked: true\n          },\n          matchOrigin: function matchOrigin() {\n            return false;\n          }\n        }];\n      } else {\n        debug(\"matched base path (\".concat(interceptors.length, \" interceptor\").concat(interceptors.length > 1 ? 's' : '', \")\"));\n        return interceptors;\n      }\n    }\n  }\n  return undefined;\n}\nfunction removeInterceptor(options) {\n  // Lazily import to avoid circular imports.\n  var Interceptor = require('./interceptor');\n  var baseUrl, key, method, proto;\n  if (options instanceof Interceptor) {\n    baseUrl = options.basePath;\n    key = options._key;\n  } else {\n    proto = options.proto ? options.proto : 'http';\n    common.normalizeRequestOptions(options);\n    baseUrl = \"\".concat(proto, \"://\").concat(options.host);\n    method = options.method && options.method.toUpperCase() || 'GET';\n    key = \"\".concat(method, \" \").concat(baseUrl).concat(options.path || '/');\n  }\n  if (allInterceptors[baseUrl] && allInterceptors[baseUrl].interceptors.length > 0) {\n    for (var i = 0; i < allInterceptors[baseUrl].interceptors.length; i++) {\n      var interceptor = allInterceptors[baseUrl].interceptors[i];\n      if (interceptor._key === key) {\n        allInterceptors[baseUrl].interceptors.splice(i, 1);\n        interceptor.scope.remove(key, interceptor);\n        break;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n//  Variable where we keep the ClientRequest we have overridden\n//  (which might or might not be node's original http.ClientRequest)\nvar originalClientRequest;\nfunction ErroringClientRequest(error) {\n  http.OutgoingMessage.call(this);\n  process.nextTick(function () {\n    this.emit('error', error);\n  }.bind(this));\n}\ninherits(ErroringClientRequest, http.ClientRequest);\nfunction overrideClientRequest() {\n  // Here's some background discussion about overriding ClientRequest:\n  // - https://github.com/nodejitsu/mock-request/issues/4\n  // - https://github.com/nock/nock/issues/26\n  // It would be good to add a comment that explains this more clearly.\n  debug('Overriding ClientRequest');\n\n  // ----- Extending http.ClientRequest\n\n  //  Define the overriding client request that nock uses internally.\n  function OverriddenClientRequest() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var _common$normalizeClie = common.normalizeClientRequestArgs.apply(common, args),\n      options = _common$normalizeClie.options,\n      callback = _common$normalizeClie.callback;\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `http[s].request()`, nock's other\n      // client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error('Creating a ClientRequest with empty `options` is not supported in Nock');\n    }\n    http.OutgoingMessage.call(this);\n\n    //  Filter the interceptors per request options.\n    var interceptors = interceptorsFor(options);\n    if (isOn() && interceptors) {\n      debug('using', interceptors.length, 'interceptors');\n\n      //  Use filtered interceptors to intercept requests.\n      // TODO: this shouldn't be a class anymore\n      // the overrider explicitly overrides methods and attrs on the request so the `assign` below should be removed.\n      var overrider = new InterceptedRequestRouter({\n        req: this,\n        options: options,\n        interceptors: interceptors\n      });\n      Object.assign(this, overrider);\n      if (callback) {\n        this.once('response', callback);\n      }\n    } else {\n      debug('falling back to original ClientRequest');\n\n      //  Fallback to original ClientRequest if nock is off or the net connection is enabled.\n      if (isOff() || isEnabledForNetConnect(options)) {\n        originalClientRequest.apply(this, arguments);\n      } else {\n        common.setImmediate(function () {\n          var error = new NetConnectNotAllowedError(options.host, options.path);\n          this.emit('error', error);\n        }.bind(this));\n      }\n    }\n  }\n  inherits(OverriddenClientRequest, http.ClientRequest);\n\n  //  Override the http module's request but keep the original so that we can use it and later restore it.\n  //  NOTE: We only override http.ClientRequest as https module also uses it.\n  originalClientRequest = http.ClientRequest;\n  http.ClientRequest = OverriddenClientRequest;\n  debug('ClientRequest overridden');\n}\nfunction restoreOverriddenClientRequest() {\n  debug('restoring overridden ClientRequest');\n\n  //  Restore the ClientRequest we have overridden.\n  if (!originalClientRequest) {\n    debug('- ClientRequest was not overridden');\n  } else {\n    http.ClientRequest = originalClientRequest;\n    originalClientRequest = undefined;\n    debug('- ClientRequest restored');\n  }\n}\nfunction isActive() {\n  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.\n  //  This means that Nock has been activated.\n  return originalClientRequest !== undefined;\n}\nfunction interceptorScopes() {\n  var _ref;\n  var nestedInterceptors = Object.values(allInterceptors).map(function (i) {\n    return i.interceptors;\n  });\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(nestedInterceptors)).map(function (i) {\n    return i.scope;\n  });\n}\nfunction isDone() {\n  return interceptorScopes().every(function (scope) {\n    return scope.isDone();\n  });\n}\nfunction pendingMocks() {\n  var _ref2;\n  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(interceptorScopes().map(function (scope) {\n    return scope.pendingMocks();\n  })));\n}\nfunction activeMocks() {\n  var _ref3;\n  return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(interceptorScopes().map(function (scope) {\n    return scope.activeMocks();\n  })));\n}\nfunction activate() {\n  if (originalClientRequest) {\n    throw new Error('Nock already active');\n  }\n  overrideClientRequest();\n\n  // ----- Overriding http.request and https.request:\n\n  common.overrideRequests(function (proto, overriddenRequest, args) {\n    //  NOTE: overriddenRequest is already bound to its module.\n\n    var _common$normalizeClie2 = common.normalizeClientRequestArgs.apply(common, _toConsumableArray(args)),\n      options = _common$normalizeClie2.options,\n      callback = _common$normalizeClie2.callback;\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `new ClientRequest()`, nock's\n      // other client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error('Making a request with empty `options` is not supported in Nock');\n    }\n\n    // The option per the docs is `protocol`. Its unclear if this line is meant to override that and is misspelled or if\n    // the intend is to explicitly keep track of which module was called using a separate name.\n    // Either way, `proto` is used as the source of truth from here on out.\n    options.proto = proto;\n    var interceptors = interceptorsFor(options);\n    if (isOn() && interceptors) {\n      var matches = interceptors.some(function (interceptor) {\n        return interceptor.matchOrigin(options);\n      });\n      var allowUnmocked = interceptors.some(function (interceptor) {\n        return interceptor.options.allowUnmocked;\n      });\n      if (!matches && allowUnmocked) {\n        var req;\n        if (proto === 'https') {\n          var ClientRequest = http.ClientRequest;\n          http.ClientRequest = originalClientRequest;\n          req = overriddenRequest(options, callback);\n          http.ClientRequest = ClientRequest;\n        } else {\n          req = overriddenRequest(options, callback);\n        }\n        globalEmitter.emit('no match', req);\n        return req;\n      }\n\n      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing\n      //    our own OverriddenClientRequest.\n      return new http.ClientRequest(options, callback);\n    } else {\n      globalEmitter.emit('no match', options);\n      if (isOff() || isEnabledForNetConnect(options)) {\n        return overriddenRequest(options, callback);\n      } else {\n        var error = new NetConnectNotAllowedError(options.host, options.path);\n        return new ErroringClientRequest(error);\n      }\n    }\n  });\n}\nmodule.exports = {\n  addInterceptor: addInterceptor,\n  remove: remove,\n  removeAll: removeAll,\n  removeInterceptor: removeInterceptor,\n  isOn: isOn,\n  activate: activate,\n  isActive: isActive,\n  isDone: isDone,\n  pendingMocks: pendingMocks,\n  activeMocks: activeMocks,\n  enableNetConnect: enableNetConnect,\n  disableNetConnect: disableNetConnect,\n  restoreOverriddenClientRequest: restoreOverriddenClientRequest,\n  abortPendingRequests: common.removeAllTimers\n};","map":{"version":3,"names":["_toConsumableArray","require","default","_createForOfIteratorHelper","_require","InterceptedRequestRouter","common","_require2","inherits","http","debug","globalEmitter","NetConnectNotAllowedError","host","path","Error","call","name","code","message","concat","captureStackTrace","constructor","allInterceptors","allowNetConnect","enableNetConnect","matcher","RegExp","test","isEnabledForNetConnect","options","normalizeRequestOptions","enabled","disableNetConnect","undefined","isOn","isOff","process","env","NOCK_OFF","addInterceptor","key","interceptor","scope","scopeOptions","interceptors","__nock_scope","__nock_scopeKey","__nock_scopeOptions","__nock_scopeHost","interceptionCounter","allowUnmocked","push","remove","shouldPersist","counter","basePath","some","thisInterceptor","i","splice","removeAll","Object","keys","forEach","keyedInterceptors","interceptorsFor","proto","_i","_Object$values","values","length","_Object$values$_i","_iterator","_step","s","n","done","value","filteringScope","logger","ic","__nock_filteredScope","err","e","f","matchStringOrRegexp","matchOrigin","removeInterceptor","Interceptor","baseUrl","method","_key","toUpperCase","originalClientRequest","ErroringClientRequest","error","OutgoingMessage","nextTick","emit","bind","ClientRequest","overrideClientRequest","OverriddenClientRequest","_len","arguments","args","Array","_common$normalizeClie","normalizeClientRequestArgs","apply","callback","overrider","req","assign","once","setImmediate","restoreOverriddenClientRequest","isActive","interceptorScopes","_ref","nestedInterceptors","map","isDone","every","pendingMocks","_ref2","activeMocks","_ref3","activate","overrideRequests","overriddenRequest","_common$normalizeClie2","matches","module","exports","abortPendingRequests","removeAllTimers"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/nock/lib/intercept.js"],"sourcesContent":["'use strict'\n\n/**\n * @module nock/intercept\n */\n\nconst { InterceptedRequestRouter } = require('./intercepted_request_router')\nconst common = require('./common')\nconst { inherits } = require('util')\nconst http = require('http')\nconst debug = require('debug')('nock.intercept')\nconst globalEmitter = require('./global_emitter')\n\n/**\n * @name NetConnectNotAllowedError\n * @private\n * @desc Error trying to make a connection when disabled external access.\n * @class\n * @example\n * nock.disableNetConnect();\n * http.get('http://zombo.com');\n * // throw NetConnectNotAllowedError\n */\nfunction NetConnectNotAllowedError(host, path) {\n  Error.call(this)\n\n  this.name = 'NetConnectNotAllowedError'\n  this.code = 'ENETUNREACH'\n  this.message = `Nock: Disallowed net connect for \"${host}${path}\"`\n\n  Error.captureStackTrace(this, this.constructor)\n}\n\ninherits(NetConnectNotAllowedError, Error)\n\nlet allInterceptors = {}\nlet allowNetConnect\n\n/**\n * Enabled real request.\n * @public\n * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match\n * @example\n * // Enables all real requests\n * nock.enableNetConnect();\n * @example\n * // Enables real requests for url that matches google\n * nock.enableNetConnect('google');\n * @example\n * // Enables real requests for url that matches google and amazon\n * nock.enableNetConnect(/(google|amazon)/);\n * @example\n * // Enables real requests for url that includes google\n * nock.enableNetConnect(host => host.includes('google'));\n */\nfunction enableNetConnect(matcher) {\n  if (typeof matcher === 'string') {\n    allowNetConnect = new RegExp(matcher)\n  } else if (matcher instanceof RegExp) {\n    allowNetConnect = matcher\n  } else if (typeof matcher === 'function') {\n    allowNetConnect = { test: matcher }\n  } else {\n    allowNetConnect = /.*/\n  }\n}\n\nfunction isEnabledForNetConnect(options) {\n  common.normalizeRequestOptions(options)\n\n  const enabled = allowNetConnect && allowNetConnect.test(options.host)\n  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host)\n  return enabled\n}\n\n/**\n * Disable all real requests.\n * @public\n * @example\n * nock.disableNetConnect();\n */\nfunction disableNetConnect() {\n  allowNetConnect = undefined\n}\n\nfunction isOn() {\n  return !isOff()\n}\n\nfunction isOff() {\n  return process.env.NOCK_OFF === 'true'\n}\n\nfunction addInterceptor(key, interceptor, scope, scopeOptions, host) {\n  if (!(key in allInterceptors)) {\n    allInterceptors[key] = { key, interceptors: [] }\n  }\n  interceptor.__nock_scope = scope\n\n  //  We need scope's key and scope options for scope filtering function (if defined)\n  interceptor.__nock_scopeKey = key\n  interceptor.__nock_scopeOptions = scopeOptions\n  //  We need scope's host for setting correct request headers for filtered scopes.\n  interceptor.__nock_scopeHost = host\n  interceptor.interceptionCounter = 0\n\n  if (scopeOptions.allowUnmocked) allInterceptors[key].allowUnmocked = true\n\n  allInterceptors[key].interceptors.push(interceptor)\n}\n\nfunction remove(interceptor) {\n  if (interceptor.__nock_scope.shouldPersist() || --interceptor.counter > 0) {\n    return\n  }\n\n  const { basePath } = interceptor\n  const interceptors =\n    (allInterceptors[basePath] && allInterceptors[basePath].interceptors) || []\n\n  // TODO: There is a clearer way to write that we want to delete the first\n  // matching instance. I'm also not sure why we couldn't delete _all_\n  // matching instances.\n  interceptors.some(function (thisInterceptor, i) {\n    return thisInterceptor === interceptor ? interceptors.splice(i, 1) : false\n  })\n}\n\nfunction removeAll() {\n  Object.keys(allInterceptors).forEach(function (key) {\n    allInterceptors[key].interceptors.forEach(function (interceptor) {\n      interceptor.scope.keyedInterceptors = {}\n    })\n  })\n  allInterceptors = {}\n}\n\n/**\n * Return all the Interceptors whose Scopes match against the base path of the provided options.\n *\n * @returns {Interceptor[]}\n */\nfunction interceptorsFor(options) {\n  common.normalizeRequestOptions(options)\n\n  debug('interceptors for %j', options.host)\n\n  const basePath = `${options.proto}://${options.host}`\n\n  debug('filtering interceptors for basepath', basePath)\n\n  // First try to use filteringScope if any of the interceptors has it defined.\n  for (const { key, interceptors, allowUnmocked } of Object.values(\n    allInterceptors\n  )) {\n    for (const interceptor of interceptors) {\n      const { filteringScope } = interceptor.__nock_scopeOptions\n\n      // If scope filtering function is defined and returns a truthy value then\n      // we have to treat this as a match.\n      if (filteringScope && filteringScope(basePath)) {\n        interceptor.scope.logger('found matching scope interceptor')\n\n        // Keep the filtered scope (its key) to signal the rest of the module\n        // that this wasn't an exact but filtered match.\n        interceptors.forEach(ic => {\n          ic.__nock_filteredScope = ic.__nock_scopeKey\n        })\n        return interceptors\n      }\n    }\n\n    if (common.matchStringOrRegexp(basePath, key)) {\n      if (allowUnmocked && interceptors.length === 0) {\n        debug('matched base path with allowUnmocked (no matching interceptors)')\n        return [\n          {\n            options: { allowUnmocked: true },\n            matchOrigin() {\n              return false\n            },\n          },\n        ]\n      } else {\n        debug(\n          `matched base path (${interceptors.length} interceptor${\n            interceptors.length > 1 ? 's' : ''\n          })`\n        )\n        return interceptors\n      }\n    }\n  }\n\n  return undefined\n}\n\nfunction removeInterceptor(options) {\n  // Lazily import to avoid circular imports.\n  const Interceptor = require('./interceptor')\n\n  let baseUrl, key, method, proto\n  if (options instanceof Interceptor) {\n    baseUrl = options.basePath\n    key = options._key\n  } else {\n    proto = options.proto ? options.proto : 'http'\n\n    common.normalizeRequestOptions(options)\n    baseUrl = `${proto}://${options.host}`\n    method = (options.method && options.method.toUpperCase()) || 'GET'\n    key = `${method} ${baseUrl}${options.path || '/'}`\n  }\n\n  if (\n    allInterceptors[baseUrl] &&\n    allInterceptors[baseUrl].interceptors.length > 0\n  ) {\n    for (let i = 0; i < allInterceptors[baseUrl].interceptors.length; i++) {\n      const interceptor = allInterceptors[baseUrl].interceptors[i]\n      if (interceptor._key === key) {\n        allInterceptors[baseUrl].interceptors.splice(i, 1)\n        interceptor.scope.remove(key, interceptor)\n        break\n      }\n    }\n\n    return true\n  }\n\n  return false\n}\n//  Variable where we keep the ClientRequest we have overridden\n//  (which might or might not be node's original http.ClientRequest)\nlet originalClientRequest\n\nfunction ErroringClientRequest(error) {\n  http.OutgoingMessage.call(this)\n  process.nextTick(\n    function () {\n      this.emit('error', error)\n    }.bind(this)\n  )\n}\n\ninherits(ErroringClientRequest, http.ClientRequest)\n\nfunction overrideClientRequest() {\n  // Here's some background discussion about overriding ClientRequest:\n  // - https://github.com/nodejitsu/mock-request/issues/4\n  // - https://github.com/nock/nock/issues/26\n  // It would be good to add a comment that explains this more clearly.\n  debug('Overriding ClientRequest')\n\n  // ----- Extending http.ClientRequest\n\n  //  Define the overriding client request that nock uses internally.\n  function OverriddenClientRequest(...args) {\n    const { options, callback } = common.normalizeClientRequestArgs(...args)\n\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `http[s].request()`, nock's other\n      // client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error(\n        'Creating a ClientRequest with empty `options` is not supported in Nock'\n      )\n    }\n\n    http.OutgoingMessage.call(this)\n\n    //  Filter the interceptors per request options.\n    const interceptors = interceptorsFor(options)\n\n    if (isOn() && interceptors) {\n      debug('using', interceptors.length, 'interceptors')\n\n      //  Use filtered interceptors to intercept requests.\n      // TODO: this shouldn't be a class anymore\n      // the overrider explicitly overrides methods and attrs on the request so the `assign` below should be removed.\n      const overrider = new InterceptedRequestRouter({\n        req: this,\n        options,\n        interceptors,\n      })\n      Object.assign(this, overrider)\n\n      if (callback) {\n        this.once('response', callback)\n      }\n    } else {\n      debug('falling back to original ClientRequest')\n\n      //  Fallback to original ClientRequest if nock is off or the net connection is enabled.\n      if (isOff() || isEnabledForNetConnect(options)) {\n        originalClientRequest.apply(this, arguments)\n      } else {\n        common.setImmediate(\n          function () {\n            const error = new NetConnectNotAllowedError(\n              options.host,\n              options.path\n            )\n            this.emit('error', error)\n          }.bind(this)\n        )\n      }\n    }\n  }\n  inherits(OverriddenClientRequest, http.ClientRequest)\n\n  //  Override the http module's request but keep the original so that we can use it and later restore it.\n  //  NOTE: We only override http.ClientRequest as https module also uses it.\n  originalClientRequest = http.ClientRequest\n  http.ClientRequest = OverriddenClientRequest\n\n  debug('ClientRequest overridden')\n}\n\nfunction restoreOverriddenClientRequest() {\n  debug('restoring overridden ClientRequest')\n\n  //  Restore the ClientRequest we have overridden.\n  if (!originalClientRequest) {\n    debug('- ClientRequest was not overridden')\n  } else {\n    http.ClientRequest = originalClientRequest\n    originalClientRequest = undefined\n\n    debug('- ClientRequest restored')\n  }\n}\n\nfunction isActive() {\n  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.\n  //  This means that Nock has been activated.\n  return originalClientRequest !== undefined\n}\n\nfunction interceptorScopes() {\n  const nestedInterceptors = Object.values(allInterceptors).map(\n    i => i.interceptors\n  )\n  return [].concat(...nestedInterceptors).map(i => i.scope)\n}\n\nfunction isDone() {\n  return interceptorScopes().every(scope => scope.isDone())\n}\n\nfunction pendingMocks() {\n  return [].concat(...interceptorScopes().map(scope => scope.pendingMocks()))\n}\n\nfunction activeMocks() {\n  return [].concat(...interceptorScopes().map(scope => scope.activeMocks()))\n}\n\nfunction activate() {\n  if (originalClientRequest) {\n    throw new Error('Nock already active')\n  }\n\n  overrideClientRequest()\n\n  // ----- Overriding http.request and https.request:\n\n  common.overrideRequests(function (proto, overriddenRequest, args) {\n    //  NOTE: overriddenRequest is already bound to its module.\n\n    const { options, callback } = common.normalizeClientRequestArgs(...args)\n\n    if (Object.keys(options).length === 0) {\n      // As weird as it is, it's possible to call `http.request` without\n      // options, and it makes a request to localhost or somesuch. We should\n      // support it too, for parity. However it doesn't work today, and fixing\n      // it seems low priority. Giving an explicit error is nicer than\n      // crashing with a weird stack trace. `new ClientRequest()`, nock's\n      // other client-facing entry point, makes a similar check.\n      // https://github.com/nock/nock/pull/1386\n      // https://github.com/nock/nock/pull/1440\n      throw Error(\n        'Making a request with empty `options` is not supported in Nock'\n      )\n    }\n\n    // The option per the docs is `protocol`. Its unclear if this line is meant to override that and is misspelled or if\n    // the intend is to explicitly keep track of which module was called using a separate name.\n    // Either way, `proto` is used as the source of truth from here on out.\n    options.proto = proto\n\n    const interceptors = interceptorsFor(options)\n\n    if (isOn() && interceptors) {\n      const matches = interceptors.some(interceptor =>\n        interceptor.matchOrigin(options)\n      )\n      const allowUnmocked = interceptors.some(\n        interceptor => interceptor.options.allowUnmocked\n      )\n\n      if (!matches && allowUnmocked) {\n        let req\n        if (proto === 'https') {\n          const { ClientRequest } = http\n          http.ClientRequest = originalClientRequest\n          req = overriddenRequest(options, callback)\n          http.ClientRequest = ClientRequest\n        } else {\n          req = overriddenRequest(options, callback)\n        }\n        globalEmitter.emit('no match', req)\n        return req\n      }\n\n      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing\n      //    our own OverriddenClientRequest.\n      return new http.ClientRequest(options, callback)\n    } else {\n      globalEmitter.emit('no match', options)\n      if (isOff() || isEnabledForNetConnect(options)) {\n        return overriddenRequest(options, callback)\n      } else {\n        const error = new NetConnectNotAllowedError(options.host, options.path)\n        return new ErroringClientRequest(error)\n      }\n    }\n  })\n}\n\nmodule.exports = {\n  addInterceptor,\n  remove,\n  removeAll,\n  removeInterceptor,\n  isOn,\n  activate,\n  isActive,\n  isDone,\n  pendingMocks,\n  activeMocks,\n  enableNetConnect,\n  disableNetConnect,\n  restoreOverriddenClientRequest,\n  abortPendingRequests: common.removeAllTimers,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}