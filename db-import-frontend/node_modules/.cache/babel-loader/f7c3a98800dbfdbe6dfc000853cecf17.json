{"ast":null,"code":"import _defineProperty from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo } from \"./operationHelpers\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport var serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var stringifyXML = options.stringifyXML;\n  return {\n    name: serializationPolicyName,\n    sendRequest: function sendRequest(request, next) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var operationInfo, operationSpec, operationArguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              operationInfo = getOperationRequestInfo(request);\n              operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n              operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n              if (operationSpec && operationArguments) {\n                serializeHeaders(request, operationArguments, operationSpec);\n                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n              }\n              return _context.abrupt(\"return\", next(request));\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    }\n  };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n  var _a, _b;\n  if (operationSpec.headerParameters) {\n    var _iterator = _createForOfIteratorHelper(operationSpec.headerParameters),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var headerParameter = _step.value;\n        var headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n        if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {\n          headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n          var headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n          if (headerCollectionPrefix) {\n            for (var _i = 0, _Object$keys = Object.keys(headerValue); _i < _Object$keys.length; _i++) {\n              var key = _Object$keys[_i];\n              request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n            }\n          } else {\n            request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  var customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n  if (customHeaders) {\n    for (var _i2 = 0, _Object$keys2 = Object.keys(customHeaders); _i2 < _Object$keys2.length; _i2++) {\n      var customHeaderName = _Object$keys2[_i2];\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec) {\n  var stringifyXML = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {\n    throw new Error(\"XML serialization unsupported!\");\n  };\n  var _a, _b, _c, _d, _e;\n  var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  var updatedOptions = {\n    xml: {\n      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY\n    }\n  };\n  var xmlCharKey = updatedOptions.xml.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n    var bodyMapper = operationSpec.requestBody.mapper;\n    var required = bodyMapper.required,\n      serializedName = bodyMapper.serializedName,\n      xmlName = bodyMapper.xmlName,\n      xmlElementName = bodyMapper.xmlElementName,\n      xmlNamespace = bodyMapper.xmlNamespace,\n      xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix,\n      nullable = bodyMapper.nullable;\n    var typeName = bodyMapper.type.name;\n    try {\n      if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {\n        var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n        var isStream = typeName === MapperTypeNames.Stream;\n        if (operationSpec.isXML) {\n          var xmlnsKey = xmlNamespacePrefix ? \"xmlns:\".concat(xmlNamespacePrefix) : \"xmlns\";\n          var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          }\n        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\"Error \\\"\".concat(error.message, \"\\\" occurred in serializing the payload - \").concat(JSON.stringify(serializedName, undefined, \"  \"), \".\"));\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n    var _iterator2 = _createForOfIteratorHelper(operationSpec.formDataParameters),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var formDataParameter = _step2.value;\n        var formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n          var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n          request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    var result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = _defineProperty({}, xmlnsKey, xmlNamespace);\n    return result;\n  }\n  return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return _defineProperty({}, elementName, obj);\n  }\n  var result = _defineProperty({}, elementName, obj);\n  result[XML_ATTRKEY] = _defineProperty({}, xmlNamespaceKey, xmlNamespace);\n  return result;\n}","map":{"version":3,"names":["XML_ATTRKEY","XML_CHARKEY","getOperationArgumentValueFromParameter","getOperationRequestInfo","MapperTypeNames","getPathStringFromParameter","serializationPolicyName","serializationPolicy","options","arguments","length","undefined","stringifyXML","name","sendRequest","request","next","_asyncToGenerator","_regeneratorRuntime","mark","_callee","operationInfo","operationSpec","operationArguments","wrap","_callee$","_context","prev","serializeHeaders","serializeRequestBody","abrupt","stop","headerParameters","_iterator","_createForOfIteratorHelper","_step","s","n","done","headerParameter","value","headerValue","mapper","required","serializer","serialize","headerCollectionPrefix","_i","_Object$keys","Object","keys","key","headers","set","serializedName","err","e","f","customHeaders","_b","_a","requestOptions","_i2","_Object$keys2","customHeaderName","Error","serializerOptions","updatedOptions","xml","rootName","includeRoot","_c","xmlCharKey","_d","requestBody","body","bodyMapper","xmlName","xmlElementName","xmlNamespace","xmlNamespacePrefix","nullable","typeName","type","requestBodyParameterPathString","isStream","Stream","isXML","xmlnsKey","concat","getXmlValueWithNamespace","Sequence","prepareXMLRootList","String","_e","contentType","match","mediaType","JSON","stringify","error","message","formDataParameters","formData","_iterator2","_step2","formDataParameter","formDataParameterValue","formDataParameterPropertyName","serializedValue","includes","result","_defineProperty","obj","elementName","xmlNamespaceKey","Array","isArray"],"sources":["../../src/serializationPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  DictionaryMapper,\n  OperationArguments,\n  OperationRequest,\n  OperationSpec,\n  RequiredSerializerOptions,\n  SerializerOptions,\n  XML_ATTRKEY,\n  XML_CHARKEY,\n  XmlOptions,\n} from \"./interfaces\";\nimport { PipelinePolicy, PipelineResponse, SendRequest } from \"@azure/core-rest-pipeline\";\nimport {\n  getOperationArgumentValueFromParameter,\n  getOperationRequestInfo,\n} from \"./operationHelpers\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n\n/**\n * Options to configure API request serialization.\n */\nexport interface SerializationPolicyOptions {\n  /**\n   * A function that is able to write XML. Required for XML support.\n   */\n  stringifyXML?: (obj: any, opts?: XmlOptions) => string;\n\n  /**\n   * Configures behavior of xml parser and builder.\n   */\n  serializerOptions?: SerializerOptions;\n}\n\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options: SerializationPolicyOptions = {}): PipelinePolicy {\n  const stringifyXML = options.stringifyXML;\n\n  return {\n    name: serializationPolicyName,\n    async sendRequest(request: OperationRequest, next: SendRequest): Promise<PipelineResponse> {\n      const operationInfo = getOperationRequestInfo(request);\n      const operationSpec = operationInfo?.operationSpec;\n      const operationArguments = operationInfo?.operationArguments;\n      if (operationSpec && operationArguments) {\n        serializeHeaders(request, operationArguments, operationSpec);\n        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n      }\n      return next(request);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function serializeHeaders(\n  request: OperationRequest,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  if (operationSpec.headerParameters) {\n    for (const headerParameter of operationSpec.headerParameters) {\n      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n      if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {\n        headerValue = operationSpec.serializer.serialize(\n          headerParameter.mapper,\n          headerValue,\n          getPathStringFromParameter(headerParameter)\n        );\n        const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n          .headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n          for (const key of Object.keys(headerValue)) {\n            request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n          }\n        } else {\n          request.headers.set(\n            headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter),\n            headerValue\n          );\n        }\n      }\n    }\n  }\n  const customHeaders = operationArguments.options?.requestOptions?.customHeaders;\n  if (customHeaders) {\n    for (const customHeaderName of Object.keys(customHeaders)) {\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function serializeRequestBody(\n  request: OperationRequest,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec,\n  stringifyXML: (obj: any, opts?: XmlOptions) => string = function () {\n    throw new Error(\"XML serialization unsupported!\");\n  }\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  const updatedOptions: RequiredSerializerOptions = {\n    xml: {\n      rootName: serializerOptions?.xml.rootName ?? \"\",\n      includeRoot: serializerOptions?.xml.includeRoot ?? false,\n      xmlCharKey: serializerOptions?.xml.xmlCharKey ?? XML_CHARKEY,\n    },\n  };\n\n  const xmlCharKey = updatedOptions.xml.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(\n      operationArguments,\n      operationSpec.requestBody\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      serializedName,\n      xmlName,\n      xmlElementName,\n      xmlNamespace,\n      xmlNamespacePrefix,\n      nullable,\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if (\n        (request.body !== undefined && request.body !== null) ||\n        (nullable && request.body === null) ||\n        required\n      ) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        request.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          request.body,\n          requestBodyParameterPathString,\n          updatedOptions\n        );\n\n        const isStream = typeName === MapperTypeNames.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            request.body,\n            updatedOptions\n          );\n\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(\n              prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace\n              ),\n              { rootName: xmlName || serializedName, xmlCharKey }\n            );\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey,\n            });\n          }\n        } else if (\n          typeName === MapperTypeNames.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(\n        operationArguments,\n        formDataParameter\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: RequiredSerializerOptions\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction prepareXMLRootList(\n  obj: any,\n  elementName: string,\n  xmlNamespaceKey?: string,\n  xmlNamespace?: string\n): { [key: string]: any[] } {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return { [elementName]: obj };\n  }\n\n  const result = { [elementName]: obj };\n  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}