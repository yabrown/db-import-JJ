{"ast":null,"code":"'use strict';\n\n/**\n * @module nock/scope\n */\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _require = require('./intercept'),\n  addInterceptor = _require.addInterceptor,\n  isOn = _require.isOn;\nvar common = require('./common');\nvar assert = require('assert');\nvar url = require('url');\nvar debug = require('debug')('nock.scope');\nvar _require2 = require('events'),\n  EventEmitter = _require2.EventEmitter;\nvar Interceptor = require('./interceptor');\nvar URL = url.URL,\n  LegacyUrl = url.Url;\nvar fs;\ntry {\n  fs = require('fs');\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\n/**\n * Normalizes the passed url for consistent internal processing\n * @param {string|LegacyUrl|URL} u\n */\nfunction normalizeUrl(u) {\n  if (!(u instanceof URL)) {\n    if (u instanceof LegacyUrl) {\n      return normalizeUrl(new URL(url.format(u)));\n    }\n    // If the url is invalid, let the URL library report it\n    return normalizeUrl(new URL(u));\n  }\n  if (!/https?:/.test(u.protocol)) {\n    throw new TypeError(\"Protocol '\".concat(u.protocol, \"' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.\"));\n  }\n  return {\n    href: u.href,\n    origin: u.origin,\n    protocol: u.protocol,\n    username: u.username,\n    password: u.password,\n    host: u.host,\n    hostname:\n    // strip brackets from IPv6\n    typeof u.hostname === 'string' && u.hostname.startsWith('[') ? u.hostname.slice(1, -1) : u.hostname,\n    port: u.port || (u.protocol === 'http:' ? 80 : 443),\n    pathname: u.pathname,\n    search: u.search,\n    searchParams: u.searchParams,\n    hash: u.hash\n  };\n}\n\n/**\n * @param  {string|RegExp|LegacyUrl|URL} basePath\n * @param  {Object}   options\n * @param  {boolean}  options.allowUnmocked\n * @param  {string[]} options.badheaders\n * @param  {function} options.conditionally\n * @param  {boolean}  options.encodedQueryParams\n * @param  {function} options.filteringScope\n * @param  {Object}   options.reqheaders\n * @constructor\n */\nvar Scope = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Scope, _EventEmitter);\n  var _super = _createSuper(Scope);\n  function Scope(basePath, options) {\n    var _this;\n    _classCallCheck(this, Scope);\n    _this = _super.call(this);\n    _this.keyedInterceptors = {};\n    _this.interceptors = [];\n    _this.transformPathFunction = null;\n    _this.transformRequestBodyFunction = null;\n    _this.matchHeaders = [];\n    _this.scopeOptions = options || {};\n    _this.urlParts = {};\n    _this._persist = false;\n    _this.contentLen = false;\n    _this.date = null;\n    _this.basePath = basePath;\n    _this.basePathname = '';\n    _this.port = null;\n    _this._defaultReplyHeaders = [];\n    var logNamespace = String(basePath);\n    if (!(basePath instanceof RegExp)) {\n      _this.urlParts = normalizeUrl(basePath);\n      _this.port = _this.urlParts.port;\n      _this.basePathname = _this.urlParts.pathname.replace(/\\/$/, '');\n      _this.basePath = \"\".concat(_this.urlParts.protocol, \"//\").concat(_this.urlParts.hostname, \":\").concat(_this.port);\n      logNamespace = _this.urlParts.host;\n    }\n    _this.logger = debug.extend(logNamespace);\n    return _this;\n  }\n  _createClass(Scope, [{\n    key: \"add\",\n    value: function add(key, interceptor) {\n      if (!(key in this.keyedInterceptors)) {\n        this.keyedInterceptors[key] = [];\n      }\n      this.keyedInterceptors[key].push(interceptor);\n      addInterceptor(this.basePath, interceptor, this, this.scopeOptions, this.urlParts.hostname);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key, interceptor) {\n      if (this._persist) {\n        return;\n      }\n      var arr = this.keyedInterceptors[key];\n      if (arr) {\n        arr.splice(arr.indexOf(interceptor), 1);\n        if (arr.length === 0) {\n          delete this.keyedInterceptors[key];\n        }\n      }\n    }\n  }, {\n    key: \"intercept\",\n    value: function intercept(uri, method, requestBody, interceptorOptions) {\n      var ic = new Interceptor(this, uri, method, requestBody, interceptorOptions);\n      this.interceptors.push(ic);\n      return ic;\n    }\n  }, {\n    key: \"get\",\n    value: function get(uri, requestBody, options) {\n      return this.intercept(uri, 'GET', requestBody, options);\n    }\n  }, {\n    key: \"post\",\n    value: function post(uri, requestBody, options) {\n      return this.intercept(uri, 'POST', requestBody, options);\n    }\n  }, {\n    key: \"put\",\n    value: function put(uri, requestBody, options) {\n      return this.intercept(uri, 'PUT', requestBody, options);\n    }\n  }, {\n    key: \"head\",\n    value: function head(uri, requestBody, options) {\n      return this.intercept(uri, 'HEAD', requestBody, options);\n    }\n  }, {\n    key: \"patch\",\n    value: function patch(uri, requestBody, options) {\n      return this.intercept(uri, 'PATCH', requestBody, options);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(uri, requestBody, options) {\n      return this.intercept(uri, 'MERGE', requestBody, options);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(uri, requestBody, options) {\n      return this.intercept(uri, 'DELETE', requestBody, options);\n    }\n  }, {\n    key: \"options\",\n    value: function options(uri, requestBody, _options) {\n      return this.intercept(uri, 'OPTIONS', requestBody, _options);\n    }\n\n    // Returns the list of keys for non-optional Interceptors that haven't been completed yet.\n    // TODO: This assumes that completed mocks are removed from the keyedInterceptors list\n    // (when persistence is off). We should change that (and this) in future.\n  }, {\n    key: \"pendingMocks\",\n    value: function pendingMocks() {\n      var _this2 = this;\n      return this.activeMocks().filter(function (key) {\n        return _this2.keyedInterceptors[key].some(function (_ref) {\n          var interceptionCounter = _ref.interceptionCounter,\n            optional = _ref.optional;\n          var persistedAndUsed = _this2._persist && interceptionCounter > 0;\n          return !persistedAndUsed && !optional;\n        });\n      });\n    }\n\n    // Returns all keyedInterceptors that are active.\n    // This includes incomplete interceptors, persisted but complete interceptors, and\n    // optional interceptors, but not non-persisted and completed interceptors.\n  }, {\n    key: \"activeMocks\",\n    value: function activeMocks() {\n      return Object.keys(this.keyedInterceptors);\n    }\n  }, {\n    key: \"isDone\",\n    value: function isDone() {\n      if (!isOn()) {\n        return true;\n      }\n      return this.pendingMocks().length === 0;\n    }\n  }, {\n    key: \"done\",\n    value: function done() {\n      assert.ok(this.isDone(), \"Mocks not yet satisfied:\\n\".concat(this.pendingMocks().join('\\n')));\n    }\n  }, {\n    key: \"buildFilter\",\n    value: function buildFilter() {\n      var filteringArguments = arguments;\n      if (arguments[0] instanceof RegExp) {\n        return function (candidate) {\n          /* istanbul ignore if */\n          if (typeof candidate !== 'string') {\n            // Given the way nock is written, it seems like `candidate` will always\n            // be a string, regardless of what options might be passed to it.\n            // However the code used to contain a truthiness test of `candidate`.\n            // The check is being preserved for now.\n            throw Error(\"Nock internal assertion failed: typeof candidate is \".concat(typeof candidate, \". If you encounter this error, please report it as a bug.\"));\n          }\n          return candidate.replace(filteringArguments[0], filteringArguments[1]);\n        };\n      } else if (typeof arguments[0] === 'function') {\n        return arguments[0];\n      }\n    }\n  }, {\n    key: \"filteringPath\",\n    value: function filteringPath() {\n      this.transformPathFunction = this.buildFilter.apply(this, arguments);\n      if (!this.transformPathFunction) {\n        throw new Error('Invalid arguments: filtering path should be a function or a regular expression');\n      }\n      return this;\n    }\n  }, {\n    key: \"filteringRequestBody\",\n    value: function filteringRequestBody() {\n      this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments);\n      if (!this.transformRequestBodyFunction) {\n        throw new Error('Invalid arguments: filtering request body should be a function or a regular expression');\n      }\n      return this;\n    }\n  }, {\n    key: \"matchHeader\",\n    value: function matchHeader(name, value) {\n      //  We use lower-case header field names throughout Nock.\n      this.matchHeaders.push({\n        name: name.toLowerCase(),\n        value: value\n      });\n      return this;\n    }\n  }, {\n    key: \"defaultReplyHeaders\",\n    value: function defaultReplyHeaders(headers) {\n      this._defaultReplyHeaders = common.headersInputToRawArray(headers);\n      return this;\n    }\n  }, {\n    key: \"persist\",\n    value: function persist() {\n      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (typeof flag !== 'boolean') {\n        throw new Error('Invalid arguments: argument should be a boolean');\n      }\n      this._persist = flag;\n      return this;\n    }\n\n    /**\n     * @private\n     * @returns {boolean}\n     */\n  }, {\n    key: \"shouldPersist\",\n    value: function shouldPersist() {\n      return this._persist;\n    }\n  }, {\n    key: \"replyContentLength\",\n    value: function replyContentLength() {\n      this.contentLen = true;\n      return this;\n    }\n  }, {\n    key: \"replyDate\",\n    value: function replyDate(d) {\n      this.date = d || new Date();\n      return this;\n    }\n  }]);\n  return Scope;\n}(EventEmitter);\nfunction loadDefs(path) {\n  if (!fs) {\n    throw new Error('No fs');\n  }\n  var contents = fs.readFileSync(path);\n  return JSON.parse(contents);\n}\nfunction load(path) {\n  return define(loadDefs(path));\n}\nfunction getStatusFromDefinition(nockDef) {\n  // Backward compatibility for when `status` was encoded as string in `reply`.\n  if (nockDef.reply !== undefined) {\n    var parsedReply = parseInt(nockDef.reply, 10);\n    if (isNaN(parsedReply)) {\n      throw Error('`reply`, when present, must be a numeric string');\n    }\n    return parsedReply;\n  }\n  var DEFAULT_STATUS_OK = 200;\n  return nockDef.status || DEFAULT_STATUS_OK;\n}\nfunction getScopeFromDefinition(nockDef) {\n  //  Backward compatibility for when `port` was part of definition.\n  if (nockDef.port !== undefined) {\n    //  Include `port` into scope if it doesn't exist.\n    var options = url.parse(nockDef.scope);\n    if (options.port === null) {\n      return \"\".concat(nockDef.scope, \":\").concat(nockDef.port);\n    } else {\n      if (parseInt(options.port) !== parseInt(nockDef.port)) {\n        throw new Error('Mismatched port numbers in scope and port properties of nock definition.');\n      }\n    }\n  }\n  return nockDef.scope;\n}\nfunction tryJsonParse(string) {\n  try {\n    return JSON.parse(string);\n  } catch (err) {\n    return string;\n  }\n}\nfunction define(nockDefs) {\n  var scopes = [];\n  nockDefs.forEach(function (nockDef) {\n    var nscope = getScopeFromDefinition(nockDef);\n    var npath = nockDef.path;\n    if (!nockDef.method) {\n      throw Error('Method is required');\n    }\n    var method = nockDef.method.toLowerCase();\n    var status = getStatusFromDefinition(nockDef);\n    var rawHeaders = nockDef.rawHeaders || [];\n    var reqheaders = nockDef.reqheaders || {};\n    var badheaders = nockDef.badheaders || [];\n    var options = _objectSpread({}, nockDef.options);\n\n    //  We use request headers for both filtering (see below) and mocking.\n    //  Here we are setting up mocked request headers but we don't want to\n    //  be changing the user's options object so we clone it first.\n    options.reqheaders = reqheaders;\n    options.badheaders = badheaders;\n\n    // Response is not always JSON as it could be a string or binary data or\n    // even an array of binary buffers (e.g. when content is encoded).\n    var response;\n    if (!nockDef.response) {\n      response = '';\n      // TODO: Rename `responseIsBinary` to `responseIsUtf8Representable`.\n    } else if (nockDef.responseIsBinary) {\n      response = Buffer.from(nockDef.response, 'hex');\n    } else {\n      response = typeof nockDef.response === 'string' ? tryJsonParse(nockDef.response) : nockDef.response;\n    }\n    var scope = new Scope(nscope, options);\n\n    // If request headers were specified filter by them.\n    Object.entries(reqheaders).forEach(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        fieldName = _ref3[0],\n        value = _ref3[1];\n      scope.matchHeader(fieldName, value);\n    });\n    var acceptableFilters = ['filteringRequestBody', 'filteringPath'];\n    acceptableFilters.forEach(function (filter) {\n      if (nockDef[filter]) {\n        scope[filter](nockDef[filter]);\n      }\n    });\n    scope.intercept(npath, method, nockDef.body).reply(status, response, rawHeaders);\n    scopes.push(scope);\n  });\n  return scopes;\n}\nmodule.exports = {\n  Scope: Scope,\n  load: load,\n  loadDefs: loadDefs,\n  define: define\n};","map":{"version":3,"names":["_slicedToArray","require","default","_objectSpread","_classCallCheck","_createClass","_inherits","_createSuper","_require","addInterceptor","isOn","common","assert","url","debug","_require2","EventEmitter","Interceptor","URL","LegacyUrl","Url","fs","err","normalizeUrl","u","format","test","protocol","TypeError","concat","href","origin","username","password","host","hostname","startsWith","slice","port","pathname","search","searchParams","hash","Scope","_EventEmitter","_super","basePath","options","_this","call","keyedInterceptors","interceptors","transformPathFunction","transformRequestBodyFunction","matchHeaders","scopeOptions","urlParts","_persist","contentLen","date","basePathname","_defaultReplyHeaders","logNamespace","String","RegExp","replace","logger","extend","key","value","add","interceptor","push","remove","arr","splice","indexOf","length","intercept","uri","method","requestBody","interceptorOptions","ic","get","post","put","head","patch","merge","_delete","pendingMocks","_this2","activeMocks","filter","some","_ref","interceptionCounter","optional","persistedAndUsed","Object","keys","isDone","done","ok","join","buildFilter","filteringArguments","arguments","candidate","Error","filteringPath","apply","filteringRequestBody","matchHeader","name","toLowerCase","defaultReplyHeaders","headers","headersInputToRawArray","persist","flag","undefined","shouldPersist","replyContentLength","replyDate","d","Date","loadDefs","path","contents","readFileSync","JSON","parse","load","define","getStatusFromDefinition","nockDef","reply","parsedReply","parseInt","isNaN","DEFAULT_STATUS_OK","status","getScopeFromDefinition","scope","tryJsonParse","string","nockDefs","scopes","forEach","nscope","npath","rawHeaders","reqheaders","badheaders","response","responseIsBinary","Buffer","from","entries","_ref2","_ref3","fieldName","acceptableFilters","body","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/nock/lib/scope.js"],"sourcesContent":["'use strict'\n\n/**\n * @module nock/scope\n */\nconst { addInterceptor, isOn } = require('./intercept')\nconst common = require('./common')\nconst assert = require('assert')\nconst url = require('url')\nconst debug = require('debug')('nock.scope')\nconst { EventEmitter } = require('events')\nconst Interceptor = require('./interceptor')\n\nconst { URL, Url: LegacyUrl } = url\nlet fs\n\ntry {\n  fs = require('fs')\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\n/**\n * Normalizes the passed url for consistent internal processing\n * @param {string|LegacyUrl|URL} u\n */\nfunction normalizeUrl(u) {\n  if (!(u instanceof URL)) {\n    if (u instanceof LegacyUrl) {\n      return normalizeUrl(new URL(url.format(u)))\n    }\n    // If the url is invalid, let the URL library report it\n    return normalizeUrl(new URL(u))\n  }\n\n  if (!/https?:/.test(u.protocol)) {\n    throw new TypeError(\n      `Protocol '${u.protocol}' not recognized. This commonly occurs when a hostname and port are included without a protocol, producing a URL that is valid but confusing, and probably not what you want.`\n    )\n  }\n\n  return {\n    href: u.href,\n    origin: u.origin,\n    protocol: u.protocol,\n    username: u.username,\n    password: u.password,\n    host: u.host,\n    hostname:\n      // strip brackets from IPv6\n      typeof u.hostname === 'string' && u.hostname.startsWith('[')\n        ? u.hostname.slice(1, -1)\n        : u.hostname,\n    port: u.port || (u.protocol === 'http:' ? 80 : 443),\n    pathname: u.pathname,\n    search: u.search,\n    searchParams: u.searchParams,\n    hash: u.hash,\n  }\n}\n\n/**\n * @param  {string|RegExp|LegacyUrl|URL} basePath\n * @param  {Object}   options\n * @param  {boolean}  options.allowUnmocked\n * @param  {string[]} options.badheaders\n * @param  {function} options.conditionally\n * @param  {boolean}  options.encodedQueryParams\n * @param  {function} options.filteringScope\n * @param  {Object}   options.reqheaders\n * @constructor\n */\nclass Scope extends EventEmitter {\n  constructor(basePath, options) {\n    super()\n\n    this.keyedInterceptors = {}\n    this.interceptors = []\n    this.transformPathFunction = null\n    this.transformRequestBodyFunction = null\n    this.matchHeaders = []\n    this.scopeOptions = options || {}\n    this.urlParts = {}\n    this._persist = false\n    this.contentLen = false\n    this.date = null\n    this.basePath = basePath\n    this.basePathname = ''\n    this.port = null\n    this._defaultReplyHeaders = []\n\n    let logNamespace = String(basePath)\n\n    if (!(basePath instanceof RegExp)) {\n      this.urlParts = normalizeUrl(basePath)\n      this.port = this.urlParts.port\n      this.basePathname = this.urlParts.pathname.replace(/\\/$/, '')\n      this.basePath = `${this.urlParts.protocol}//${this.urlParts.hostname}:${this.port}`\n      logNamespace = this.urlParts.host\n    }\n\n    this.logger = debug.extend(logNamespace)\n  }\n\n  add(key, interceptor) {\n    if (!(key in this.keyedInterceptors)) {\n      this.keyedInterceptors[key] = []\n    }\n    this.keyedInterceptors[key].push(interceptor)\n    addInterceptor(\n      this.basePath,\n      interceptor,\n      this,\n      this.scopeOptions,\n      this.urlParts.hostname\n    )\n  }\n\n  remove(key, interceptor) {\n    if (this._persist) {\n      return\n    }\n    const arr = this.keyedInterceptors[key]\n    if (arr) {\n      arr.splice(arr.indexOf(interceptor), 1)\n      if (arr.length === 0) {\n        delete this.keyedInterceptors[key]\n      }\n    }\n  }\n\n  intercept(uri, method, requestBody, interceptorOptions) {\n    const ic = new Interceptor(\n      this,\n      uri,\n      method,\n      requestBody,\n      interceptorOptions\n    )\n\n    this.interceptors.push(ic)\n    return ic\n  }\n\n  get(uri, requestBody, options) {\n    return this.intercept(uri, 'GET', requestBody, options)\n  }\n\n  post(uri, requestBody, options) {\n    return this.intercept(uri, 'POST', requestBody, options)\n  }\n\n  put(uri, requestBody, options) {\n    return this.intercept(uri, 'PUT', requestBody, options)\n  }\n\n  head(uri, requestBody, options) {\n    return this.intercept(uri, 'HEAD', requestBody, options)\n  }\n\n  patch(uri, requestBody, options) {\n    return this.intercept(uri, 'PATCH', requestBody, options)\n  }\n\n  merge(uri, requestBody, options) {\n    return this.intercept(uri, 'MERGE', requestBody, options)\n  }\n\n  delete(uri, requestBody, options) {\n    return this.intercept(uri, 'DELETE', requestBody, options)\n  }\n\n  options(uri, requestBody, options) {\n    return this.intercept(uri, 'OPTIONS', requestBody, options)\n  }\n\n  // Returns the list of keys for non-optional Interceptors that haven't been completed yet.\n  // TODO: This assumes that completed mocks are removed from the keyedInterceptors list\n  // (when persistence is off). We should change that (and this) in future.\n  pendingMocks() {\n    return this.activeMocks().filter(key =>\n      this.keyedInterceptors[key].some(({ interceptionCounter, optional }) => {\n        const persistedAndUsed = this._persist && interceptionCounter > 0\n        return !persistedAndUsed && !optional\n      })\n    )\n  }\n\n  // Returns all keyedInterceptors that are active.\n  // This includes incomplete interceptors, persisted but complete interceptors, and\n  // optional interceptors, but not non-persisted and completed interceptors.\n  activeMocks() {\n    return Object.keys(this.keyedInterceptors)\n  }\n\n  isDone() {\n    if (!isOn()) {\n      return true\n    }\n\n    return this.pendingMocks().length === 0\n  }\n\n  done() {\n    assert.ok(\n      this.isDone(),\n      `Mocks not yet satisfied:\\n${this.pendingMocks().join('\\n')}`\n    )\n  }\n\n  buildFilter() {\n    const filteringArguments = arguments\n\n    if (arguments[0] instanceof RegExp) {\n      return function (candidate) {\n        /* istanbul ignore if */\n        if (typeof candidate !== 'string') {\n          // Given the way nock is written, it seems like `candidate` will always\n          // be a string, regardless of what options might be passed to it.\n          // However the code used to contain a truthiness test of `candidate`.\n          // The check is being preserved for now.\n          throw Error(\n            `Nock internal assertion failed: typeof candidate is ${typeof candidate}. If you encounter this error, please report it as a bug.`\n          )\n        }\n        return candidate.replace(filteringArguments[0], filteringArguments[1])\n      }\n    } else if (typeof arguments[0] === 'function') {\n      return arguments[0]\n    }\n  }\n\n  filteringPath() {\n    this.transformPathFunction = this.buildFilter.apply(this, arguments)\n    if (!this.transformPathFunction) {\n      throw new Error(\n        'Invalid arguments: filtering path should be a function or a regular expression'\n      )\n    }\n    return this\n  }\n\n  filteringRequestBody() {\n    this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments)\n    if (!this.transformRequestBodyFunction) {\n      throw new Error(\n        'Invalid arguments: filtering request body should be a function or a regular expression'\n      )\n    }\n    return this\n  }\n\n  matchHeader(name, value) {\n    //  We use lower-case header field names throughout Nock.\n    this.matchHeaders.push({ name: name.toLowerCase(), value })\n    return this\n  }\n\n  defaultReplyHeaders(headers) {\n    this._defaultReplyHeaders = common.headersInputToRawArray(headers)\n    return this\n  }\n\n  persist(flag = true) {\n    if (typeof flag !== 'boolean') {\n      throw new Error('Invalid arguments: argument should be a boolean')\n    }\n    this._persist = flag\n    return this\n  }\n\n  /**\n   * @private\n   * @returns {boolean}\n   */\n  shouldPersist() {\n    return this._persist\n  }\n\n  replyContentLength() {\n    this.contentLen = true\n    return this\n  }\n\n  replyDate(d) {\n    this.date = d || new Date()\n    return this\n  }\n}\n\nfunction loadDefs(path) {\n  if (!fs) {\n    throw new Error('No fs')\n  }\n\n  const contents = fs.readFileSync(path)\n  return JSON.parse(contents)\n}\n\nfunction load(path) {\n  return define(loadDefs(path))\n}\n\nfunction getStatusFromDefinition(nockDef) {\n  // Backward compatibility for when `status` was encoded as string in `reply`.\n  if (nockDef.reply !== undefined) {\n    const parsedReply = parseInt(nockDef.reply, 10)\n    if (isNaN(parsedReply)) {\n      throw Error('`reply`, when present, must be a numeric string')\n    }\n\n    return parsedReply\n  }\n\n  const DEFAULT_STATUS_OK = 200\n  return nockDef.status || DEFAULT_STATUS_OK\n}\n\nfunction getScopeFromDefinition(nockDef) {\n  //  Backward compatibility for when `port` was part of definition.\n  if (nockDef.port !== undefined) {\n    //  Include `port` into scope if it doesn't exist.\n    const options = url.parse(nockDef.scope)\n    if (options.port === null) {\n      return `${nockDef.scope}:${nockDef.port}`\n    } else {\n      if (parseInt(options.port) !== parseInt(nockDef.port)) {\n        throw new Error(\n          'Mismatched port numbers in scope and port properties of nock definition.'\n        )\n      }\n    }\n  }\n\n  return nockDef.scope\n}\n\nfunction tryJsonParse(string) {\n  try {\n    return JSON.parse(string)\n  } catch (err) {\n    return string\n  }\n}\n\nfunction define(nockDefs) {\n  const scopes = []\n\n  nockDefs.forEach(function (nockDef) {\n    const nscope = getScopeFromDefinition(nockDef)\n    const npath = nockDef.path\n    if (!nockDef.method) {\n      throw Error('Method is required')\n    }\n    const method = nockDef.method.toLowerCase()\n    const status = getStatusFromDefinition(nockDef)\n    const rawHeaders = nockDef.rawHeaders || []\n    const reqheaders = nockDef.reqheaders || {}\n    const badheaders = nockDef.badheaders || []\n    const options = { ...nockDef.options }\n\n    //  We use request headers for both filtering (see below) and mocking.\n    //  Here we are setting up mocked request headers but we don't want to\n    //  be changing the user's options object so we clone it first.\n    options.reqheaders = reqheaders\n    options.badheaders = badheaders\n\n    // Response is not always JSON as it could be a string or binary data or\n    // even an array of binary buffers (e.g. when content is encoded).\n    let response\n    if (!nockDef.response) {\n      response = ''\n      // TODO: Rename `responseIsBinary` to `responseIsUtf8Representable`.\n    } else if (nockDef.responseIsBinary) {\n      response = Buffer.from(nockDef.response, 'hex')\n    } else {\n      response =\n        typeof nockDef.response === 'string'\n          ? tryJsonParse(nockDef.response)\n          : nockDef.response\n    }\n\n    const scope = new Scope(nscope, options)\n\n    // If request headers were specified filter by them.\n    Object.entries(reqheaders).forEach(([fieldName, value]) => {\n      scope.matchHeader(fieldName, value)\n    })\n\n    const acceptableFilters = ['filteringRequestBody', 'filteringPath']\n    acceptableFilters.forEach(filter => {\n      if (nockDef[filter]) {\n        scope[filter](nockDef[filter])\n      }\n    })\n\n    scope\n      .intercept(npath, method, nockDef.body)\n      .reply(status, response, rawHeaders)\n\n    scopes.push(scope)\n  })\n\n  return scopes\n}\n\nmodule.exports = {\n  Scope,\n  load,\n  loadDefs,\n  define,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}