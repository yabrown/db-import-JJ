{"ast":null,"code":"import _slicedToArray from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTracingClient } from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError\";\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport var tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var userAgent = getUserAgentValue(options.userAgentPrefix);\n  var tracingClient = tryCreateTracingClient();\n  return {\n    name: tracingPolicyName,\n    sendRequest: function sendRequest(request, next) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _a, _b, _ref, span, tracingContext, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext))) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", next(request));\n            case 2:\n              _ref = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {}, span = _ref.span, tracingContext = _ref.tracingContext;\n              if (!(!span || !tracingContext)) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\", next(request));\n            case 5:\n              _context.prev = 5;\n              _context.next = 8;\n              return tracingClient.withContext(tracingContext, next, request);\n            case 8:\n              response = _context.sent;\n              tryProcessResponse(span, response);\n              return _context.abrupt(\"return\", response);\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](5);\n              tryProcessError(span, _context.t0);\n              throw _context.t0;\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[5, 13]]);\n      }))();\n    }\n  };\n}\nfunction tryCreateTracingClient() {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION\n    });\n  } catch (e) {\n    logger.warning(\"Error when creating the TracingClient: \".concat(getErrorMessage(e)));\n    return undefined;\n  }\n}\nfunction tryCreateSpan(tracingClient, request, userAgent) {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    var _tracingClient$startS = tracingClient.startSpan(\"HTTP \".concat(request.method), {\n        tracingOptions: request.tracingOptions\n      }, {\n        spanKind: \"client\",\n        spanAttributes: {\n          \"http.method\": request.method,\n          \"http.url\": request.url,\n          requestId: request.requestId\n        }\n      }),\n      span = _tracingClient$startS.span,\n      updatedOptions = _tracingClient$startS.updatedOptions;\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n    // set headers\n    var headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);\n    for (var _i = 0, _Object$entries = Object.entries(headers); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      request.headers.set(key, value);\n    }\n    return {\n      span: span,\n      tracingContext: updatedOptions.tracingOptions.tracingContext\n    };\n  } catch (e) {\n    logger.warning(\"Skipping creating a tracing span due to an error: \".concat(getErrorMessage(e)));\n    return undefined;\n  }\n}\nfunction tryProcessError(span, error) {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e) {\n    logger.warning(\"Skipping tracing span processing due to an error: \".concat(getErrorMessage(e)));\n  }\n}\nfunction tryProcessResponse(span, response) {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    var serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\"\n    });\n    span.end();\n  } catch (e) {\n    logger.warning(\"Skipping tracing span processing due to an error: \".concat(getErrorMessage(e)));\n  }\n}","map":{"version":3,"names":["createTracingClient","SDK_VERSION","getUserAgentValue","logger","getErrorMessage","isError","isRestError","tracingPolicyName","tracingPolicy","options","arguments","length","undefined","userAgent","userAgentPrefix","tracingClient","tryCreateTracingClient","name","sendRequest","request","next","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_a","_b","_ref","span","tracingContext","response","wrap","_callee$","_context","prev","tracingOptions","abrupt","tryCreateSpan","withContext","sent","tryProcessResponse","t0","tryProcessError","stop","namespace","packageName","packageVersion","e","warning","concat","_tracingClient$startS","startSpan","method","spanKind","spanAttributes","url","requestId","updatedOptions","isRecording","end","setAttribute","headers","createRequestHeaders","_i","_Object$entries","Object","entries","_Object$entries$_i","_slicedToArray","key","value","set","error","setStatus","status","statusCode","serviceRequestId","get"],"sources":["../../../src/policies/tracingPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  TracingClient,\n  TracingContext,\n  TracingSpan,\n  createTracingClient,\n} from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants\";\nimport { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError\";\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  const tracingClient = tryCreateTracingClient();\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!tracingClient || !request.tracingOptions?.tracingContext) {\n        return next(request);\n      }\n\n      const { span, tracingContext } = tryCreateSpan(tracingClient, request, userAgent) ?? {};\n\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err: any) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    },\n  };\n}\n\nfunction tryCreateTracingClient(): TracingClient | undefined {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION,\n    });\n  } catch (e: unknown) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryCreateSpan(\n  tracingClient: TracingClient,\n  request: PipelineRequest,\n  userAgent?: string\n): { span: TracingSpan; tracingContext: TracingContext } | undefined {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const { span, updatedOptions } = tracingClient.startSpan(\n      `HTTP ${request.method}`,\n      { tracingOptions: request.tracingOptions },\n      {\n        spanKind: \"client\",\n        spanAttributes: {\n          \"http.method\": request.method,\n          \"http.url\": request.url,\n          requestId: request.requestId,\n        },\n      }\n    );\n\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n\n    // set headers\n    const headers = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions.tracingContext\n    );\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n  } catch (e: any) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span: TracingSpan, error: unknown): void {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined,\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n\nfunction tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\",\n    });\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}