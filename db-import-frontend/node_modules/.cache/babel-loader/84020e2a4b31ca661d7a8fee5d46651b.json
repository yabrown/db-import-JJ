{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require('minipass-fetch'),\n  Request = _require.Request,\n  Response = _require.Response;\nvar Minipass = require('minipass');\nvar MinipassCollect = require('minipass-collect');\nvar MinipassFlush = require('minipass-flush');\nvar MinipassPipeline = require('minipass-pipeline');\nvar cacache = require('cacache');\nvar url = require('url');\nvar CachePolicy = require('./policy.js');\nvar cacheKey = require('./key.js');\nvar remote = require('../remote.js');\nvar hasOwnProperty = function hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\n// maximum amount of data we will buffer into memory\n// if we'll exceed this, we switch to streaming\nvar MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nvar KEEP_REQUEST_HEADERS = ['accept-charset', 'accept-encoding', 'accept-language', 'accept', 'cache-control'];\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nvar KEEP_RESPONSE_HEADERS = ['cache-control', 'content-encoding', 'content-language', 'content-type', 'date', 'etag', 'expires', 'last-modified', 'location', 'pragma', 'vary'];\n\n// return an object containing all metadata to be written to the index\nvar getMetadata = function getMetadata(request, response, options) {\n  var metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {}\n  };\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304) metadata.status = response.status;\n  for (var _i = 0, _KEEP_REQUEST_HEADERS = KEEP_REQUEST_HEADERS; _i < _KEEP_REQUEST_HEADERS.length; _i++) {\n    var name = _KEEP_REQUEST_HEADERS[_i];\n    if (request.headers.has(name)) metadata.reqHeaders[name] = request.headers.get(name);\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  var host = request.headers.get('host');\n  var parsedUrl = new url.URL(request.url);\n  if (host && parsedUrl.host !== host) metadata.reqHeaders.host = host;\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    var vary = response.headers.get('vary');\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      var varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/);\n      var _iterator = _createForOfIteratorHelper(varyHeaders),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _name = _step.value;\n          // explicitly ignore accept-encoding here\n          if (_name !== 'accept-encoding' && request.headers.has(_name)) metadata.reqHeaders[_name] = request.headers.get(_name);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  for (var _i2 = 0, _KEEP_RESPONSE_HEADER = KEEP_RESPONSE_HEADERS; _i2 < _KEEP_RESPONSE_HEADER.length; _i2++) {\n    var _name2 = _KEEP_RESPONSE_HEADER[_i2];\n    if (response.headers.has(_name2)) metadata.resHeaders[_name2] = response.headers.get(_name2);\n  }\n\n  // we only store accept-encoding and content-encoding if the user\n  // has disabled automatic compression and decompression in minipass-fetch\n  // since if it's enabled (the default) then the content will have\n  // already been decompressed making the header a lie\n  if (options.compress === false) {\n    metadata.reqHeaders['accept-encoding'] = request.headers.get('accept-encoding');\n    metadata.resHeaders['content-encoding'] = response.headers.get('content-encoding');\n  }\n  return metadata;\n};\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nvar _request = Symbol('request');\nvar _response = Symbol('response');\nvar _policy = Symbol('policy');\nvar CacheEntry = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function CacheEntry(_ref) {\n    var entry = _ref.entry,\n      request = _ref.request,\n      response = _ref.response,\n      options = _ref.options;\n    _classCallCheck(this, CacheEntry);\n    if (entry) {\n      this.key = entry.key;\n      this.entry = entry;\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time;\n    } else this.key = cacheKey(request);\n    this.options = options;\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request;\n    this[_response] = response;\n    this[_policy] = null;\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  _createClass(CacheEntry, [{\n    key: \"request\",\n    get: function get() {\n      if (!this[_request]) {\n        this[_request] = new Request(this.entry.metadata.url, {\n          method: 'GET',\n          headers: this.entry.metadata.reqHeaders\n        });\n      }\n      return this[_request];\n    }\n  }, {\n    key: \"response\",\n    get: function get() {\n      if (!this[_response]) {\n        this[_response] = new Response(null, {\n          url: this.entry.metadata.url,\n          counter: this.options.counter,\n          status: this.entry.metadata.status || 200,\n          headers: _objectSpread(_objectSpread({}, this.entry.metadata.resHeaders), {}, {\n            'content-length': this.entry.size\n          })\n        });\n      }\n      return this[_response];\n    }\n  }, {\n    key: \"policy\",\n    get: function get() {\n      if (!this[_policy]) {\n        this[_policy] = new CachePolicy({\n          entry: this.entry,\n          request: this.request,\n          response: this.response,\n          options: this.options\n        });\n      }\n      return this[_policy];\n    }\n\n    // wraps the response in a pipeline that stores the data\n    // in the cache while the user consumes it\n  }, {\n    key: \"store\",\n    value: function () {\n      var _store = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(status) {\n        var _this = this;\n        var size, fitsInMemory, shouldBuffer, cacheOpts, body, cacheWriteResolve, cacheWriteReject, cacheWritePromise, abortStream, onResume, newResponse;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.request.method !== 'GET' || ![200, 301, 308].includes(this.response.status) || !this.policy.storable())) {\n                _context.next = 3;\n                break;\n              }\n              this.response.headers.set('x-local-cache-status', 'skip');\n              return _context.abrupt(\"return\", this.response);\n            case 3:\n              size = this.response.headers.get('content-length');\n              fitsInMemory = !!size && Number(size) < MAX_MEM_SIZE;\n              shouldBuffer = this.options.memoize !== false && fitsInMemory;\n              cacheOpts = {\n                algorithms: this.options.algorithms,\n                metadata: getMetadata(this.request, this.response, this.options),\n                size: size,\n                memoize: fitsInMemory && this.options.memoize\n              };\n              body = null; // we only set a body if the status is a 200, redirects are\n              // stored as metadata only\n              if (!(this.response.status === 200)) {\n                _context.next = 17;\n                break;\n              }\n              cacheWritePromise = new Promise(function (resolve, reject) {\n                cacheWriteResolve = resolve;\n                cacheWriteReject = reject;\n              });\n              body = new MinipassPipeline(new MinipassFlush({\n                flush: function flush() {\n                  return cacheWritePromise;\n                }\n              }));\n              if (shouldBuffer) {\n                // if the result fits in memory, use a collect stream to gather\n                // the response and write it to cacache while also passing it through\n                // to the user\n                onResume = function onResume() {\n                  var collector = new MinipassCollect.PassThrough();\n                  abortStream = collector;\n                  collector.on('collect', function (data) {\n                    // TODO if the cache write fails, log a warning but return the response anyway\n                    cacache.put(_this.options.cachePath, _this.key, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject);\n                  });\n                  body.unshift(collector);\n                  body.unshift(_this.response.body);\n                };\n              } else {\n                // if it does not fit in memory, create a tee stream and use\n                // that to pipe to both the cache and the user simultaneously\n                onResume = function onResume() {\n                  var tee = new Minipass();\n                  var cacheStream = cacache.put.stream(_this.options.cachePath, _this.key, cacheOpts);\n                  abortStream = cacheStream;\n                  tee.pipe(cacheStream);\n                  // TODO if the cache write fails, log a warning but return the response anyway\n                  cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);\n                  body.unshift(tee);\n                  body.unshift(_this.response.body);\n                };\n              }\n              body.once('resume', onResume);\n              body.once('end', function () {\n                return body.removeListener('resume', onResume);\n              });\n              this.response.body.on('error', function (err) {\n                // the abortStream will either be a MinipassCollect if we buffer\n                // or a cacache write stream, either way be sure to listen for\n                // errors from the actual response and avoid writing data that we\n                // know to be invalid to the cache\n                abortStream.destroy(err);\n              });\n              _context.next = 19;\n              break;\n            case 17:\n              _context.next = 19;\n              return cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts);\n            case 19:\n              // note: we do not set the x-local-cache-hash header because we do not know\n              // the hash value until after the write to the cache completes, which doesn't\n              // happen until after the response has been sent and it's too late to write\n              // the header anyway\n              this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));\n              this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key));\n              this.response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');\n              this.response.headers.set('x-local-cache-status', status);\n              this.response.headers.set('x-local-cache-time', new Date().toISOString());\n              newResponse = new Response(body, {\n                url: this.response.url,\n                status: this.response.status,\n                headers: this.response.headers,\n                counter: this.options.counter\n              });\n              return _context.abrupt(\"return\", newResponse);\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function store(_x) {\n        return _store.apply(this, arguments);\n      }\n      return store;\n    }() // use the cached data to create a response and return it\n  }, {\n    key: \"respond\",\n    value: function () {\n      var _respond = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(method, options, status) {\n        var _this2 = this;\n        var response, size, fitsInMemory, shouldBuffer, body, removeOnResume, onResume;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              size = Number(this.response.headers.get('content-length'));\n              fitsInMemory = !!size && size < MAX_MEM_SIZE;\n              shouldBuffer = this.options.memoize !== false && fitsInMemory;\n              if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n                // if the request is a HEAD, or the response is a redirect,\n                // then the metadata in the entry already includes everything\n                // we need to build a response\n                response = this.response;\n              } else {\n                // we're responding with a full cached response, so create a body\n                // that reads from cacache and attach it to a new Response\n                body = new Minipass();\n                removeOnResume = function removeOnResume() {\n                  return body.removeListener('resume', onResume);\n                };\n                if (shouldBuffer) {\n                  onResume = /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                      var content;\n                      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                        while (1) switch (_context2.prev = _context2.next) {\n                          case 0:\n                            removeOnResume();\n                            _context2.prev = 1;\n                            _context2.next = 4;\n                            return cacache.get.byDigest(_this2.options.cachePath, _this2.entry.integrity, {\n                              memoize: _this2.options.memoize\n                            });\n                          case 4:\n                            content = _context2.sent;\n                            body.end(content);\n                            _context2.next = 17;\n                            break;\n                          case 8:\n                            _context2.prev = 8;\n                            _context2.t0 = _context2[\"catch\"](1);\n                            if (!(_context2.t0.code === 'EINTEGRITY')) {\n                              _context2.next = 13;\n                              break;\n                            }\n                            _context2.next = 13;\n                            return cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {\n                              memoize: _this2.options.memoize\n                            });\n                          case 13:\n                            if (!(_context2.t0.code === 'ENOENT' || _context2.t0.code === 'EINTEGRITY')) {\n                              _context2.next = 16;\n                              break;\n                            }\n                            _context2.next = 16;\n                            return CacheEntry.invalidate(_this2.request, _this2.options);\n                          case 16:\n                            body.emit('error', _context2.t0);\n                          case 17:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }, _callee2, null, [[1, 8]]);\n                    }));\n                    return function onResume() {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }();\n                } else {\n                  onResume = function onResume() {\n                    var cacheStream = cacache.get.stream.byDigest(_this2.options.cachePath, _this2.entry.integrity, {\n                      memoize: _this2.options.memoize\n                    });\n                    cacheStream.on('error', /*#__PURE__*/function () {\n                      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(err) {\n                        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                          while (1) switch (_context3.prev = _context3.next) {\n                            case 0:\n                              cacheStream.pause();\n                              if (!(err.code === 'EINTEGRITY')) {\n                                _context3.next = 4;\n                                break;\n                              }\n                              _context3.next = 4;\n                              return cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {\n                                memoize: _this2.options.memoize\n                              });\n                            case 4:\n                              if (!(err.code === 'ENOENT' || err.code === 'EINTEGRITY')) {\n                                _context3.next = 7;\n                                break;\n                              }\n                              _context3.next = 7;\n                              return CacheEntry.invalidate(_this2.request, _this2.options);\n                            case 7:\n                              body.emit('error', err);\n                              cacheStream.resume();\n                            case 9:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }, _callee3);\n                      }));\n                      return function (_x5) {\n                        return _ref3.apply(this, arguments);\n                      };\n                    }());\n                    cacheStream.pipe(body);\n                  };\n                }\n                body.once('resume', onResume);\n                body.once('end', removeOnResume);\n                response = new Response(body, {\n                  url: this.entry.metadata.url,\n                  counter: options.counter,\n                  status: 200,\n                  headers: _objectSpread({}, this.policy.responseHeaders())\n                });\n              }\n              response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath));\n              response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity));\n              response.headers.set('x-local-cache-key', encodeURIComponent(this.key));\n              response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');\n              response.headers.set('x-local-cache-status', status);\n              response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString());\n              return _context4.abrupt(\"return\", response);\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function respond(_x2, _x3, _x4) {\n        return _respond.apply(this, arguments);\n      }\n      return respond;\n    }() // use the provided request along with this cache entry to\n    // revalidate the stored response. returns a response, either\n    // from the cache or from the update\n  }, {\n    key: \"revalidate\",\n    value: function () {\n      var _revalidate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request, options) {\n        var revalidateRequest, response, metadata, _i3, _KEEP_RESPONSE_HEADER2, name, newEntry;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              revalidateRequest = new Request(request, {\n                headers: this.policy.revalidationHeaders(request)\n              });\n              _context5.prev = 1;\n              _context5.next = 4;\n              return remote(revalidateRequest, _objectSpread(_objectSpread({}, options), {}, {\n                headers: undefined\n              }));\n            case 4:\n              response = _context5.sent;\n              _context5.next = 12;\n              break;\n            case 7:\n              _context5.prev = 7;\n              _context5.t0 = _context5[\"catch\"](1);\n              if (this.policy.mustRevalidate) {\n                _context5.next = 11;\n                break;\n              }\n              return _context5.abrupt(\"return\", this.respond(request.method, options, 'stale'));\n            case 11:\n              throw _context5.t0;\n            case 12:\n              if (!this.policy.revalidated(revalidateRequest, response)) {\n                _context5.next = 23;\n                break;\n              }\n              // we got a 304, write a new index to the cache and respond from cache\n              metadata = getMetadata(request, response, options); // 304 responses do not include headers that are specific to the response data\n              // since they do not include a body, so we copy values for headers that were\n              // in the old cache entry to the new one, if the new metadata does not already\n              // include that header\n              for (_i3 = 0, _KEEP_RESPONSE_HEADER2 = KEEP_RESPONSE_HEADERS; _i3 < _KEEP_RESPONSE_HEADER2.length; _i3++) {\n                name = _KEEP_RESPONSE_HEADER2[_i3];\n                if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name)) metadata.resHeaders[name] = this.entry.metadata.resHeaders[name];\n              }\n              _context5.prev = 15;\n              _context5.next = 18;\n              return cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n                size: this.entry.size,\n                metadata: metadata\n              });\n            case 18:\n              _context5.next = 22;\n              break;\n            case 20:\n              _context5.prev = 20;\n              _context5.t1 = _context5[\"catch\"](15);\n            case 22:\n              return _context5.abrupt(\"return\", this.respond(request.method, options, 'revalidated'));\n            case 23:\n              // if we got a modified response, create a new entry based on it\n              newEntry = new CacheEntry({\n                request: request,\n                response: response,\n                options: options\n              }); // respond with the new entry while writing it to the cache\n              return _context5.abrupt(\"return\", newEntry.store('updated'));\n            case 25:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[1, 7], [15, 20]]);\n      }));\n      function revalidate(_x6, _x7) {\n        return _revalidate.apply(this, arguments);\n      }\n      return revalidate;\n    }()\n  }], [{\n    key: \"find\",\n    value: function () {\n      var _find = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request, options) {\n        var matches, match, _iterator2, _step2, entry, _entry;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.prev = 0;\n              _context6.next = 3;\n              return cacache.index.compact(options.cachePath, cacheKey(request), function (A, B) {\n                var entryA = new CacheEntry({\n                  entry: A,\n                  options: options\n                });\n                var entryB = new CacheEntry({\n                  entry: B,\n                  options: options\n                });\n                return entryA.policy.satisfies(entryB.request);\n              }, {\n                validateEntry: function validateEntry(entry) {\n                  // if an integrity is null, it needs to have a status specified\n                  if (entry.integrity === null) return !!(entry.metadata && entry.metadata.status);\n                  return true;\n                }\n              });\n            case 3:\n              matches = _context6.sent;\n              _context6.next = 9;\n              break;\n            case 6:\n              _context6.prev = 6;\n              _context6.t0 = _context6[\"catch\"](0);\n              return _context6.abrupt(\"return\");\n            case 9:\n              if (!(options.cache === 'reload')) {\n                _context6.next = 11;\n                break;\n              }\n              return _context6.abrupt(\"return\");\n            case 11:\n              _iterator2 = _createForOfIteratorHelper(matches);\n              _context6.prev = 12;\n              _iterator2.s();\n            case 14:\n              if ((_step2 = _iterator2.n()).done) {\n                _context6.next = 22;\n                break;\n              }\n              entry = _step2.value;\n              _entry = new CacheEntry({\n                entry: entry,\n                options: options\n              });\n              if (!_entry.policy.satisfies(request)) {\n                _context6.next = 20;\n                break;\n              }\n              match = _entry;\n              return _context6.abrupt(\"break\", 22);\n            case 20:\n              _context6.next = 14;\n              break;\n            case 22:\n              _context6.next = 27;\n              break;\n            case 24:\n              _context6.prev = 24;\n              _context6.t1 = _context6[\"catch\"](12);\n              _iterator2.e(_context6.t1);\n            case 27:\n              _context6.prev = 27;\n              _iterator2.f();\n              return _context6.finish(27);\n            case 30:\n              return _context6.abrupt(\"return\", match);\n            case 31:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, null, [[0, 6], [12, 24, 27, 30]]);\n      }));\n      function find(_x8, _x9) {\n        return _find.apply(this, arguments);\n      }\n      return find;\n    }() // if the user made a PUT/POST/PATCH then we invalidate our\n    // cache for the same url by deleting the index entirely\n  }, {\n    key: \"invalidate\",\n    value: function () {\n      var _invalidate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request, options) {\n        var key;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              key = cacheKey(request);\n              _context7.prev = 1;\n              _context7.next = 4;\n              return cacache.rm.entry(options.cachePath, key, {\n                removeFully: true\n              });\n            case 4:\n              _context7.next = 8;\n              break;\n            case 6:\n              _context7.prev = 6;\n              _context7.t0 = _context7[\"catch\"](1);\n            case 8:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, null, [[1, 6]]);\n      }));\n      function invalidate(_x10, _x11) {\n        return _invalidate.apply(this, arguments);\n      }\n      return invalidate;\n    }()\n  }]);\n  return CacheEntry;\n}();\nmodule.exports = CacheEntry;","map":{"version":3,"names":["_require","require","Request","Response","Minipass","MinipassCollect","MinipassFlush","MinipassPipeline","cacache","url","CachePolicy","cacheKey","remote","hasOwnProperty","obj","prop","Object","prototype","call","MAX_MEM_SIZE","KEEP_REQUEST_HEADERS","KEEP_RESPONSE_HEADERS","getMetadata","request","response","options","metadata","time","Date","now","reqHeaders","resHeaders","status","_i","_KEEP_REQUEST_HEADERS","length","name","headers","has","get","host","parsedUrl","URL","vary","varyHeaders","trim","toLowerCase","split","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","e","f","_i2","_KEEP_RESPONSE_HEADER","compress","_request","Symbol","_response","_policy","CacheEntry","_ref","entry","_classCallCheck","key","_createClass","method","counter","_objectSpread","size","_store","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this","fitsInMemory","shouldBuffer","cacheOpts","body","cacheWriteResolve","cacheWriteReject","cacheWritePromise","abortStream","onResume","newResponse","wrap","_callee$","_context","prev","next","includes","policy","storable","set","abrupt","Number","memoize","algorithms","Promise","resolve","reject","flush","collector","PassThrough","on","data","put","cachePath","then","unshift","tee","cacheStream","stream","pipe","promise","once","removeListener","destroy","index","insert","encodeURIComponent","toISOString","stop","store","_x","apply","arguments","_respond","_callee4","_this2","removeOnResume","_callee4$","_context4","_ref2","_callee2","content","_callee2$","_context2","byDigest","integrity","sent","end","t0","code","rm","invalidate","emit","_ref3","_callee3","_callee3$","_context3","pause","resume","_x5","responseHeaders","toUTCString","respond","_x2","_x3","_x4","_revalidate","_callee5","revalidateRequest","_i3","_KEEP_RESPONSE_HEADER2","newEntry","_callee5$","_context5","revalidationHeaders","undefined","mustRevalidate","revalidated","t1","revalidate","_x6","_x7","_find","_callee6","matches","match","_iterator2","_step2","_entry","_callee6$","_context6","compact","A","B","entryA","entryB","satisfies","validateEntry","cache","finish","find","_x8","_x9","_invalidate","_callee7","_callee7$","_context7","removeFully","_x10","_x11","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/make-fetch-happen/lib/cache/entry.js"],"sourcesContent":["const { Request, Response } = require('minipass-fetch')\nconst Minipass = require('minipass')\nconst MinipassCollect = require('minipass-collect')\nconst MinipassFlush = require('minipass-flush')\nconst MinipassPipeline = require('minipass-pipeline')\nconst cacache = require('cacache')\nconst url = require('url')\n\nconst CachePolicy = require('./policy.js')\nconst cacheKey = require('./key.js')\nconst remote = require('../remote.js')\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n\n// maximum amount of data we will buffer into memory\n// if we'll exceed this, we switch to streaming\nconst MAX_MEM_SIZE = 5 * 1024 * 1024 // 5MB\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nconst KEEP_REQUEST_HEADERS = [\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept',\n  'cache-control',\n]\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nconst KEEP_RESPONSE_HEADERS = [\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-type',\n  'date',\n  'etag',\n  'expires',\n  'last-modified',\n  'location',\n  'pragma',\n  'vary',\n]\n\n// return an object containing all metadata to be written to the index\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n  }\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304)\n    metadata.status = response.status\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name))\n      metadata.reqHeaders[name] = request.headers.get(name)\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  const host = request.headers.get('host')\n  const parsedUrl = new url.URL(request.url)\n  if (host && parsedUrl.host !== host)\n    metadata.reqHeaders.host = host\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary')\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/)\n      for (const name of varyHeaders) {\n        // explicitly ignore accept-encoding here\n        if (name !== 'accept-encoding' && request.headers.has(name))\n          metadata.reqHeaders[name] = request.headers.get(name)\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name))\n      metadata.resHeaders[name] = response.headers.get(name)\n  }\n\n  // we only store accept-encoding and content-encoding if the user\n  // has disabled automatic compression and decompression in minipass-fetch\n  // since if it's enabled (the default) then the content will have\n  // already been decompressed making the header a lie\n  if (options.compress === false) {\n    metadata.reqHeaders['accept-encoding'] = request.headers.get('accept-encoding')\n    metadata.resHeaders['content-encoding'] = response.headers.get('content-encoding')\n  }\n\n  return metadata\n}\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nconst _request = Symbol('request')\nconst _response = Symbol('response')\nconst _policy = Symbol('policy')\n\nclass CacheEntry {\n  constructor ({ entry, request, response, options }) {\n    if (entry) {\n      this.key = entry.key\n      this.entry = entry\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time\n    } else\n      this.key = cacheKey(request)\n\n    this.options = options\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request\n    this[_response] = response\n    this[_policy] = null\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  static async find (request, options) {\n    try {\n      // compacts the index and returns an array of unique entries\n      var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n        const entryA = new CacheEntry({ entry: A, options })\n        const entryB = new CacheEntry({ entry: B, options })\n        return entryA.policy.satisfies(entryB.request)\n      }, {\n        validateEntry: (entry) => {\n          // if an integrity is null, it needs to have a status specified\n          if (entry.integrity === null)\n            return !!(entry.metadata && entry.metadata.status)\n\n          return true\n        },\n      })\n    } catch (err) {\n      // if the compact request fails, ignore the error and return\n      return\n    }\n\n    // a cache mode of 'reload' means to behave as though we have no cache\n    // on the way to the network. return undefined to allow cacheFetch to\n    // create a brand new request no matter what.\n    if (options.cache === 'reload')\n      return\n\n    // find the specific entry that satisfies the request\n    let match\n    for (const entry of matches) {\n      const _entry = new CacheEntry({\n        entry,\n        options,\n      })\n\n      if (_entry.policy.satisfies(request)) {\n        match = _entry\n        break\n      }\n    }\n\n    return match\n  }\n\n  // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n  static async invalidate (request, options) {\n    const key = cacheKey(request)\n    try {\n      await cacache.rm.entry(options.cachePath, key, { removeFully: true })\n    } catch (err) {\n      // ignore errors\n    }\n  }\n\n  get request () {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n      })\n    }\n\n    return this[_request]\n  }\n\n  get response () {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: {\n          ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size,\n        },\n      })\n    }\n\n    return this[_response]\n  }\n\n  get policy () {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options,\n      })\n    }\n\n    return this[_policy]\n  }\n\n  // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n  async store (status) {\n    // if we got a status other than 200, 301, or 308,\n    // or the CachePolicy forbid storage, append the\n    // cache status header and return it untouched\n    if (this.request.method !== 'GET' || ![200, 301, 308].includes(this.response.status) || !this.policy.storable()) {\n      this.response.headers.set('x-local-cache-status', 'skip')\n      return this.response\n    }\n\n    const size = this.response.headers.get('content-length')\n    const fitsInMemory = !!size && Number(size) < MAX_MEM_SIZE\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory\n    const cacheOpts = {\n      algorithms: this.options.algorithms,\n      metadata: getMetadata(this.request, this.response, this.options),\n      size,\n      memoize: fitsInMemory && this.options.memoize,\n    }\n\n    let body = null\n    // we only set a body if the status is a 200, redirects are\n    // stored as metadata only\n    if (this.response.status === 200) {\n      let cacheWriteResolve, cacheWriteReject\n      const cacheWritePromise = new Promise((resolve, reject) => {\n        cacheWriteResolve = resolve\n        cacheWriteReject = reject\n      })\n\n      body = new MinipassPipeline(new MinipassFlush({\n        flush () {\n          return cacheWritePromise\n        },\n      }))\n\n      let abortStream, onResume\n      if (shouldBuffer) {\n        // if the result fits in memory, use a collect stream to gather\n        // the response and write it to cacache while also passing it through\n        // to the user\n        onResume = () => {\n          const collector = new MinipassCollect.PassThrough()\n          abortStream = collector\n          collector.on('collect', (data) => {\n            // TODO if the cache write fails, log a warning but return the response anyway\n            cacache.put(this.options.cachePath, this.key, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject)\n          })\n          body.unshift(collector)\n          body.unshift(this.response.body)\n        }\n      } else {\n        // if it does not fit in memory, create a tee stream and use\n        // that to pipe to both the cache and the user simultaneously\n        onResume = () => {\n          const tee = new Minipass()\n          const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts)\n          abortStream = cacheStream\n          tee.pipe(cacheStream)\n          // TODO if the cache write fails, log a warning but return the response anyway\n          cacheStream.promise().then(cacheWriteResolve, cacheWriteReject)\n          body.unshift(tee)\n          body.unshift(this.response.body)\n        }\n      }\n\n      body.once('resume', onResume)\n      body.once('end', () => body.removeListener('resume', onResume))\n      this.response.body.on('error', (err) => {\n        // the abortStream will either be a MinipassCollect if we buffer\n        // or a cacache write stream, either way be sure to listen for\n        // errors from the actual response and avoid writing data that we\n        // know to be invalid to the cache\n        abortStream.destroy(err)\n      })\n    } else\n      await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts)\n\n    // note: we do not set the x-local-cache-hash header because we do not know\n    // the hash value until after the write to the cache completes, which doesn't\n    // happen until after the response has been sent and it's too late to write\n    // the header anyway\n    this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    this.response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream')\n    this.response.headers.set('x-local-cache-status', status)\n    this.response.headers.set('x-local-cache-time', new Date().toISOString())\n    const newResponse = new Response(body, {\n      url: this.response.url,\n      status: this.response.status,\n      headers: this.response.headers,\n      counter: this.options.counter,\n    })\n    return newResponse\n  }\n\n  // use the cached data to create a response and return it\n  async respond (method, options, status) {\n    let response\n    const size = Number(this.response.headers.get('content-length'))\n    const fitsInMemory = !!size && size < MAX_MEM_SIZE\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory\n    if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n      // if the request is a HEAD, or the response is a redirect,\n      // then the metadata in the entry already includes everything\n      // we need to build a response\n      response = this.response\n    } else {\n      // we're responding with a full cached response, so create a body\n      // that reads from cacache and attach it to a new Response\n      const body = new Minipass()\n      const removeOnResume = () => body.removeListener('resume', onResume)\n      let onResume\n      if (shouldBuffer) {\n        onResume = async () => {\n          removeOnResume()\n          try {\n            const content = await cacache.get.byDigest(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            body.end(content)\n          } catch (err) {\n            if (err.code === 'EINTEGRITY')\n              await cacache.rm.content(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY')\n              await CacheEntry.invalidate(this.request, this.options)\n            body.emit('error', err)\n          }\n        }\n      } else {\n        onResume = () => {\n          const cacheStream = cacache.get.stream.byDigest(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n          cacheStream.on('error', async (err) => {\n            cacheStream.pause()\n            if (err.code === 'EINTEGRITY')\n              await cacache.rm.content(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY')\n              await CacheEntry.invalidate(this.request, this.options)\n            body.emit('error', err)\n            cacheStream.resume()\n          })\n          cacheStream.pipe(body)\n        }\n      }\n\n      body.once('resume', onResume)\n      body.once('end', removeOnResume)\n      response = new Response(body, {\n        url: this.entry.metadata.url,\n        counter: options.counter,\n        status: 200,\n        headers: {\n          ...this.policy.responseHeaders(),\n        },\n      })\n    }\n\n    response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity))\n    response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream')\n    response.headers.set('x-local-cache-status', status)\n    response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString())\n    return response\n  }\n\n  // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n  async revalidate (request, options) {\n    const revalidateRequest = new Request(request, {\n      headers: this.policy.revalidationHeaders(request),\n    })\n\n    try {\n      // NOTE: be sure to remove the headers property from the\n      // user supplied options, since we have already defined\n      // them on the new request object. if they're still in the\n      // options then those will overwrite the ones from the policy\n      var response = await remote(revalidateRequest, {\n        ...options,\n        headers: undefined,\n      })\n    } catch (err) {\n      // if the network fetch fails, return the stale\n      // cached response unless it has a cache-control\n      // of 'must-revalidate'\n      if (!this.policy.mustRevalidate)\n        return this.respond(request.method, options, 'stale')\n\n      throw err\n    }\n\n    if (this.policy.revalidated(revalidateRequest, response)) {\n      // we got a 304, write a new index to the cache and respond from cache\n      const metadata = getMetadata(request, response, options)\n      // 304 responses do not include headers that are specific to the response data\n      // since they do not include a body, so we copy values for headers that were\n      // in the old cache entry to the new one, if the new metadata does not already\n      // include that header\n      for (const name of KEEP_RESPONSE_HEADERS) {\n        if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name))\n          metadata.resHeaders[name] = this.entry.metadata.resHeaders[name]\n      }\n\n      try {\n        await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n          size: this.entry.size,\n          metadata,\n        })\n      } catch (err) {\n        // if updating the cache index fails, we ignore it and\n        // respond anyway\n      }\n      return this.respond(request.method, options, 'revalidated')\n    }\n\n    // if we got a modified response, create a new entry based on it\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options,\n    })\n\n    // respond with the new entry while writing it to the cache\n    return newEntry.store('updated')\n  }\n}\n\nmodule.exports = CacheEntry\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}