{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _toConsumableArray = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar stringify = require('json-stringify-safe');\nvar querystring = require('querystring');\nvar _require = require('url'),\n  URL = _require.URL,\n  URLSearchParams = _require.URLSearchParams;\nvar common = require('./common');\nvar _require2 = require('./intercept'),\n  remove = _require2.remove;\nvar matchBody = require('./match_body');\nvar fs;\ntry {\n  fs = require('fs');\n} catch (err) {\n  // do nothing, we're in the browser\n}\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   *\n   * Valid argument types for `uri`:\n   *  - A string used for strict comparisons with pathname.\n   *    The search portion of the URI may also be postfixed, in which case the search params\n   *    are striped and added via the `query` method.\n   *  - A RegExp instance that tests against only the pathname of requests.\n   *  - A synchronous function bound to this Interceptor instance. It's provided the pathname\n   *    of requests and must return a boolean denoting if the request is considered a match.\n   */\n  function Interceptor(scope, uri, method, requestBody, interceptorOptions) {\n    _classCallCheck(this, Interceptor);\n    var uriIsStr = typeof uri === 'string';\n    // Check for leading slash. Uri can be either a string or a regexp, but\n    // When enabled filteringScope ignores the passed URL entirely so we skip validation.\n\n    if (uriIsStr && !scope.scopeOptions.filteringScope && !scope.basePathname && !uri.startsWith('/') && !uri.startsWith('*')) {\n      throw Error(\"Non-wildcard URL path strings must begin with a slash (otherwise they won't match anything) (got: \".concat(uri, \")\"));\n    }\n    if (!method) {\n      throw new Error('The \"method\" parameter is required for an intercept call.');\n    }\n    this.scope = scope;\n    this.interceptorMatchHeaders = [];\n    this.method = method.toUpperCase();\n    this.uri = uri;\n    this._key = \"\".concat(this.method, \" \").concat(scope.basePath).concat(scope.basePathname).concat(uriIsStr ? '' : '/').concat(uri);\n    this.basePath = this.scope.basePath;\n    this.path = uriIsStr ? scope.basePathname + uri : uri;\n    this.queries = null;\n    this.options = interceptorOptions || {};\n    this.counter = 1;\n    this._requestBody = requestBody;\n\n    //  We use lower-case header field names throughout Nock.\n    this.reqheaders = common.headersFieldNamesToLowerCase(scope.scopeOptions.reqheaders || {}, true);\n    this.badheaders = common.headersFieldsArrayToLowerCase(scope.scopeOptions.badheaders || []);\n    this.delayBodyInMs = 0;\n    this.delayConnectionInMs = 0;\n    this.optional = false;\n\n    // strip off literal query parameters if they were provided as part of the URI\n    if (uriIsStr && uri.includes('?')) {\n      // localhost is a dummy value because the URL constructor errors for only relative inputs\n      var parsedURL = new URL(this.path, 'http://localhost');\n      this.path = parsedURL.pathname;\n      this.query(parsedURL.searchParams);\n      this._key = \"\".concat(this.method, \" \").concat(scope.basePath).concat(this.path);\n    }\n  }\n  _createClass(Interceptor, [{\n    key: \"optionally\",\n    value: function optionally() {\n      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      // The default behaviour of optionally() with no arguments is to make the mock optional.\n      if (typeof flag !== 'boolean') {\n        throw new Error('Invalid arguments: argument should be a boolean');\n      }\n      this.optional = flag;\n      return this;\n    }\n  }, {\n    key: \"replyWithError\",\n    value: function replyWithError(errorMessage) {\n      this.errorMessage = errorMessage;\n      this.options = _objectSpread(_objectSpread({}, this.scope.scopeOptions), this.options);\n      this.scope.add(this._key, this);\n      return this.scope;\n    }\n  }, {\n    key: \"reply\",\n    value: function reply(statusCode, body, rawHeaders) {\n      // support the format of only passing in a callback\n      if (typeof statusCode === 'function') {\n        if (arguments.length > 1) {\n          // It's not very Javascript-y to throw an error for extra args to a function, but because\n          // of legacy behavior, this error was added to reduce confusion for those migrating.\n          throw Error('Invalid arguments. When providing a function for the first argument, .reply does not accept other arguments.');\n        }\n        this.statusCode = null;\n        this.fullReplyFunction = statusCode;\n      } else {\n        if (statusCode !== undefined && !Number.isInteger(statusCode)) {\n          throw new Error(\"Invalid \".concat(typeof statusCode, \" value for status code\"));\n        }\n        this.statusCode = statusCode || 200;\n        if (typeof body === 'function') {\n          this.replyFunction = body;\n          body = null;\n        }\n      }\n      this.options = _objectSpread(_objectSpread({}, this.scope.scopeOptions), this.options);\n      this.rawHeaders = common.headersInputToRawArray(rawHeaders);\n      if (this.scope.date) {\n        // https://tools.ietf.org/html/rfc7231#section-7.1.1.2\n        this.rawHeaders.push('Date', this.scope.date.toUTCString());\n      }\n\n      // Prepare the headers temporarily so we can make best guesses about content-encoding and content-type\n      // below as well as while the response is being processed in RequestOverrider.end().\n      // Including all the default headers is safe for our purposes because of the specific headers we introspect.\n      // A more thoughtful process is used to merge the default headers when the response headers are finally computed.\n      this.headers = common.headersArrayToObject(this.rawHeaders.concat(this.scope._defaultReplyHeaders));\n\n      //  If the content is not encoded we may need to transform the response body.\n      //  Otherwise, we leave it as it is.\n      if (body && typeof body !== 'string' && !Buffer.isBuffer(body) && !common.isStream(body) && !common.isContentEncoded(this.headers)) {\n        try {\n          body = stringify(body);\n        } catch (err) {\n          throw new Error('Error encoding response body into JSON');\n        }\n        if (!this.headers['content-type']) {\n          // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n          this.rawHeaders.push('Content-Type', 'application/json');\n        }\n      }\n      if (this.scope.contentLen) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        if (typeof body === 'string') {\n          this.rawHeaders.push('Content-Length', body.length);\n        } else if (Buffer.isBuffer(body)) {\n          this.rawHeaders.push('Content-Length', body.byteLength);\n        }\n      }\n      this.scope.logger('reply.headers:', this.headers);\n      this.scope.logger('reply.rawHeaders:', this.rawHeaders);\n      this.body = body;\n      this.scope.add(this._key, this);\n      return this.scope;\n    }\n  }, {\n    key: \"replyWithFile\",\n    value: function replyWithFile(statusCode, filePath, headers) {\n      if (!fs) {\n        throw new Error('No fs');\n      }\n      var readStream = fs.createReadStream(filePath);\n      readStream.pause();\n      this.filePath = filePath;\n      return this.reply(statusCode, readStream, headers);\n    }\n\n    // Also match request headers\n    // https://github.com/nock/nock/issues/163\n  }, {\n    key: \"reqheaderMatches\",\n    value: function reqheaderMatches(options, key) {\n      var reqHeader = this.reqheaders[key];\n      var header = options.headers[key];\n\n      // https://github.com/nock/nock/issues/399\n      // https://github.com/nock/nock/issues/822\n      if (header && typeof header !== 'string' && header.toString) {\n        header = header.toString();\n      }\n\n      // We skip 'host' header comparison unless it's available in both mock and\n      // actual request. This because 'host' may get inserted by Nock itself and\n      // then get recorded. NOTE: We use lower-case header field names throughout\n      // Nock. See https://github.com/nock/nock/pull/196.\n      if (key === 'host' && (header === undefined || reqHeader === undefined)) {\n        return true;\n      }\n      if (reqHeader !== undefined && header !== undefined) {\n        if (typeof reqHeader === 'function') {\n          return reqHeader(header);\n        } else if (common.matchStringOrRegexp(header, reqHeader)) {\n          return true;\n        }\n      }\n      this.scope.logger(\"request header field doesn't match:\", key, header, reqHeader);\n      return false;\n    }\n  }, {\n    key: \"match\",\n    value: function match(req, options, body) {\n      var _this = this;\n      // check if the logger is enabled because the stringifies can be expensive.\n      if (this.scope.logger.enabled) {\n        this.scope.logger('attempting match %s, body = %s', stringify(options), stringify(body));\n      }\n      var method = (options.method || 'GET').toUpperCase();\n      var _options$path = options.path,\n        path = _options$path === void 0 ? '/' : _options$path;\n      var matches;\n      var matchKey;\n      var proto = options.proto;\n      if (this.method !== method) {\n        this.scope.logger(\"Method did not match. Request \".concat(method, \" Interceptor \").concat(this.method));\n        return false;\n      }\n      if (this.scope.transformPathFunction) {\n        path = this.scope.transformPathFunction(path);\n      }\n      var requestMatchesFilter = function requestMatchesFilter(_ref) {\n        var name = _ref.name,\n          predicate = _ref.value;\n        var headerValue = req.getHeader(name);\n        if (typeof predicate === 'function') {\n          return predicate(headerValue);\n        } else {\n          return common.matchStringOrRegexp(headerValue, predicate);\n        }\n      };\n      if (!this.scope.matchHeaders.every(requestMatchesFilter) || !this.interceptorMatchHeaders.every(requestMatchesFilter)) {\n        this.scope.logger(\"headers don't match\");\n        return false;\n      }\n      var reqHeadersMatch = Object.keys(this.reqheaders).every(function (key) {\n        return _this.reqheaderMatches(options, key);\n      });\n      if (!reqHeadersMatch) {\n        this.scope.logger(\"headers don't match\");\n        return false;\n      }\n      if (this.scope.scopeOptions.conditionally && !this.scope.scopeOptions.conditionally()) {\n        this.scope.logger('matching failed because Scope.conditionally() did not validate');\n        return false;\n      }\n      var badHeaders = this.badheaders.filter(function (header) {\n        return header in options.headers;\n      });\n      if (badHeaders.length) {\n        var _this$scope;\n        (_this$scope = this.scope).logger.apply(_this$scope, ['request contains bad headers'].concat(_toConsumableArray(badHeaders)));\n        return false;\n      }\n\n      // Match query strings when using query()\n      if (this.queries === null) {\n        this.scope.logger('query matching skipped');\n      } else {\n        // can't rely on pathname or search being in the options, but path has a default\n        var _path$split = path.split('?'),\n          _path$split2 = _slicedToArray(_path$split, 2),\n          pathname = _path$split2[0],\n          search = _path$split2[1];\n        var matchQueries = this.matchQuery({\n          search: search\n        });\n        this.scope.logger(matchQueries ? 'query matching succeeded' : 'query matching failed');\n        if (!matchQueries) {\n          return false;\n        }\n\n        // If the query string was explicitly checked then subsequent checks against\n        // the path using a callback or regexp only validate the pathname.\n        path = pathname;\n      }\n\n      // If we have a filtered scope then we use it instead reconstructing the\n      // scope from the request options (proto, host and port) as these two won't\n      // necessarily match and we have to remove the scope that was matched (vs.\n      // that was defined).\n      if (this.__nock_filteredScope) {\n        matchKey = this.__nock_filteredScope;\n      } else {\n        matchKey = common.normalizeOrigin(proto, options.host, options.port);\n      }\n      if (typeof this.uri === 'function') {\n        matches = common.matchStringOrRegexp(matchKey, this.basePath) &&\n        // This is a false positive, as `uri` is not bound to `this`.\n        // eslint-disable-next-line no-useless-call\n        this.uri.call(this, path);\n      } else {\n        matches = common.matchStringOrRegexp(matchKey, this.basePath) && common.matchStringOrRegexp(path, this.path);\n      }\n      this.scope.logger(\"matching \".concat(matchKey).concat(path, \" to \").concat(this._key, \": \").concat(matches));\n      if (matches && this._requestBody !== undefined) {\n        if (this.scope.transformRequestBodyFunction) {\n          body = this.scope.transformRequestBodyFunction(body, this._requestBody);\n        }\n        matches = matchBody(options, this._requestBody, body);\n        if (!matches) {\n          this.scope.logger(\"bodies don't match: \\n\", this._requestBody, '\\n', body);\n        }\n      }\n      return matches;\n    }\n\n    /**\n     * Return true when the interceptor's method, protocol, host, port, and path\n     * match the provided options.\n     */\n  }, {\n    key: \"matchOrigin\",\n    value: function matchOrigin(options) {\n      var isPathFn = typeof this.path === 'function';\n      var isRegex = this.path instanceof RegExp;\n      var isRegexBasePath = this.scope.basePath instanceof RegExp;\n      var method = (options.method || 'GET').toUpperCase();\n      var path = options.path;\n      var proto = options.proto;\n\n      // NOTE: Do not split off the query params as the regex could use them\n      if (!isRegex) {\n        path = path ? path.split('?')[0] : '';\n      }\n      if (this.scope.transformPathFunction) {\n        path = this.scope.transformPathFunction(path);\n      }\n      var comparisonKey = isPathFn || isRegex ? this.__nock_scopeKey : this._key;\n      var matchKey = \"\".concat(method, \" \").concat(proto, \"://\").concat(options.host).concat(path);\n      if (isPathFn) {\n        return !!(matchKey.match(comparisonKey) && this.path(path));\n      }\n      if (isRegex && !isRegexBasePath) {\n        return !!matchKey.match(comparisonKey) && this.path.test(path);\n      }\n      if (isRegexBasePath) {\n        return this.scope.basePath.test(matchKey) && !!path.match(this.path);\n      }\n      return comparisonKey === matchKey;\n    }\n  }, {\n    key: \"matchHostName\",\n    value: function matchHostName(options) {\n      var basePath = this.scope.basePath;\n      if (basePath instanceof RegExp) {\n        return basePath.test(options.hostname);\n      }\n      return options.hostname === this.scope.urlParts.hostname;\n    }\n  }, {\n    key: \"matchQuery\",\n    value: function matchQuery(options) {\n      if (this.queries === true) {\n        return true;\n      }\n      var reqQueries = querystring.parse(options.search);\n      this.scope.logger('Interceptor queries: %j', this.queries);\n      this.scope.logger('    Request queries: %j', reqQueries);\n      if (typeof this.queries === 'function') {\n        return this.queries(reqQueries);\n      }\n      return common.dataEqual(this.queries, reqQueries);\n    }\n  }, {\n    key: \"filteringPath\",\n    value: function filteringPath() {\n      var _this$scope2;\n      (_this$scope2 = this.scope).filteringPath.apply(_this$scope2, arguments);\n      return this;\n    }\n\n    // TODO filtering by path is valid on the intercept level, but not filtering\n    // by request body?\n  }, {\n    key: \"markConsumed\",\n    value: function markConsumed() {\n      this.interceptionCounter++;\n      if ((this.scope.shouldPersist() || this.counter > 0) && this.interceptionCounter > 1 && this.filePath) {\n        this.body = fs.createReadStream(this.filePath);\n        this.body.pause();\n      }\n      remove(this);\n      if (!this.scope.shouldPersist() && this.counter < 1) {\n        this.scope.remove(this._key, this);\n      }\n    }\n  }, {\n    key: \"matchHeader\",\n    value: function matchHeader(name, value) {\n      this.interceptorMatchHeaders.push({\n        name: name,\n        value: value\n      });\n      return this;\n    }\n  }, {\n    key: \"basicAuth\",\n    value: function basicAuth(_ref2) {\n      var user = _ref2.user,\n        _ref2$pass = _ref2.pass,\n        pass = _ref2$pass === void 0 ? '' : _ref2$pass;\n      var encoded = Buffer.from(\"\".concat(user, \":\").concat(pass)).toString('base64');\n      this.matchHeader('authorization', \"Basic \".concat(encoded));\n      return this;\n    }\n\n    /**\n     * Set query strings for the interceptor\n     * @name query\n     * @param queries Object of query string name,values (accepts regexp values)\n     * @public\n     * @example\n     * // Will match 'http://zombo.com/?q=t'\n     * nock('http://zombo.com').get('/').query({q: 't'});\n     */\n  }, {\n    key: \"query\",\n    value: function query(queries) {\n      if (this.queries !== null) {\n        throw Error(\"Query parameters have already been defined\");\n      }\n\n      // Allow all query strings to match this route\n      if (queries === true) {\n        this.queries = queries;\n        return this;\n      }\n      if (typeof queries === 'function') {\n        this.queries = queries;\n        return this;\n      }\n      var strFormattingFn;\n      if (this.scope.scopeOptions.encodedQueryParams) {\n        strFormattingFn = common.percentDecode;\n      }\n      if (queries instanceof URLSearchParams) {\n        // Normalize the data into the shape that is matched against.\n        // Duplicate keys are handled by combining the values into an array.\n        queries = querystring.parse(queries.toString());\n      } else if (!common.isPlainObject(queries)) {\n        throw Error(\"Argument Error: \".concat(queries));\n      }\n      this.queries = {};\n      for (var _i = 0, _Object$entries = Object.entries(queries); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n        var formatted = common.formatQueryValue(key, value, strFormattingFn);\n        var _formatted = _slicedToArray(formatted, 2),\n          formattedKey = _formatted[0],\n          formattedValue = _formatted[1];\n        this.queries[formattedKey] = formattedValue;\n      }\n      return this;\n    }\n\n    /**\n     * Set number of times will repeat the interceptor\n     * @name times\n     * @param newCounter Number of times to repeat (should be > 0)\n     * @public\n     * @example\n     * // Will repeat mock 5 times for same king of request\n     * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');\n     */\n  }, {\n    key: \"times\",\n    value: function times(newCounter) {\n      if (newCounter < 1) {\n        return this;\n      }\n      this.counter = newCounter;\n      return this;\n    }\n\n    /**\n     * An sugar syntax for times(1)\n     * @name once\n     * @see {@link times}\n     * @public\n     * @example\n     * nock('http://zombo.com).get('/').once().reply(200, 'Ok');\n     */\n  }, {\n    key: \"once\",\n    value: function once() {\n      return this.times(1);\n    }\n\n    /**\n     * An sugar syntax for times(2)\n     * @name twice\n     * @see {@link times}\n     * @public\n     * @example\n     * nock('http://zombo.com).get('/').twice().reply(200, 'Ok');\n     */\n  }, {\n    key: \"twice\",\n    value: function twice() {\n      return this.times(2);\n    }\n\n    /**\n     * An sugar syntax for times(3).\n     * @name thrice\n     * @see {@link times}\n     * @public\n     * @example\n     * nock('http://zombo.com).get('/').thrice().reply(200, 'Ok');\n     */\n  }, {\n    key: \"thrice\",\n    value: function thrice() {\n      return this.times(3);\n    }\n\n    /**\n     * Delay the response by a certain number of ms.\n     *\n     * @param {(integer|object)} opts - Number of milliseconds to wait, or an object\n     * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent\n     * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent\n     * @return {Interceptor} - the current interceptor for chaining\n     */\n  }, {\n    key: \"delay\",\n    value: function delay(opts) {\n      var headDelay;\n      var bodyDelay;\n      if (typeof opts === 'number') {\n        headDelay = opts;\n        bodyDelay = 0;\n      } else if (typeof opts === 'object') {\n        headDelay = opts.head || 0;\n        bodyDelay = opts.body || 0;\n      } else {\n        throw new Error(\"Unexpected input opts \".concat(opts));\n      }\n      return this.delayConnection(headDelay).delayBody(bodyDelay);\n    }\n\n    /**\n     * Delay the response body by a certain number of ms.\n     *\n     * @param {integer} ms - Number of milliseconds to wait before response is sent\n     * @return {Interceptor} - the current interceptor for chaining\n     */\n  }, {\n    key: \"delayBody\",\n    value: function delayBody(ms) {\n      this.delayBodyInMs = ms;\n      return this;\n    }\n\n    /**\n     * Delay the connection by a certain number of ms.\n     *\n     * @param  {integer} ms - Number of milliseconds to wait\n     * @return {Interceptor} - the current interceptor for chaining\n     */\n  }, {\n    key: \"delayConnection\",\n    value: function delayConnection(ms) {\n      this.delayConnectionInMs = ms;\n      return this;\n    }\n  }]);\n  return Interceptor;\n}();","map":{"version":3,"names":["_slicedToArray","require","default","_toConsumableArray","_objectSpread","_classCallCheck","_createClass","stringify","querystring","_require","URL","URLSearchParams","common","_require2","remove","matchBody","fs","err","module","exports","Interceptor","scope","uri","method","requestBody","interceptorOptions","uriIsStr","scopeOptions","filteringScope","basePathname","startsWith","Error","concat","interceptorMatchHeaders","toUpperCase","_key","basePath","path","queries","options","counter","_requestBody","reqheaders","headersFieldNamesToLowerCase","badheaders","headersFieldsArrayToLowerCase","delayBodyInMs","delayConnectionInMs","optional","includes","parsedURL","pathname","query","searchParams","key","value","optionally","flag","arguments","length","undefined","replyWithError","errorMessage","add","reply","statusCode","body","rawHeaders","fullReplyFunction","Number","isInteger","replyFunction","headersInputToRawArray","date","push","toUTCString","headers","headersArrayToObject","_defaultReplyHeaders","Buffer","isBuffer","isStream","isContentEncoded","contentLen","byteLength","logger","replyWithFile","filePath","readStream","createReadStream","pause","reqheaderMatches","reqHeader","header","toString","matchStringOrRegexp","match","req","_this","enabled","_options$path","matches","matchKey","proto","transformPathFunction","requestMatchesFilter","_ref","name","predicate","headerValue","getHeader","matchHeaders","every","reqHeadersMatch","Object","keys","conditionally","badHeaders","filter","_this$scope","apply","_path$split","split","_path$split2","search","matchQueries","matchQuery","__nock_filteredScope","normalizeOrigin","host","port","call","transformRequestBodyFunction","matchOrigin","isPathFn","isRegex","RegExp","isRegexBasePath","comparisonKey","__nock_scopeKey","test","matchHostName","hostname","urlParts","reqQueries","parse","dataEqual","filteringPath","_this$scope2","markConsumed","interceptionCounter","shouldPersist","matchHeader","basicAuth","_ref2","user","_ref2$pass","pass","encoded","from","strFormattingFn","encodedQueryParams","percentDecode","isPlainObject","_i","_Object$entries","entries","_Object$entries$_i","formatted","formatQueryValue","_formatted","formattedKey","formattedValue","times","newCounter","once","twice","thrice","delay","opts","headDelay","bodyDelay","head","delayConnection","delayBody","ms"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/nock/lib/interceptor.js"],"sourcesContent":["'use strict'\n\nconst stringify = require('json-stringify-safe')\nconst querystring = require('querystring')\nconst { URL, URLSearchParams } = require('url')\n\nconst common = require('./common')\nconst { remove } = require('./intercept')\nconst matchBody = require('./match_body')\n\nlet fs\ntry {\n  fs = require('fs')\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\nmodule.exports = class Interceptor {\n  /**\n   *\n   * Valid argument types for `uri`:\n   *  - A string used for strict comparisons with pathname.\n   *    The search portion of the URI may also be postfixed, in which case the search params\n   *    are striped and added via the `query` method.\n   *  - A RegExp instance that tests against only the pathname of requests.\n   *  - A synchronous function bound to this Interceptor instance. It's provided the pathname\n   *    of requests and must return a boolean denoting if the request is considered a match.\n   */\n  constructor(scope, uri, method, requestBody, interceptorOptions) {\n    const uriIsStr = typeof uri === 'string'\n    // Check for leading slash. Uri can be either a string or a regexp, but\n    // When enabled filteringScope ignores the passed URL entirely so we skip validation.\n\n    if (\n      uriIsStr &&\n      !scope.scopeOptions.filteringScope &&\n      !scope.basePathname &&\n      !uri.startsWith('/') &&\n      !uri.startsWith('*')\n    ) {\n      throw Error(\n        `Non-wildcard URL path strings must begin with a slash (otherwise they won't match anything) (got: ${uri})`\n      )\n    }\n\n    if (!method) {\n      throw new Error(\n        'The \"method\" parameter is required for an intercept call.'\n      )\n    }\n\n    this.scope = scope\n    this.interceptorMatchHeaders = []\n    this.method = method.toUpperCase()\n    this.uri = uri\n    this._key = `${this.method} ${scope.basePath}${scope.basePathname}${\n      uriIsStr ? '' : '/'\n    }${uri}`\n    this.basePath = this.scope.basePath\n    this.path = uriIsStr ? scope.basePathname + uri : uri\n    this.queries = null\n\n    this.options = interceptorOptions || {}\n    this.counter = 1\n    this._requestBody = requestBody\n\n    //  We use lower-case header field names throughout Nock.\n    this.reqheaders = common.headersFieldNamesToLowerCase(\n      scope.scopeOptions.reqheaders || {},\n      true\n    )\n    this.badheaders = common.headersFieldsArrayToLowerCase(\n      scope.scopeOptions.badheaders || []\n    )\n\n    this.delayBodyInMs = 0\n    this.delayConnectionInMs = 0\n\n    this.optional = false\n\n    // strip off literal query parameters if they were provided as part of the URI\n    if (uriIsStr && uri.includes('?')) {\n      // localhost is a dummy value because the URL constructor errors for only relative inputs\n      const parsedURL = new URL(this.path, 'http://localhost')\n      this.path = parsedURL.pathname\n      this.query(parsedURL.searchParams)\n      this._key = `${this.method} ${scope.basePath}${this.path}`\n    }\n  }\n\n  optionally(flag = true) {\n    // The default behaviour of optionally() with no arguments is to make the mock optional.\n    if (typeof flag !== 'boolean') {\n      throw new Error('Invalid arguments: argument should be a boolean')\n    }\n\n    this.optional = flag\n\n    return this\n  }\n\n  replyWithError(errorMessage) {\n    this.errorMessage = errorMessage\n\n    this.options = {\n      ...this.scope.scopeOptions,\n      ...this.options,\n    }\n\n    this.scope.add(this._key, this)\n    return this.scope\n  }\n\n  reply(statusCode, body, rawHeaders) {\n    // support the format of only passing in a callback\n    if (typeof statusCode === 'function') {\n      if (arguments.length > 1) {\n        // It's not very Javascript-y to throw an error for extra args to a function, but because\n        // of legacy behavior, this error was added to reduce confusion for those migrating.\n        throw Error(\n          'Invalid arguments. When providing a function for the first argument, .reply does not accept other arguments.'\n        )\n      }\n      this.statusCode = null\n      this.fullReplyFunction = statusCode\n    } else {\n      if (statusCode !== undefined && !Number.isInteger(statusCode)) {\n        throw new Error(`Invalid ${typeof statusCode} value for status code`)\n      }\n\n      this.statusCode = statusCode || 200\n      if (typeof body === 'function') {\n        this.replyFunction = body\n        body = null\n      }\n    }\n\n    this.options = {\n      ...this.scope.scopeOptions,\n      ...this.options,\n    }\n\n    this.rawHeaders = common.headersInputToRawArray(rawHeaders)\n\n    if (this.scope.date) {\n      // https://tools.ietf.org/html/rfc7231#section-7.1.1.2\n      this.rawHeaders.push('Date', this.scope.date.toUTCString())\n    }\n\n    // Prepare the headers temporarily so we can make best guesses about content-encoding and content-type\n    // below as well as while the response is being processed in RequestOverrider.end().\n    // Including all the default headers is safe for our purposes because of the specific headers we introspect.\n    // A more thoughtful process is used to merge the default headers when the response headers are finally computed.\n    this.headers = common.headersArrayToObject(\n      this.rawHeaders.concat(this.scope._defaultReplyHeaders)\n    )\n\n    //  If the content is not encoded we may need to transform the response body.\n    //  Otherwise, we leave it as it is.\n    if (\n      body &&\n      typeof body !== 'string' &&\n      !Buffer.isBuffer(body) &&\n      !common.isStream(body) &&\n      !common.isContentEncoded(this.headers)\n    ) {\n      try {\n        body = stringify(body)\n      } catch (err) {\n        throw new Error('Error encoding response body into JSON')\n      }\n\n      if (!this.headers['content-type']) {\n        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n        this.rawHeaders.push('Content-Type', 'application/json')\n      }\n    }\n\n    if (this.scope.contentLen) {\n      // https://tools.ietf.org/html/rfc7230#section-3.3.2\n      if (typeof body === 'string') {\n        this.rawHeaders.push('Content-Length', body.length)\n      } else if (Buffer.isBuffer(body)) {\n        this.rawHeaders.push('Content-Length', body.byteLength)\n      }\n    }\n\n    this.scope.logger('reply.headers:', this.headers)\n    this.scope.logger('reply.rawHeaders:', this.rawHeaders)\n\n    this.body = body\n\n    this.scope.add(this._key, this)\n    return this.scope\n  }\n\n  replyWithFile(statusCode, filePath, headers) {\n    if (!fs) {\n      throw new Error('No fs')\n    }\n    const readStream = fs.createReadStream(filePath)\n    readStream.pause()\n    this.filePath = filePath\n    return this.reply(statusCode, readStream, headers)\n  }\n\n  // Also match request headers\n  // https://github.com/nock/nock/issues/163\n  reqheaderMatches(options, key) {\n    const reqHeader = this.reqheaders[key]\n    let header = options.headers[key]\n\n    // https://github.com/nock/nock/issues/399\n    // https://github.com/nock/nock/issues/822\n    if (header && typeof header !== 'string' && header.toString) {\n      header = header.toString()\n    }\n\n    // We skip 'host' header comparison unless it's available in both mock and\n    // actual request. This because 'host' may get inserted by Nock itself and\n    // then get recorded. NOTE: We use lower-case header field names throughout\n    // Nock. See https://github.com/nock/nock/pull/196.\n    if (key === 'host' && (header === undefined || reqHeader === undefined)) {\n      return true\n    }\n\n    if (reqHeader !== undefined && header !== undefined) {\n      if (typeof reqHeader === 'function') {\n        return reqHeader(header)\n      } else if (common.matchStringOrRegexp(header, reqHeader)) {\n        return true\n      }\n    }\n\n    this.scope.logger(\n      \"request header field doesn't match:\",\n      key,\n      header,\n      reqHeader\n    )\n    return false\n  }\n\n  match(req, options, body) {\n    // check if the logger is enabled because the stringifies can be expensive.\n    if (this.scope.logger.enabled) {\n      this.scope.logger(\n        'attempting match %s, body = %s',\n        stringify(options),\n        stringify(body)\n      )\n    }\n\n    const method = (options.method || 'GET').toUpperCase()\n    let { path = '/' } = options\n    let matches\n    let matchKey\n    const { proto } = options\n\n    if (this.method !== method) {\n      this.scope.logger(\n        `Method did not match. Request ${method} Interceptor ${this.method}`\n      )\n      return false\n    }\n\n    if (this.scope.transformPathFunction) {\n      path = this.scope.transformPathFunction(path)\n    }\n\n    const requestMatchesFilter = ({ name, value: predicate }) => {\n      const headerValue = req.getHeader(name)\n      if (typeof predicate === 'function') {\n        return predicate(headerValue)\n      } else {\n        return common.matchStringOrRegexp(headerValue, predicate)\n      }\n    }\n\n    if (\n      !this.scope.matchHeaders.every(requestMatchesFilter) ||\n      !this.interceptorMatchHeaders.every(requestMatchesFilter)\n    ) {\n      this.scope.logger(\"headers don't match\")\n      return false\n    }\n\n    const reqHeadersMatch = Object.keys(this.reqheaders).every(key =>\n      this.reqheaderMatches(options, key)\n    )\n\n    if (!reqHeadersMatch) {\n      this.scope.logger(\"headers don't match\")\n      return false\n    }\n\n    if (\n      this.scope.scopeOptions.conditionally &&\n      !this.scope.scopeOptions.conditionally()\n    ) {\n      this.scope.logger(\n        'matching failed because Scope.conditionally() did not validate'\n      )\n      return false\n    }\n\n    const badHeaders = this.badheaders.filter(\n      header => header in options.headers\n    )\n\n    if (badHeaders.length) {\n      this.scope.logger('request contains bad headers', ...badHeaders)\n      return false\n    }\n\n    // Match query strings when using query()\n    if (this.queries === null) {\n      this.scope.logger('query matching skipped')\n    } else {\n      // can't rely on pathname or search being in the options, but path has a default\n      const [pathname, search] = path.split('?')\n      const matchQueries = this.matchQuery({ search })\n\n      this.scope.logger(\n        matchQueries ? 'query matching succeeded' : 'query matching failed'\n      )\n\n      if (!matchQueries) {\n        return false\n      }\n\n      // If the query string was explicitly checked then subsequent checks against\n      // the path using a callback or regexp only validate the pathname.\n      path = pathname\n    }\n\n    // If we have a filtered scope then we use it instead reconstructing the\n    // scope from the request options (proto, host and port) as these two won't\n    // necessarily match and we have to remove the scope that was matched (vs.\n    // that was defined).\n    if (this.__nock_filteredScope) {\n      matchKey = this.__nock_filteredScope\n    } else {\n      matchKey = common.normalizeOrigin(proto, options.host, options.port)\n    }\n\n    if (typeof this.uri === 'function') {\n      matches =\n        common.matchStringOrRegexp(matchKey, this.basePath) &&\n        // This is a false positive, as `uri` is not bound to `this`.\n        // eslint-disable-next-line no-useless-call\n        this.uri.call(this, path)\n    } else {\n      matches =\n        common.matchStringOrRegexp(matchKey, this.basePath) &&\n        common.matchStringOrRegexp(path, this.path)\n    }\n\n    this.scope.logger(`matching ${matchKey}${path} to ${this._key}: ${matches}`)\n\n    if (matches && this._requestBody !== undefined) {\n      if (this.scope.transformRequestBodyFunction) {\n        body = this.scope.transformRequestBodyFunction(body, this._requestBody)\n      }\n\n      matches = matchBody(options, this._requestBody, body)\n      if (!matches) {\n        this.scope.logger(\n          \"bodies don't match: \\n\",\n          this._requestBody,\n          '\\n',\n          body\n        )\n      }\n    }\n\n    return matches\n  }\n\n  /**\n   * Return true when the interceptor's method, protocol, host, port, and path\n   * match the provided options.\n   */\n  matchOrigin(options) {\n    const isPathFn = typeof this.path === 'function'\n    const isRegex = this.path instanceof RegExp\n    const isRegexBasePath = this.scope.basePath instanceof RegExp\n\n    const method = (options.method || 'GET').toUpperCase()\n    let { path } = options\n    const { proto } = options\n\n    // NOTE: Do not split off the query params as the regex could use them\n    if (!isRegex) {\n      path = path ? path.split('?')[0] : ''\n    }\n\n    if (this.scope.transformPathFunction) {\n      path = this.scope.transformPathFunction(path)\n    }\n    const comparisonKey = isPathFn || isRegex ? this.__nock_scopeKey : this._key\n    const matchKey = `${method} ${proto}://${options.host}${path}`\n\n    if (isPathFn) {\n      return !!(matchKey.match(comparisonKey) && this.path(path))\n    }\n\n    if (isRegex && !isRegexBasePath) {\n      return !!matchKey.match(comparisonKey) && this.path.test(path)\n    }\n\n    if (isRegexBasePath) {\n      return this.scope.basePath.test(matchKey) && !!path.match(this.path)\n    }\n\n    return comparisonKey === matchKey\n  }\n\n  matchHostName(options) {\n    const { basePath } = this.scope\n\n    if (basePath instanceof RegExp) {\n      return basePath.test(options.hostname)\n    }\n\n    return options.hostname === this.scope.urlParts.hostname\n  }\n\n  matchQuery(options) {\n    if (this.queries === true) {\n      return true\n    }\n\n    const reqQueries = querystring.parse(options.search)\n    this.scope.logger('Interceptor queries: %j', this.queries)\n    this.scope.logger('    Request queries: %j', reqQueries)\n\n    if (typeof this.queries === 'function') {\n      return this.queries(reqQueries)\n    }\n\n    return common.dataEqual(this.queries, reqQueries)\n  }\n\n  filteringPath(...args) {\n    this.scope.filteringPath(...args)\n    return this\n  }\n\n  // TODO filtering by path is valid on the intercept level, but not filtering\n  // by request body?\n\n  markConsumed() {\n    this.interceptionCounter++\n\n    if (\n      (this.scope.shouldPersist() || this.counter > 0) &&\n      this.interceptionCounter > 1 &&\n      this.filePath\n    ) {\n      this.body = fs.createReadStream(this.filePath)\n      this.body.pause()\n    }\n\n    remove(this)\n\n    if (!this.scope.shouldPersist() && this.counter < 1) {\n      this.scope.remove(this._key, this)\n    }\n  }\n\n  matchHeader(name, value) {\n    this.interceptorMatchHeaders.push({ name, value })\n    return this\n  }\n\n  basicAuth({ user, pass = '' }) {\n    const encoded = Buffer.from(`${user}:${pass}`).toString('base64')\n    this.matchHeader('authorization', `Basic ${encoded}`)\n    return this\n  }\n\n  /**\n   * Set query strings for the interceptor\n   * @name query\n   * @param queries Object of query string name,values (accepts regexp values)\n   * @public\n   * @example\n   * // Will match 'http://zombo.com/?q=t'\n   * nock('http://zombo.com').get('/').query({q: 't'});\n   */\n  query(queries) {\n    if (this.queries !== null) {\n      throw Error(`Query parameters have already been defined`)\n    }\n\n    // Allow all query strings to match this route\n    if (queries === true) {\n      this.queries = queries\n      return this\n    }\n\n    if (typeof queries === 'function') {\n      this.queries = queries\n      return this\n    }\n\n    let strFormattingFn\n    if (this.scope.scopeOptions.encodedQueryParams) {\n      strFormattingFn = common.percentDecode\n    }\n\n    if (queries instanceof URLSearchParams) {\n      // Normalize the data into the shape that is matched against.\n      // Duplicate keys are handled by combining the values into an array.\n      queries = querystring.parse(queries.toString())\n    } else if (!common.isPlainObject(queries)) {\n      throw Error(`Argument Error: ${queries}`)\n    }\n\n    this.queries = {}\n    for (const [key, value] of Object.entries(queries)) {\n      const formatted = common.formatQueryValue(key, value, strFormattingFn)\n      const [formattedKey, formattedValue] = formatted\n      this.queries[formattedKey] = formattedValue\n    }\n\n    return this\n  }\n\n  /**\n   * Set number of times will repeat the interceptor\n   * @name times\n   * @param newCounter Number of times to repeat (should be > 0)\n   * @public\n   * @example\n   * // Will repeat mock 5 times for same king of request\n   * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');\n   */\n  times(newCounter) {\n    if (newCounter < 1) {\n      return this\n    }\n\n    this.counter = newCounter\n\n    return this\n  }\n\n  /**\n   * An sugar syntax for times(1)\n   * @name once\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').once().reply(200, 'Ok');\n   */\n  once() {\n    return this.times(1)\n  }\n\n  /**\n   * An sugar syntax for times(2)\n   * @name twice\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').twice().reply(200, 'Ok');\n   */\n  twice() {\n    return this.times(2)\n  }\n\n  /**\n   * An sugar syntax for times(3).\n   * @name thrice\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').thrice().reply(200, 'Ok');\n   */\n  thrice() {\n    return this.times(3)\n  }\n\n  /**\n   * Delay the response by a certain number of ms.\n   *\n   * @param {(integer|object)} opts - Number of milliseconds to wait, or an object\n   * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent\n   * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delay(opts) {\n    let headDelay\n    let bodyDelay\n    if (typeof opts === 'number') {\n      headDelay = opts\n      bodyDelay = 0\n    } else if (typeof opts === 'object') {\n      headDelay = opts.head || 0\n      bodyDelay = opts.body || 0\n    } else {\n      throw new Error(`Unexpected input opts ${opts}`)\n    }\n\n    return this.delayConnection(headDelay).delayBody(bodyDelay)\n  }\n\n  /**\n   * Delay the response body by a certain number of ms.\n   *\n   * @param {integer} ms - Number of milliseconds to wait before response is sent\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delayBody(ms) {\n    this.delayBodyInMs = ms\n    return this\n  }\n\n  /**\n   * Delay the connection by a certain number of ms.\n   *\n   * @param  {integer} ms - Number of milliseconds to wait\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delayConnection(ms) {\n    this.delayConnectionInMs = ms\n    return this\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}