{"ast":null,"code":"import _regeneratorRuntime from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/aribraun/Desktop/db-import/db-import-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { IdentityClient } from \"../client/identityClient\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { tracingClient } from \"../util/tracing\";\nimport { checkTenantId } from \"../util/checkTenantId\";\nvar logger = credentialLogger(\"UsernamePasswordCredential\");\n/**\n * Enables authentication to Azure Active Directory with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n */\nexport var UsernamePasswordCredential = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the UsernamePasswordCredential with the details\n   * needed to authenticate against Azure Active Directory with a username\n   * and password.\n   *\n   * @param tenantIdOrName - The Azure Active Directory tenant (directory) ID or name.\n   * @param clientId - The client (application) ID of an App Registration in the tenant.\n   * @param username - The user account's e-mail address (user name).\n   * @param password - The user account's account password\n   * @param options - Options for configuring the client which makes the authentication request.\n   */\n  function UsernamePasswordCredential(tenantIdOrName, clientId, username, password, options) {\n    _classCallCheck(this, UsernamePasswordCredential);\n    checkTenantId(logger, tenantIdOrName);\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantIdOrName;\n    this.clientId = clientId;\n    this.username = username;\n    this.password = password;\n  }\n  /**\n   * Authenticates with Azure Active Directory and returns an access token if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  _createClass(UsernamePasswordCredential, [{\n    key: \"getToken\",\n    value: function () {\n      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(scopes, options) {\n        var _tracingClient$startS, span, newOptions, urlSuffix, params, webResource, tokenResponse;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _tracingClient$startS = tracingClient.startSpan(\"UsernamePasswordCredential.getToken\", options), span = _tracingClient$startS.span, newOptions = _tracingClient$startS.updatedOptions;\n              _context.prev = 1;\n              urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n              params = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"password\",\n                client_id: this.clientId,\n                username: this.username,\n                password: this.password,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \")\n              });\n              webResource = createPipelineRequest({\n                url: \"\".concat(this.identityClient.authorityHost, \"/\").concat(this.tenantId, \"/\").concat(urlSuffix),\n                method: \"POST\",\n                body: params.toString(),\n                headers: createHttpHeaders({\n                  Accept: \"application/json\",\n                  \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }),\n                abortSignal: options && options.abortSignal,\n                tracingOptions: newOptions.tracingOptions\n              });\n              _context.next = 7;\n              return this.identityClient.sendTokenRequest(webResource);\n            case 7:\n              tokenResponse = _context.sent;\n              logger.getToken.info(formatSuccess(scopes));\n              return _context.abrupt(\"return\", tokenResponse && tokenResponse.accessToken || null);\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](1);\n              span.setStatus({\n                status: \"error\",\n                error: _context.t0\n              });\n              logger.getToken.info(formatError(scopes, _context.t0));\n              throw _context.t0;\n            case 17:\n              _context.prev = 17;\n              span.end();\n              return _context.finish(17);\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[1, 12, 17, 20]]);\n      }));\n      function getToken(_x, _x2) {\n        return _getToken.apply(this, arguments);\n      }\n      return getToken;\n    }()\n  }]);\n  return UsernamePasswordCredential;\n}();","map":{"version":3,"names":["createHttpHeaders","createPipelineRequest","IdentityClient","credentialLogger","formatError","formatSuccess","getIdentityTokenEndpointSuffix","tracingClient","checkTenantId","logger","UsernamePasswordCredential","tenantIdOrName","clientId","username","password","options","_classCallCheck","identityClient","tenantId","_createClass","key","value","_getToken","_asyncToGenerator","_regeneratorRuntime","mark","_callee","scopes","_tracingClient$startS","span","newOptions","urlSuffix","params","webResource","tokenResponse","wrap","_callee$","_context","prev","next","startSpan","updatedOptions","URLSearchParams","response_type","grant_type","client_id","scope","join","url","concat","authorityHost","method","body","toString","headers","Accept","abortSignal","tracingOptions","sendTokenRequest","sent","getToken","info","abrupt","accessToken","t0","setStatus","status","error","end","finish","stop","_x","_x2","apply","arguments"],"sources":["../../../src/credentials/usernamePasswordCredential.browser.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { IdentityClient } from \"../client/identityClient\";\nimport { TokenCredentialOptions } from \"../tokenCredentialOptions\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { tracingClient } from \"../util/tracing\";\nimport { checkTenantId } from \"../util/checkTenantId\";\n\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n\n/**\n * Enables authentication to Azure Active Directory with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n */\nexport class UsernamePasswordCredential implements TokenCredential {\n  private identityClient: IdentityClient;\n  private tenantId: string;\n  private clientId: string;\n  private username: string;\n  private password: string;\n\n  /**\n   * Creates an instance of the UsernamePasswordCredential with the details\n   * needed to authenticate against Azure Active Directory with a username\n   * and password.\n   *\n   * @param tenantIdOrName - The Azure Active Directory tenant (directory) ID or name.\n   * @param clientId - The client (application) ID of an App Registration in the tenant.\n   * @param username - The user account's e-mail address (user name).\n   * @param password - The user account's account password\n   * @param options - Options for configuring the client which makes the authentication request.\n   */\n  constructor(\n    tenantIdOrName: string,\n    clientId: string,\n    username: string,\n    password: string,\n    options?: TokenCredentialOptions\n  ) {\n    checkTenantId(logger, tenantIdOrName);\n\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantIdOrName;\n    this.clientId = clientId;\n    this.username = username;\n    this.password = password;\n  }\n\n  /**\n   * Authenticates with Azure Active Directory and returns an access token if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  public async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    const { span, updatedOptions: newOptions } = tracingClient.startSpan(\n      \"UsernamePasswordCredential.getToken\",\n      options\n    );\n    try {\n      const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n      const params = new URLSearchParams({\n        response_type: \"token\",\n        grant_type: \"password\",\n        client_id: this.clientId,\n        username: this.username,\n        password: this.password,\n        scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n      });\n      const webResource = createPipelineRequest({\n        url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,\n        method: \"POST\",\n        body: params.toString(),\n        headers: createHttpHeaders({\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n        }),\n        abortSignal: options && options.abortSignal,\n        tracingOptions: newOptions.tracingOptions,\n      });\n\n      const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n      logger.getToken.info(formatSuccess(scopes));\n      return (tokenResponse && tokenResponse.accessToken) || null;\n    } catch (err: any) {\n      span.setStatus({\n        status: \"error\",\n        error: err,\n      });\n      logger.getToken.info(formatError(scopes, err));\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n}\n"],"mappings":";;;;AAAA;AACA;AAGA,SAASA,iBAAiB,EAAEC,qBAAqB,QAAQ,2BAA2B;AACpF,SAASC,cAAc,QAAQ,0BAA0B;AAEzD,SAASC,gBAAgB,EAAEC,WAAW,EAAEC,aAAa,QAAQ,iBAAiB;AAC9E,SAASC,8BAA8B,QAAQ,+BAA+B;AAC9E,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,aAAa,QAAQ,uBAAuB;AAErD,IAAMC,MAAM,GAAGN,gBAAgB,CAAC,4BAA4B,CAAC;AAE7D;;;;;;AAMA,WAAaO,0BAA0B;EAOrC;;;;;;;;;;;EAWA,SAAAA,2BACEC,cAAsB,EACtBC,QAAgB,EAChBC,QAAgB,EAChBC,QAAgB,EAChBC,OAAgC;IAAAC,eAAA,OAAAN,0BAAA;IAEhCF,aAAa,CAACC,MAAM,EAAEE,cAAc,CAAC;IAErC,IAAI,CAACM,cAAc,GAAG,IAAIf,cAAc,CAACa,OAAO,CAAC;IACjD,IAAI,CAACG,QAAQ,GAAGP,cAAc;IAC9B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;EAEA;;;;;;;;;;EAAAK,YAAA,CAAAT,0BAAA;IAAAU,GAAA;IAAAC,KAAA;MAAA,IAAAC,SAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAUO,SAAAC,QACLC,MAAyB,EACzBZ,OAAyB;QAAA,IAAAa,qBAAA,EAAAC,IAAA,EAAAC,UAAA,EAAAC,SAAA,EAAAC,MAAA,EAAAC,WAAA,EAAAC,aAAA;QAAA,OAAAV,mBAAA,GAAAW,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAAX,qBAAA,GAEoBrB,aAAa,CAACiC,SAAS,CAClE,qCAAqC,EACrCzB,OAAO,CACR,EAHOc,IAAI,GAAAD,qBAAA,CAAJC,IAAI,EAAkBC,UAAU,GAAAF,qBAAA,CAA1Ba,cAAc;cAAAJ,QAAA,CAAAC,IAAA;cAKpBP,SAAS,GAAGzB,8BAA8B,CAAC,IAAI,CAACY,QAAQ,CAAC;cACzDc,MAAM,GAAG,IAAIU,eAAe,CAAC;gBACjCC,aAAa,EAAE,OAAO;gBACtBC,UAAU,EAAE,UAAU;gBACtBC,SAAS,EAAE,IAAI,CAACjC,QAAQ;gBACxBC,QAAQ,EAAE,IAAI,CAACA,QAAQ;gBACvBC,QAAQ,EAAE,IAAI,CAACA,QAAQ;gBACvBgC,KAAK,EAAE,OAAOnB,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAGA,MAAM,CAACoB,IAAI,CAAC,GAAG;eAC7D,CAAC;cACId,WAAW,GAAGhC,qBAAqB,CAAC;gBACxC+C,GAAG,KAAAC,MAAA,CAAK,IAAI,CAAChC,cAAc,CAACiC,aAAa,OAAAD,MAAA,CAAI,IAAI,CAAC/B,QAAQ,OAAA+B,MAAA,CAAIlB,SAAS,CAAE;gBACzEoB,MAAM,EAAE,MAAM;gBACdC,IAAI,EAAEpB,MAAM,CAACqB,QAAQ,EAAE;gBACvBC,OAAO,EAAEtD,iBAAiB,CAAC;kBACzBuD,MAAM,EAAE,kBAAkB;kBAC1B,cAAc,EAAE;iBACjB,CAAC;gBACFC,WAAW,EAAEzC,OAAO,IAAIA,OAAO,CAACyC,WAAW;gBAC3CC,cAAc,EAAE3B,UAAU,CAAC2B;eAC5B,CAAC;cAAApB,QAAA,CAAAE,IAAA;cAAA,OAE0B,IAAI,CAACtB,cAAc,CAACyC,gBAAgB,CAACzB,WAAW,CAAC;YAAA;cAAvEC,aAAa,GAAAG,QAAA,CAAAsB,IAAA;cACnBlD,MAAM,CAACmD,QAAQ,CAACC,IAAI,CAACxD,aAAa,CAACsB,MAAM,CAAC,CAAC;cAAC,OAAAU,QAAA,CAAAyB,MAAA,WACpC5B,aAAa,IAAIA,aAAa,CAAC6B,WAAW,IAAK,IAAI;YAAA;cAAA1B,QAAA,CAAAC,IAAA;cAAAD,QAAA,CAAA2B,EAAA,GAAA3B,QAAA;cAE3DR,IAAI,CAACoC,SAAS,CAAC;gBACbC,MAAM,EAAE,OAAO;gBACfC,KAAK,EAAA9B,QAAA,CAAA2B;eACN,CAAC;cACFvD,MAAM,CAACmD,QAAQ,CAACC,IAAI,CAACzD,WAAW,CAACuB,MAAM,EAAAU,QAAA,CAAA2B,EAAK,CAAC,CAAC;cAAC,MAAA3B,QAAA,CAAA2B,EAAA;YAAA;cAAA3B,QAAA,CAAAC,IAAA;cAG/CT,IAAI,CAACuC,GAAG,EAAE;cAAC,OAAA/B,QAAA,CAAAgC,MAAA;YAAA;YAAA;cAAA,OAAAhC,QAAA,CAAAiC,IAAA;UAAA;QAAA,GAAA5C,OAAA;MAAA,CAEd;MAAA,SAAAkC,SAAAW,EAAA,EAAAC,GAAA;QAAA,OAAAlD,SAAA,CAAAmD,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAd,QAAA;IAAA;EAAA;EAAA,OAAAlD,0BAAA;AAAA"},"metadata":{},"sourceType":"module"}