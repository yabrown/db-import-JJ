{"ast":null,"code":"'use strict';\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\nvar _assertThisInitialized = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _get = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar PackJob = /*#__PURE__*/_createClass(function PackJob(path, absolute) {\n  _classCallCheck(this, PackJob);\n  this.path = path || './';\n  this.absolute = absolute;\n  this.entry = null;\n  this.stat = null;\n  this.readdir = null;\n  this.pending = false;\n  this.ignore = false;\n  this.piped = false;\n});\nvar _require = require('minipass'),\n  Minipass = _require.Minipass;\nvar zlib = require('minizlib');\nvar ReadEntry = require('./read-entry.js');\nvar WriteEntry = require('./write-entry.js');\nvar WriteEntrySync = WriteEntry.Sync;\nvar WriteEntryTar = WriteEntry.Tar;\nvar Yallist = require('yallist');\nvar EOF = Buffer.alloc(1024);\nvar ONSTAT = Symbol('onStat');\nvar ENDED = Symbol('ended');\nvar QUEUE = Symbol('queue');\nvar CURRENT = Symbol('current');\nvar PROCESS = Symbol('process');\nvar PROCESSING = Symbol('processing');\nvar PROCESSJOB = Symbol('processJob');\nvar JOBS = Symbol('jobs');\nvar JOBDONE = Symbol('jobDone');\nvar ADDFSENTRY = Symbol('addFSEntry');\nvar ADDTARENTRY = Symbol('addTarEntry');\nvar STAT = Symbol('stat');\nvar READDIR = Symbol('readdir');\nvar ONREADDIR = Symbol('onreaddir');\nvar PIPE = Symbol('pipe');\nvar ENTRY = Symbol('entry');\nvar ENTRYOPT = Symbol('entryOpt');\nvar WRITEENTRYCLASS = Symbol('writeEntryClass');\nvar WRITE = Symbol('write');\nvar ONDRAIN = Symbol('ondrain');\nvar fs = require('fs');\nvar path = require('path');\nvar warner = require('./warn-mixin.js');\nvar normPath = require('./normalize-windows-path.js');\nvar Pack = warner( /*#__PURE__*/function (_Minipass) {\n  _inherits(Pack, _Minipass);\n  var _super = _createSuper(Pack);\n  function Pack(opt) {\n    var _thisSuper, _thisSuper2, _this;\n    _classCallCheck(this, Pack);\n    _this = _super.call(this, opt);\n    opt = opt || Object.create(null);\n    _this.opt = opt;\n    _this.file = opt.file || '';\n    _this.cwd = opt.cwd || process.cwd();\n    _this.maxReadSize = opt.maxReadSize;\n    _this.preservePaths = !!opt.preservePaths;\n    _this.strict = !!opt.strict;\n    _this.noPax = !!opt.noPax;\n    _this.prefix = normPath(opt.prefix || '');\n    _this.linkCache = opt.linkCache || new Map();\n    _this.statCache = opt.statCache || new Map();\n    _this.readdirCache = opt.readdirCache || new Map();\n    _this[WRITEENTRYCLASS] = WriteEntry;\n    if (typeof opt.onwarn === 'function') {\n      _this.on('warn', opt.onwarn);\n    }\n    _this.portable = !!opt.portable;\n    _this.zip = null;\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') {\n        opt.gzip = {};\n      }\n      if (_this.portable) {\n        opt.gzip.portable = true;\n      }\n      _this.zip = new zlib.Gzip(opt.gzip);\n      _this.zip.on('data', function (chunk) {\n        return _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"write\", _thisSuper).call(_thisSuper, chunk);\n      });\n      _this.zip.on('end', function (_) {\n        return _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"end\", _thisSuper2).call(_thisSuper2);\n      });\n      _this.zip.on('drain', function (_) {\n        return _this[ONDRAIN]();\n      });\n      _this.on('resume', function (_) {\n        return _this.zip.resume();\n      });\n    } else {\n      _this.on('drain', _this[ONDRAIN]);\n    }\n    _this.noDirRecurse = !!opt.noDirRecurse;\n    _this.follow = !!opt.follow;\n    _this.noMtime = !!opt.noMtime;\n    _this.mtime = opt.mtime || null;\n    _this.filter = typeof opt.filter === 'function' ? opt.filter : function (_) {\n      return true;\n    };\n    _this[QUEUE] = new Yallist();\n    _this[JOBS] = 0;\n    _this.jobs = +opt.jobs || 4;\n    _this[PROCESSING] = false;\n    _this[ENDED] = false;\n    return _this;\n  }\n  _createClass(Pack, [{\n    key: WRITE,\n    value: function value(chunk) {\n      return _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, chunk);\n    }\n  }, {\n    key: \"add\",\n    value: function add(path) {\n      this.write(path);\n      return this;\n    }\n  }, {\n    key: \"end\",\n    value: function end(path) {\n      if (path) {\n        this.write(path);\n      }\n      this[ENDED] = true;\n      this[PROCESS]();\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(path) {\n      if (this[ENDED]) {\n        throw new Error('write after end');\n      }\n      if (path instanceof ReadEntry) {\n        this[ADDTARENTRY](path);\n      } else {\n        this[ADDFSENTRY](path);\n      }\n      return this.flowing;\n    }\n  }, {\n    key: ADDTARENTRY,\n    value: function value(p) {\n      var _this2 = this;\n      var absolute = normPath(path.resolve(this.cwd, p.path));\n      // in this case, we don't have to wait for the stat\n      if (!this.filter(p.path, p)) {\n        p.resume();\n      } else {\n        var job = new PackJob(p.path, absolute, false);\n        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n        job.entry.on('end', function (_) {\n          return _this2[JOBDONE](job);\n        });\n        this[JOBS] += 1;\n        this[QUEUE].push(job);\n      }\n      this[PROCESS]();\n    }\n  }, {\n    key: ADDFSENTRY,\n    value: function value(p) {\n      var absolute = normPath(path.resolve(this.cwd, p));\n      this[QUEUE].push(new PackJob(p, absolute));\n      this[PROCESS]();\n    }\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var _this3 = this;\n      job.pending = true;\n      this[JOBS] += 1;\n      var stat = this.follow ? 'stat' : 'lstat';\n      fs[stat](job.absolute, function (er, stat) {\n        job.pending = false;\n        _this3[JOBS] -= 1;\n        if (er) {\n          _this3.emit('error', er);\n        } else {\n          _this3[ONSTAT](job, stat);\n        }\n      });\n    }\n  }, {\n    key: ONSTAT,\n    value: function value(job, stat) {\n      this.statCache.set(job.absolute, stat);\n      job.stat = stat;\n\n      // now we have the stat, we can filter it.\n      if (!this.filter(job.path, stat)) {\n        job.ignore = true;\n      }\n      this[PROCESS]();\n    }\n  }, {\n    key: READDIR,\n    value: function value(job) {\n      var _this4 = this;\n      job.pending = true;\n      this[JOBS] += 1;\n      fs.readdir(job.absolute, function (er, entries) {\n        job.pending = false;\n        _this4[JOBS] -= 1;\n        if (er) {\n          return _this4.emit('error', er);\n        }\n        _this4[ONREADDIR](job, entries);\n      });\n    }\n  }, {\n    key: ONREADDIR,\n    value: function value(job, entries) {\n      this.readdirCache.set(job.absolute, entries);\n      job.readdir = entries;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESS,\n    value: function value() {\n      if (this[PROCESSING]) {\n        return;\n      }\n      this[PROCESSING] = true;\n      for (var w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n        this[PROCESSJOB](w.value);\n        if (w.value.ignore) {\n          var p = w.next;\n          this[QUEUE].removeNode(w);\n          w.next = p;\n        }\n      }\n      this[PROCESSING] = false;\n      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n        if (this.zip) {\n          this.zip.end(EOF);\n        } else {\n          _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, EOF);\n          _get(_getPrototypeOf(Pack.prototype), \"end\", this).call(this);\n        }\n      }\n    }\n  }, {\n    key: CURRENT,\n    get: function get() {\n      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n  }, {\n    key: JOBDONE,\n    value: function value(job) {\n      this[QUEUE].shift();\n      this[JOBS] -= 1;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESSJOB,\n    value: function value(job) {\n      if (job.pending) {\n        return;\n      }\n      if (job.entry) {\n        if (job === this[CURRENT] && !job.piped) {\n          this[PIPE](job);\n        }\n        return;\n      }\n      if (!job.stat) {\n        if (this.statCache.has(job.absolute)) {\n          this[ONSTAT](job, this.statCache.get(job.absolute));\n        } else {\n          this[STAT](job);\n        }\n      }\n      if (!job.stat) {\n        return;\n      }\n\n      // filtered out!\n      if (job.ignore) {\n        return;\n      }\n      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n        if (this.readdirCache.has(job.absolute)) {\n          this[ONREADDIR](job, this.readdirCache.get(job.absolute));\n        } else {\n          this[READDIR](job);\n        }\n        if (!job.readdir) {\n          return;\n        }\n      }\n\n      // we know it doesn't have an entry, because that got checked above\n      job.entry = this[ENTRY](job);\n      if (!job.entry) {\n        job.ignore = true;\n        return;\n      }\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job);\n      }\n    }\n  }, {\n    key: ENTRYOPT,\n    value: function value(job) {\n      var _this5 = this;\n      return {\n        onwarn: function onwarn(code, msg, data) {\n          return _this5.warn(code, msg, data);\n        },\n        noPax: this.noPax,\n        cwd: this.cwd,\n        absolute: job.absolute,\n        preservePaths: this.preservePaths,\n        maxReadSize: this.maxReadSize,\n        strict: this.strict,\n        portable: this.portable,\n        linkCache: this.linkCache,\n        statCache: this.statCache,\n        noMtime: this.noMtime,\n        mtime: this.mtime,\n        prefix: this.prefix\n      };\n    }\n  }, {\n    key: ENTRY,\n    value: function value(job) {\n      var _this6 = this;\n      this[JOBS] += 1;\n      try {\n        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', function () {\n          return _this6[JOBDONE](job);\n        }).on('error', function (er) {\n          return _this6.emit('error', er);\n        });\n      } catch (er) {\n        this.emit('error', er);\n      }\n    }\n  }, {\n    key: ONDRAIN,\n    value: function value() {\n      if (this[CURRENT] && this[CURRENT].entry) {\n        this[CURRENT].entry.resume();\n      }\n    }\n\n    // like .pipe() but using super, because our write() is special\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this7 = this;\n      job.piped = true;\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n          _this7[ADDFSENTRY](base + entry);\n        });\n      }\n      var source = job.entry;\n      var zip = this.zip;\n      if (zip) {\n        source.on('data', function (chunk) {\n          if (!zip.write(chunk)) {\n            source.pause();\n          }\n        });\n      } else {\n        source.on('data', function (chunk) {\n          if (!_get(_getPrototypeOf(Pack.prototype), \"write\", _this7).call(_this7, chunk)) {\n            source.pause();\n          }\n        });\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.zip) {\n        this.zip.pause();\n      }\n      return _get(_getPrototypeOf(Pack.prototype), \"pause\", this).call(this);\n    }\n  }]);\n  return Pack;\n}(Minipass));\nvar PackSync = /*#__PURE__*/function (_Pack) {\n  _inherits(PackSync, _Pack);\n  var _super2 = _createSuper(PackSync);\n  function PackSync(opt) {\n    var _this8;\n    _classCallCheck(this, PackSync);\n    _this8 = _super2.call(this, opt);\n    _this8[WRITEENTRYCLASS] = WriteEntrySync;\n    return _this8;\n  }\n\n  // pause/resume are no-ops in sync streams.\n  _createClass(PackSync, [{\n    key: \"pause\",\n    value: function pause() {}\n  }, {\n    key: \"resume\",\n    value: function resume() {}\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var stat = this.follow ? 'statSync' : 'lstatSync';\n      this[ONSTAT](job, fs[stat](job.absolute));\n    }\n  }, {\n    key: READDIR,\n    value: function value(job, stat) {\n      this[ONREADDIR](job, fs.readdirSync(job.absolute));\n    }\n\n    // gotta get it all in this tick\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this9 = this;\n      var source = job.entry;\n      var zip = this.zip;\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n          _this9[ADDFSENTRY](base + entry);\n        });\n      }\n      if (zip) {\n        source.on('data', function (chunk) {\n          zip.write(chunk);\n        });\n      } else {\n        source.on('data', function (chunk) {\n          _get(_getPrototypeOf(PackSync.prototype), WRITE, _this9).call(_this9, chunk);\n        });\n      }\n    }\n  }]);\n  return PackSync;\n}(Pack);\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":{"version":3,"names":["_assertThisInitialized","require","default","_inherits","_createSuper","_get","_getPrototypeOf","_createClass","_classCallCheck","PackJob","path","absolute","entry","stat","readdir","pending","ignore","piped","_require","Minipass","zlib","ReadEntry","WriteEntry","WriteEntrySync","Sync","WriteEntryTar","Tar","Yallist","EOF","Buffer","alloc","ONSTAT","Symbol","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","fs","warner","normPath","Pack","_Minipass","_super","opt","_thisSuper","_thisSuper2","_this","call","Object","create","file","cwd","process","maxReadSize","preservePaths","strict","noPax","prefix","linkCache","Map","statCache","readdirCache","onwarn","on","portable","zip","gzip","Gzip","chunk","prototype","_","resume","noDirRecurse","follow","noMtime","mtime","filter","jobs","key","value","add","write","end","Error","flowing","p","_this2","resolve","job","push","_this3","er","emit","set","_this4","entries","w","head","next","removeNode","length","get","shift","has","isDirectory","_this5","code","msg","data","warn","_this6","_this7","forEach","base","replace","source","pause","PackSync","_Pack","_super2","_this8","readdirSync","_this9","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/tar/lib/pack.js"],"sourcesContent":["'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst { Minipass } = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') {\n        opt.gzip = {}\n      }\n      if (this.portable) {\n        opt.gzip.portable = true\n      }\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}