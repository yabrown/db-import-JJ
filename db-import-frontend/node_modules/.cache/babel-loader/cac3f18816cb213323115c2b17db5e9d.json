{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _require = require('path'),\n  dirname = _require.dirname;\nvar fileURLToPath = require('../common/file-url-to-path/index.js');\nvar fs = require('../fs.js');\nvar defaultOptions = {\n  mode: 511,\n  recursive: false\n};\nvar mkdir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path, opts) {\n    var options, makeDirectory;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _objectSpread(_objectSpread({}, defaultOptions), opts); // if we're not in recursive mode, just call the real mkdir with the path and\n          // the mode option only\n          if (options.recursive) {\n            _context2.next = 3;\n            break;\n          }\n          return _context2.abrupt(\"return\", fs.mkdir(path, options.mode));\n        case 3:\n          makeDirectory = /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dir, mode) {\n              var parent, made, stat;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    // we can't use dirname directly since these functions support URL\n                    // objects with the file: protocol as the path input, so first we get a\n                    // string path, then we can call dirname on that\n                    parent = dir != null && dir.href && dir.origin ? dirname(fileURLToPath(dir)) : dirname(dir); // if the parent is the dir itself, try to create it. anything but EISDIR\n                    // should be rethrown\n                    if (!(parent === dir)) {\n                      _context.next = 12;\n                      break;\n                    }\n                    _context.prev = 2;\n                    _context.next = 5;\n                    return fs.mkdir(dir, opts);\n                  case 5:\n                    _context.next = 11;\n                    break;\n                  case 7:\n                    _context.prev = 7;\n                    _context.t0 = _context[\"catch\"](2);\n                    if (!(_context.t0.code !== 'EISDIR')) {\n                      _context.next = 11;\n                      break;\n                    }\n                    throw _context.t0;\n                  case 11:\n                    return _context.abrupt(\"return\", undefined);\n                  case 12:\n                    _context.prev = 12;\n                    _context.next = 15;\n                    return fs.mkdir(dir, mode);\n                  case 15:\n                    return _context.abrupt(\"return\", dir);\n                  case 18:\n                    _context.prev = 18;\n                    _context.t1 = _context[\"catch\"](12);\n                    if (!(_context.t1.code === 'ENOENT')) {\n                      _context.next = 27;\n                      break;\n                    }\n                    _context.next = 23;\n                    return makeDirectory(parent, mode);\n                  case 23:\n                    made = _context.sent;\n                    _context.next = 26;\n                    return makeDirectory(dir, mode);\n                  case 26:\n                    return _context.abrupt(\"return\", made);\n                  case 27:\n                    if (!(_context.t1.code !== 'EEXIST' && _context.t1.code !== 'EROFS')) {\n                      _context.next = 29;\n                      break;\n                    }\n                    throw _context.t1;\n                  case 29:\n                    _context.prev = 29;\n                    _context.next = 32;\n                    return fs.stat(dir);\n                  case 32:\n                    stat = _context.sent;\n                    if (!stat.isDirectory()) {\n                      _context.next = 35;\n                      break;\n                    }\n                    return _context.abrupt(\"return\", undefined);\n                  case 35:\n                    _context.next = 39;\n                    break;\n                  case 37:\n                    _context.prev = 37;\n                    _context.t2 = _context[\"catch\"](29);\n                  case 39:\n                    throw _context.t1;\n                  case 40:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee, null, [[2, 7], [12, 18], [29, 37]]);\n            }));\n            return function makeDirectory(_x3, _x4) {\n              return _ref2.apply(this, arguments);\n            };\n          }();\n          return _context2.abrupt(\"return\", makeDirectory(path, options.mode));\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function mkdir(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nmodule.exports = mkdir;","map":{"version":3,"names":["_require","require","dirname","fileURLToPath","fs","defaultOptions","mode","recursive","mkdir","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","path","opts","options","makeDirectory","wrap","_callee2$","_context2","prev","next","_objectSpread","abrupt","_ref2","_callee","dir","parent","made","stat","_callee$","_context","href","origin","t0","code","undefined","t1","sent","isDirectory","t2","stop","_x3","_x4","apply","arguments","_x","_x2","module","exports"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/@npmcli/fs/lib/mkdir/polyfill.js"],"sourcesContent":["const { dirname } = require('path')\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js')\nconst fs = require('../fs.js')\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false,\n}\n\nconst mkdir = async (path, opts) => {\n  const options = { ...defaultOptions, ...opts }\n\n  // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode)\n  }\n\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin\n      ? dirname(fileURLToPath(dir))\n      : dirname(dir)\n\n    // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts)\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err\n        }\n      }\n      return undefined\n    }\n\n    try {\n      await fs.mkdir(dir, mode)\n      return dir\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode)\n        await makeDirectory(dir, mode)\n        // return the shallowest path we created, i.e. the result of creating\n        // the parent\n        return made\n      }\n\n      // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err\n      }\n\n      // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n      try {\n        const stat = await fs.stat(dir)\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined\n        }\n      } catch (_) {}\n\n      // if the thing that's there isn't a directory, then just re-throw\n      throw err\n    }\n  }\n\n  return makeDirectory(path, options.mode)\n}\n\nmodule.exports = mkdir\n"],"mappings":";;;AAAA,IAAAA,QAAA,GAAoBC,OAAO,CAAC,MAAM,CAAC;EAA3BC,OAAO,GAAAF,QAAA,CAAPE,OAAO;AAEf,IAAMC,aAAa,GAAGF,OAAO,CAAC,qCAAqC,CAAC;AACpE,IAAMG,EAAE,GAAGH,OAAO,CAAC,UAAU,CAAC;AAE9B,IAAMI,cAAc,GAAG;EACrBC,IAAI,EAAE,GAAK;EACXC,SAAS,EAAE;AACb,CAAC;AAED,IAAMC,KAAK;EAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,SAAOC,IAAI,EAAEC,IAAI;IAAA,IAAAC,OAAA,EAAAC,aAAA;IAAA,OAAAN,mBAAA,GAAAO,IAAA,UAAAC,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAC,IAAA,GAAAD,SAAA,CAAAE,IAAA;QAAA;UACvBN,OAAO,GAAAO,aAAA,CAAAA,aAAA,KAAQlB,cAAc,GAAKU,IAAI,GAE5C;UACA;UAAA,IACKC,OAAO,CAACT,SAAS;YAAAa,SAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,OAAAF,SAAA,CAAAI,MAAA,WACbpB,EAAE,CAACI,KAAK,CAACM,IAAI,EAAEE,OAAO,CAACV,IAAI,CAAC;QAAA;UAG/BW,aAAa;YAAA,IAAAQ,KAAA,GAAAf,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAc,QAAOC,GAAG,EAAErB,IAAI;cAAA,IAAAsB,MAAA,EAAAC,IAAA,EAAAC,IAAA;cAAA,OAAAnB,mBAAA,GAAAO,IAAA,UAAAa,SAAAC,QAAA;gBAAA,kBAAAA,QAAA,CAAAX,IAAA,GAAAW,QAAA,CAAAV,IAAA;kBAAA;oBACpC;oBACA;oBACA;oBACMM,MAAM,GAAGD,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACM,IAAI,IAAIN,GAAG,CAACO,MAAM,GAChDhC,OAAO,CAACC,aAAa,CAACwB,GAAG,CAAC,CAAC,GAC3BzB,OAAO,CAACyB,GAAG,CAAC,EAEhB;oBACA;oBAAA,MACIC,MAAM,KAAKD,GAAG;sBAAAK,QAAA,CAAAV,IAAA;sBAAA;oBAAA;oBAAAU,QAAA,CAAAX,IAAA;oBAAAW,QAAA,CAAAV,IAAA;oBAAA,OAERlB,EAAE,CAACI,KAAK,CAACmB,GAAG,EAAEZ,IAAI,CAAC;kBAAA;oBAAAiB,QAAA,CAAAV,IAAA;oBAAA;kBAAA;oBAAAU,QAAA,CAAAX,IAAA;oBAAAW,QAAA,CAAAG,EAAA,GAAAH,QAAA;oBAAA,MAErBA,QAAA,CAAAG,EAAA,CAAIC,IAAI,KAAK,QAAQ;sBAAAJ,QAAA,CAAAV,IAAA;sBAAA;oBAAA;oBAAA,MAAAU,QAAA,CAAAG,EAAA;kBAAA;oBAAA,OAAAH,QAAA,CAAAR,MAAA,WAIpBa,SAAS;kBAAA;oBAAAL,QAAA,CAAAX,IAAA;oBAAAW,QAAA,CAAAV,IAAA;oBAAA,OAIVlB,EAAE,CAACI,KAAK,CAACmB,GAAG,EAAErB,IAAI,CAAC;kBAAA;oBAAA,OAAA0B,QAAA,CAAAR,MAAA,WAClBG,GAAG;kBAAA;oBAAAK,QAAA,CAAAX,IAAA;oBAAAW,QAAA,CAAAM,EAAA,GAAAN,QAAA;oBAAA,MAGNA,QAAA,CAAAM,EAAA,CAAIF,IAAI,KAAK,QAAQ;sBAAAJ,QAAA,CAAAV,IAAA;sBAAA;oBAAA;oBAAAU,QAAA,CAAAV,IAAA;oBAAA,OACJL,aAAa,CAACW,MAAM,EAAEtB,IAAI,CAAC;kBAAA;oBAAxCuB,IAAI,GAAAG,QAAA,CAAAO,IAAA;oBAAAP,QAAA,CAAAV,IAAA;oBAAA,OACJL,aAAa,CAACU,GAAG,EAAErB,IAAI,CAAC;kBAAA;oBAAA,OAAA0B,QAAA,CAAAR,MAAA,WAGvBK,IAAI;kBAAA;oBAAA,MAMTG,QAAA,CAAAM,EAAA,CAAIF,IAAI,KAAK,QAAQ,IAAIJ,QAAA,CAAAM,EAAA,CAAIF,IAAI,KAAK,OAAO;sBAAAJ,QAAA,CAAAV,IAAA;sBAAA;oBAAA;oBAAA,MAAAU,QAAA,CAAAM,EAAA;kBAAA;oBAAAN,QAAA,CAAAX,IAAA;oBAAAW,QAAA,CAAAV,IAAA;oBAAA,OAQ5BlB,EAAE,CAAC0B,IAAI,CAACH,GAAG,CAAC;kBAAA;oBAAzBG,IAAI,GAAAE,QAAA,CAAAO,IAAA;oBAAA,KACNT,IAAI,CAACU,WAAW,CAAC,CAAC;sBAAAR,QAAA,CAAAV,IAAA;sBAAA;oBAAA;oBAAA,OAAAU,QAAA,CAAAR,MAAA,WAGba,SAAS;kBAAA;oBAAAL,QAAA,CAAAV,IAAA;oBAAA;kBAAA;oBAAAU,QAAA,CAAAX,IAAA;oBAAAW,QAAA,CAAAS,EAAA,GAAAT,QAAA;kBAAA;oBAAA,MAAAA,QAAA,CAAAM,EAAA;kBAAA;kBAAA;oBAAA,OAAAN,QAAA,CAAAU,IAAA;gBAAA;cAAA,GAAAhB,OAAA;YAAA,CAOvB;YAAA,gBAxDKT,aAAaA,CAAA0B,GAAA,EAAAC,GAAA;cAAA,OAAAnB,KAAA,CAAAoB,KAAA,OAAAC,SAAA;YAAA;UAAA;UAAA,OAAA1B,SAAA,CAAAI,MAAA,WA0DZP,aAAa,CAACH,IAAI,EAAEE,OAAO,CAACV,IAAI,CAAC;QAAA;QAAA;UAAA,OAAAc,SAAA,CAAAsB,IAAA;MAAA;IAAA,GAAA7B,QAAA;EAAA,CACzC;EAAA,gBApEKL,KAAKA,CAAAuC,EAAA,EAAAC,GAAA;IAAA,OAAAvC,IAAA,CAAAoC,KAAA,OAAAC,SAAA;EAAA;AAAA,GAoEV;AAEDG,MAAM,CAACC,OAAO,GAAG1C,KAAK"},"metadata":{},"sourceType":"script"}