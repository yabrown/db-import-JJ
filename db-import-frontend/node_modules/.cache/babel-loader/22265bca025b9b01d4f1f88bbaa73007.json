{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createClass = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/Users/aribraun/Desktop/db-import/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nvar util = require('util');\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar Minipass = require('minipass');\nvar path = require('path');\nvar ssri = require('ssri');\nvar uniqueFilename = require('unique-filename');\nvar _require = require('./util/disposer'),\n  disposer = _require.disposer;\nvar contentPath = require('./content/path');\nvar fixOwner = require('./util/fix-owner');\nvar hashToSegments = require('./util/hash-to-segments');\nvar indexV = require('../package.json')['cache-version'].index;\nvar moveFile = require('@npmcli/move-file');\nvar _rimraf = require('rimraf');\nvar rimraf = util.promisify(_rimraf);\nrimraf.sync = _rimraf.sync;\nvar appendFile = util.promisify(fs.appendFile);\nvar readFile = util.promisify(fs.readFile);\nvar readdir = util.promisify(fs.readdir);\nvar writeFile = util.promisify(fs.writeFile);\nmodule.exports.NotFoundError = /*#__PURE__*/function (_Error) {\n  _inherits(NotFoundError, _Error);\n  var _super = _createSuper(NotFoundError);\n  function NotFoundError(cache, key) {\n    var _this;\n    _classCallCheck(this, NotFoundError);\n    _this = _super.call(this, \"No cache entry for \".concat(key, \" found in \").concat(cache));\n    _this.code = 'ENOENT';\n    _this.cache = cache;\n    _this.key = key;\n    return _this;\n  }\n  return _createClass(NotFoundError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nmodule.exports.compact = compact;\nfunction compact(_x, _x2, _x3) {\n  return _compact.apply(this, arguments);\n}\nfunction _compact() {\n  _compact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(cache, key, matchFn) {\n    var opts,\n      bucket,\n      entries,\n      newEntries,\n      _loop,\n      i,\n      _ret,\n      newIndex,\n      setup,\n      teardown,\n      write,\n      _args5 = arguments;\n    return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          opts = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : {};\n          bucket = bucketPath(cache, key);\n          _context5.next = 4;\n          return bucketEntries(bucket);\n        case 4:\n          entries = _context5.sent;\n          newEntries = []; // we loop backwards because the bottom-most result is the newest\n          // since we add new entries with appendFile\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var entry;\n            return _regeneratorRuntime().wrap(function _loop$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  entry = entries[i]; // a null integrity could mean either a delete was appended\n                  // or the user has simply stored an index that does not map\n                  // to any content. we determine if the user wants to keep the\n                  // null integrity based on the validateEntry function passed in options.\n                  // if the integrity is null and no validateEntry is provided, we break\n                  // as we consider the null integrity to be a deletion of everything\n                  // that came before it.\n                  if (!(entry.integrity === null && !opts.validateEntry)) {\n                    _context4.next = 3;\n                    break;\n                  }\n                  return _context4.abrupt(\"return\", \"break\");\n                case 3:\n                  // if this entry is valid, and it is either the first entry or\n                  // the newEntries array doesn't already include an entry that\n                  // matches this one based on the provided matchFn, then we add\n                  // it to the beginning of our list\n                  if ((!opts.validateEntry || opts.validateEntry(entry) === true) && (newEntries.length === 0 || !newEntries.find(function (oldEntry) {\n                    return matchFn(oldEntry, entry);\n                  }))) newEntries.unshift(entry);\n                case 4:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _loop);\n          });\n          i = entries.length - 1;\n        case 8:\n          if (!(i >= 0)) {\n            _context5.next = 16;\n            break;\n          }\n          return _context5.delegateYield(_loop(), \"t0\", 10);\n        case 10:\n          _ret = _context5.t0;\n          if (!(_ret === \"break\")) {\n            _context5.next = 13;\n            break;\n          }\n          return _context5.abrupt(\"break\", 16);\n        case 13:\n          --i;\n          _context5.next = 8;\n          break;\n        case 16:\n          newIndex = '\\n' + newEntries.map(function (entry) {\n            var stringified = JSON.stringify(entry);\n            var hash = hashEntry(stringified);\n            return \"\".concat(hash, \"\\t\").concat(stringified);\n          }).join('\\n');\n          setup = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var target;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) switch (_context.prev = _context.next) {\n                  case 0:\n                    target = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n                    _context.next = 3;\n                    return fixOwner.mkdirfix(cache, path.dirname(target));\n                  case 3:\n                    return _context.abrupt(\"return\", {\n                      target: target,\n                      moved: false\n                    });\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }, _callee);\n            }));\n            return function setup() {\n              return _ref.apply(this, arguments);\n            };\n          }();\n          teardown = /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tmp) {\n              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                while (1) switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (tmp.moved) {\n                      _context2.next = 2;\n                      break;\n                    }\n                    return _context2.abrupt(\"return\", rimraf(tmp.target));\n                  case 2:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }, _callee2);\n            }));\n            return function teardown(_x4) {\n              return _ref2.apply(this, arguments);\n            };\n          }();\n          write = /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tmp) {\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.next = 2;\n                    return writeFile(tmp.target, newIndex, {\n                      flag: 'wx'\n                    });\n                  case 2:\n                    _context3.next = 4;\n                    return fixOwner.mkdirfix(cache, path.dirname(bucket));\n                  case 4:\n                    _context3.next = 6;\n                    return moveFile(tmp.target, bucket);\n                  case 6:\n                    tmp.moved = true;\n                    _context3.prev = 7;\n                    _context3.next = 10;\n                    return fixOwner.chownr(cache, bucket);\n                  case 10:\n                    _context3.next = 16;\n                    break;\n                  case 12:\n                    _context3.prev = 12;\n                    _context3.t0 = _context3[\"catch\"](7);\n                    if (!(_context3.t0.code !== 'ENOENT')) {\n                      _context3.next = 16;\n                      break;\n                    }\n                    throw _context3.t0;\n                  case 16:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _callee3, null, [[7, 12]]);\n            }));\n            return function write(_x5) {\n              return _ref3.apply(this, arguments);\n            };\n          }(); // write the file atomically\n          _context5.next = 22;\n          return disposer(setup(), teardown, write);\n        case 22:\n          return _context5.abrupt(\"return\", newEntries.reverse().map(function (entry) {\n            return formatEntry(cache, entry, true);\n          }));\n        case 23:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee4);\n  }));\n  return _compact.apply(this, arguments);\n}\nmodule.exports.insert = insert;\nfunction insert(cache, key, integrity) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var metadata = opts.metadata,\n    size = opts.size;\n  var bucket = bucketPath(cache, key);\n  var entry = {\n    key: key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: size,\n    metadata: metadata\n  };\n  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(function () {\n    var stringified = JSON.stringify(entry);\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with\n    // this.\n    return appendFile(bucket, \"\\n\".concat(hashEntry(stringified), \"\\t\").concat(stringified));\n  }).then(function () {\n    return fixOwner.chownr(cache, bucket);\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') return undefined;\n    throw err;\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(function () {\n    return formatEntry(cache, entry);\n  });\n}\nmodule.exports.insert.sync = insertSync;\nfunction insertSync(cache, key, integrity) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var metadata = opts.metadata,\n    size = opts.size;\n  var bucket = bucketPath(cache, key);\n  var entry = {\n    key: key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: size,\n    metadata: metadata\n  };\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));\n  var stringified = JSON.stringify(entry);\n  fs.appendFileSync(bucket, \"\\n\".concat(hashEntry(stringified), \"\\t\").concat(stringified));\n  try {\n    fixOwner.chownr.sync(cache, bucket);\n  } catch (err) {\n    if (err.code !== 'ENOENT') throw err;\n  }\n  return formatEntry(cache, entry);\n}\nmodule.exports.find = find;\nfunction find(cache, key) {\n  var bucket = bucketPath(cache, key);\n  return bucketEntries(bucket).then(function (entries) {\n    return entries.reduce(function (latest, next) {\n      if (next && next.key === key) return formatEntry(cache, next);else return latest;\n    }, null);\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') return null;else throw err;\n  });\n}\nmodule.exports.find.sync = findSync;\nfunction findSync(cache, key) {\n  var bucket = bucketPath(cache, key);\n  try {\n    return bucketEntriesSync(bucket).reduce(function (latest, next) {\n      if (next && next.key === key) return formatEntry(cache, next);else return latest;\n    }, null);\n  } catch (err) {\n    if (err.code === 'ENOENT') return null;else throw err;\n  }\n}\nmodule.exports.delete = del;\nfunction del(cache, key) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!opts.removeFully) return insert(cache, key, null, opts);\n  var bucket = bucketPath(cache, key);\n  return rimraf(bucket);\n}\nmodule.exports.delete.sync = delSync;\nfunction delSync(cache, key) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!opts.removeFully) return insertSync(cache, key, null, opts);\n  var bucket = bucketPath(cache, key);\n  return rimraf.sync(bucket);\n}\nmodule.exports.lsStream = lsStream;\nfunction lsStream(cache) {\n  var indexDir = bucketDir(cache);\n  var stream = new Minipass({\n    objectMode: true\n  });\n  readdirOrEmpty(indexDir).then(function (buckets) {\n    return Promise.all(buckets.map(function (bucket) {\n      var bucketPath = path.join(indexDir, bucket);\n      return readdirOrEmpty(bucketPath).then(function (subbuckets) {\n        return Promise.all(subbuckets.map(function (subbucket) {\n          var subbucketPath = path.join(bucketPath, subbucket);\n\n          // \"/cachename/<bucket 0xFF>/<bucket 0xFF>./*\"\n          return readdirOrEmpty(subbucketPath).then(function (entries) {\n            return Promise.all(entries.map(function (entry) {\n              var entryPath = path.join(subbucketPath, entry);\n              return bucketEntries(entryPath).then(function (entries) {\n                return (\n                  // using a Map here prevents duplicate keys from\n                  // showing up twice, I guess?\n                  entries.reduce(function (acc, entry) {\n                    acc.set(entry.key, entry);\n                    return acc;\n                  }, new Map())\n                );\n              }).then(function (reduced) {\n                // reduced is a map of key => entry\n                var _iterator = _createForOfIteratorHelper(reduced.values()),\n                  _step;\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var _entry = _step.value;\n                    var formatted = formatEntry(cache, _entry);\n                    if (formatted) stream.write(formatted);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n              }).catch(function (err) {\n                if (err.code === 'ENOENT') return undefined;\n                throw err;\n              });\n            }));\n          });\n        }));\n      });\n    }));\n  }).then(function () {\n    return stream.end();\n  }, function (err) {\n    return stream.emit('error', err);\n  });\n  return stream;\n}\nmodule.exports.ls = ls;\nfunction ls(cache) {\n  return lsStream(cache).collect().then(function (entries) {\n    return entries.reduce(function (acc, xs) {\n      acc[xs.key] = xs;\n      return acc;\n    }, {});\n  });\n}\nmodule.exports.bucketEntries = bucketEntries;\nfunction bucketEntries(bucket, filter) {\n  return readFile(bucket, 'utf8').then(function (data) {\n    return _bucketEntries(data, filter);\n  });\n}\nmodule.exports.bucketEntries.sync = bucketEntriesSync;\nfunction bucketEntriesSync(bucket, filter) {\n  var data = fs.readFileSync(bucket, 'utf8');\n  return _bucketEntries(data, filter);\n}\nfunction _bucketEntries(data, filter) {\n  var entries = [];\n  data.split('\\n').forEach(function (entry) {\n    if (!entry) return;\n    var pieces = entry.split('\\t');\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return;\n    }\n    var obj;\n    try {\n      obj = JSON.parse(pieces[1]);\n    } catch (e) {\n      // Entry is corrupted!\n      return;\n    }\n    if (obj) entries.push(obj);\n  });\n  return entries;\n}\nmodule.exports.bucketDir = bucketDir;\nfunction bucketDir(cache) {\n  return path.join(cache, \"index-v\".concat(indexV));\n}\nmodule.exports.bucketPath = bucketPath;\nfunction bucketPath(cache, key) {\n  var hashed = hashKey(key);\n  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));\n}\nmodule.exports.hashKey = hashKey;\nfunction hashKey(key) {\n  return hash(key, 'sha256');\n}\nmodule.exports.hashEntry = hashEntry;\nfunction hashEntry(str) {\n  return hash(str, 'sha1');\n}\nfunction hash(str, digest) {\n  return crypto.createHash(digest).update(str).digest('hex');\n}\nfunction formatEntry(cache, entry, keepAll) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity && !keepAll) return null;\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: entry.integrity ? contentPath(cache, entry.integrity) : undefined,\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  };\n}\nfunction readdirOrEmpty(dir) {\n  return readdir(dir).catch(function (err) {\n    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return [];\n    throw err;\n  });\n}","map":{"version":3,"names":["_regeneratorRuntime","require","default","_createForOfIteratorHelper","_asyncToGenerator","_createClass","_classCallCheck","_inherits","_createSuper","_wrapNativeSuper","util","crypto","fs","Minipass","path","ssri","uniqueFilename","_require","disposer","contentPath","fixOwner","hashToSegments","indexV","index","moveFile","_rimraf","rimraf","promisify","sync","appendFile","readFile","readdir","writeFile","module","exports","NotFoundError","_Error","_super","cache","key","_this","call","concat","code","Error","compact","_x","_x2","_x3","_compact","apply","arguments","mark","_callee4","matchFn","opts","bucket","entries","newEntries","_loop","i","_ret","newIndex","setup","teardown","write","_args5","wrap","_callee4$","_context5","prev","next","length","undefined","bucketPath","bucketEntries","sent","entry","_loop$","_context4","integrity","validateEntry","abrupt","find","oldEntry","unshift","stop","delegateYield","t0","map","stringified","JSON","stringify","hash","hashEntry","join","_ref","_callee","target","_callee$","_context","tmpPrefix","mkdirfix","dirname","moved","_ref2","_callee2","tmp","_callee2$","_context2","_x4","_ref3","_callee3","_callee3$","_context3","flag","chownr","_x5","reverse","formatEntry","insert","metadata","size","time","Date","now","then","catch","err","insertSync","appendFileSync","reduce","latest","findSync","bucketEntriesSync","delete","del","removeFully","delSync","lsStream","indexDir","bucketDir","stream","objectMode","readdirOrEmpty","buckets","Promise","all","subbuckets","subbucket","subbucketPath","entryPath","acc","set","Map","reduced","_iterator","values","_step","s","n","done","value","formatted","e","f","end","emit","ls","collect","xs","filter","data","_bucketEntries","readFileSync","split","forEach","pieces","obj","parse","push","hashed","hashKey","str","digest","createHash","update","keepAll","dir"],"sources":["/Users/aribraun/Desktop/db-import/node_modules/cacache/lib/entry-index.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst Minipass = require('minipass')\nconst path = require('path')\nconst ssri = require('ssri')\nconst uniqueFilename = require('unique-filename')\n\nconst { disposer } = require('./util/disposer')\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst hashToSegments = require('./util/hash-to-segments')\nconst indexV = require('../package.json')['cache-version'].index\nconst moveFile = require('@npmcli/move-file')\nconst _rimraf = require('rimraf')\nconst rimraf = util.promisify(_rimraf)\nrimraf.sync = _rimraf.sync\n\nconst appendFile = util.promisify(fs.appendFile)\nconst readFile = util.promisify(fs.readFile)\nconst readdir = util.promisify(fs.readdir)\nconst writeFile = util.promisify(fs.writeFile)\n\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor (cache, key) {\n    super(`No cache entry for ${key} found in ${cache}`)\n    this.code = 'ENOENT'\n    this.cache = cache\n    this.key = key\n  }\n}\n\nmodule.exports.compact = compact\n\nasync function compact (cache, key, matchFn, opts = {}) {\n  const bucket = bucketPath(cache, key)\n  const entries = await bucketEntries(bucket)\n  const newEntries = []\n  // we loop backwards because the bottom-most result is the newest\n  // since we add new entries with appendFile\n  for (let i = entries.length - 1; i >= 0; --i) {\n    const entry = entries[i]\n    // a null integrity could mean either a delete was appended\n    // or the user has simply stored an index that does not map\n    // to any content. we determine if the user wants to keep the\n    // null integrity based on the validateEntry function passed in options.\n    // if the integrity is null and no validateEntry is provided, we break\n    // as we consider the null integrity to be a deletion of everything\n    // that came before it.\n    if (entry.integrity === null && !opts.validateEntry)\n      break\n\n    // if this entry is valid, and it is either the first entry or\n    // the newEntries array doesn't already include an entry that\n    // matches this one based on the provided matchFn, then we add\n    // it to the beginning of our list\n    if ((!opts.validateEntry || opts.validateEntry(entry) === true) &&\n      (newEntries.length === 0 ||\n        !newEntries.find((oldEntry) => matchFn(oldEntry, entry))))\n      newEntries.unshift(entry)\n  }\n\n  const newIndex = '\\n' + newEntries.map((entry) => {\n    const stringified = JSON.stringify(entry)\n    const hash = hashEntry(stringified)\n    return `${hash}\\t${stringified}`\n  }).join('\\n')\n\n  const setup = async () => {\n    const target = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix)\n    await fixOwner.mkdirfix(cache, path.dirname(target))\n    return {\n      target,\n      moved: false,\n    }\n  }\n\n  const teardown = async (tmp) => {\n    if (!tmp.moved)\n      return rimraf(tmp.target)\n  }\n\n  const write = async (tmp) => {\n    await writeFile(tmp.target, newIndex, { flag: 'wx' })\n    await fixOwner.mkdirfix(cache, path.dirname(bucket))\n    // we use @npmcli/move-file directly here because we\n    // want to overwrite the existing file\n    await moveFile(tmp.target, bucket)\n    tmp.moved = true\n    try {\n      await fixOwner.chownr(cache, bucket)\n    } catch (err) {\n      if (err.code !== 'ENOENT')\n        throw err\n    }\n  }\n\n  // write the file atomically\n  await disposer(setup(), teardown, write)\n\n  // we reverse the list we generated such that the newest\n  // entries come first in order to make looping through them easier\n  // the true passed to formatEntry tells it to keep null\n  // integrity values, if they made it this far it's because\n  // validateEntry returned true, and as such we should return it\n  return newEntries.reverse().map((entry) => formatEntry(cache, entry, true))\n}\n\nmodule.exports.insert = insert\n\nfunction insert (cache, key, integrity, opts = {}) {\n  const { metadata, size } = opts\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size,\n    metadata,\n  }\n  return fixOwner\n    .mkdirfix(cache, path.dirname(bucket))\n    .then(() => {\n      const stringified = JSON.stringify(entry)\n      // NOTE - Cleverness ahoy!\n      //\n      // This works because it's tremendously unlikely for an entry to corrupt\n      // another while still preserving the string length of the JSON in\n      // question. So, we just slap the length in there and verify it on read.\n      //\n      // Thanks to @isaacs for the whiteboarding session that ended up with\n      // this.\n      return appendFile(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`)\n    })\n    .then(() => fixOwner.chownr(cache, bucket))\n    .catch((err) => {\n      if (err.code === 'ENOENT')\n        return undefined\n\n      throw err\n      // There's a class of race conditions that happen when things get deleted\n      // during fixOwner, or between the two mkdirfix/chownr calls.\n      //\n      // It's perfectly fine to just not bother in those cases and lie\n      // that the index entry was written. Because it's a cache.\n    })\n    .then(() => {\n      return formatEntry(cache, entry)\n    })\n}\n\nmodule.exports.insert.sync = insertSync\n\nfunction insertSync (cache, key, integrity, opts = {}) {\n  const { metadata, size } = opts\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size,\n    metadata,\n  }\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket))\n  const stringified = JSON.stringify(entry)\n  fs.appendFileSync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`)\n  try {\n    fixOwner.chownr.sync(cache, bucket)\n  } catch (err) {\n    if (err.code !== 'ENOENT')\n      throw err\n  }\n  return formatEntry(cache, entry)\n}\n\nmodule.exports.find = find\n\nfunction find (cache, key) {\n  const bucket = bucketPath(cache, key)\n  return bucketEntries(bucket)\n    .then((entries) => {\n      return entries.reduce((latest, next) => {\n        if (next && next.key === key)\n          return formatEntry(cache, next)\n        else\n          return latest\n      }, null)\n    })\n    .catch((err) => {\n      if (err.code === 'ENOENT')\n        return null\n      else\n        throw err\n    })\n}\n\nmodule.exports.find.sync = findSync\n\nfunction findSync (cache, key) {\n  const bucket = bucketPath(cache, key)\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key)\n        return formatEntry(cache, next)\n      else\n        return latest\n    }, null)\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return null\n    else\n      throw err\n  }\n}\n\nmodule.exports.delete = del\n\nfunction del (cache, key, opts = {}) {\n  if (!opts.removeFully)\n    return insert(cache, key, null, opts)\n\n  const bucket = bucketPath(cache, key)\n  return rimraf(bucket)\n}\n\nmodule.exports.delete.sync = delSync\n\nfunction delSync (cache, key, opts = {}) {\n  if (!opts.removeFully)\n    return insertSync(cache, key, null, opts)\n\n  const bucket = bucketPath(cache, key)\n  return rimraf.sync(bucket)\n}\n\nmodule.exports.lsStream = lsStream\n\nfunction lsStream (cache) {\n  const indexDir = bucketDir(cache)\n  const stream = new Minipass({ objectMode: true })\n\n  readdirOrEmpty(indexDir).then(buckets => Promise.all(\n    buckets.map(bucket => {\n      const bucketPath = path.join(indexDir, bucket)\n      return readdirOrEmpty(bucketPath).then(subbuckets => Promise.all(\n        subbuckets.map(subbucket => {\n          const subbucketPath = path.join(bucketPath, subbucket)\n\n          // \"/cachename/<bucket 0xFF>/<bucket 0xFF>./*\"\n          return readdirOrEmpty(subbucketPath).then(entries => Promise.all(\n            entries.map(entry => {\n              const entryPath = path.join(subbucketPath, entry)\n              return bucketEntries(entryPath).then(entries =>\n                // using a Map here prevents duplicate keys from\n                // showing up twice, I guess?\n                entries.reduce((acc, entry) => {\n                  acc.set(entry.key, entry)\n                  return acc\n                }, new Map())\n              ).then(reduced => {\n                // reduced is a map of key => entry\n                for (const entry of reduced.values()) {\n                  const formatted = formatEntry(cache, entry)\n                  if (formatted)\n                    stream.write(formatted)\n                }\n              }).catch(err => {\n                if (err.code === 'ENOENT')\n                  return undefined\n                throw err\n              })\n            })\n          ))\n        })\n      ))\n    })\n  ))\n    .then(\n      () => stream.end(),\n      err => stream.emit('error', err)\n    )\n\n  return stream\n}\n\nmodule.exports.ls = ls\n\nfunction ls (cache) {\n  return lsStream(cache).collect().then(entries =>\n    entries.reduce((acc, xs) => {\n      acc[xs.key] = xs\n      return acc\n    }, {})\n  )\n}\n\nmodule.exports.bucketEntries = bucketEntries\n\nfunction bucketEntries (bucket, filter) {\n  return readFile(bucket, 'utf8').then((data) => _bucketEntries(data, filter))\n}\n\nmodule.exports.bucketEntries.sync = bucketEntriesSync\n\nfunction bucketEntriesSync (bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8')\n  return _bucketEntries(data, filter)\n}\n\nfunction _bucketEntries (data, filter) {\n  const entries = []\n  data.split('\\n').forEach((entry) => {\n    if (!entry)\n      return\n\n    const pieces = entry.split('\\t')\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return\n    }\n    let obj\n    try {\n      obj = JSON.parse(pieces[1])\n    } catch (e) {\n      // Entry is corrupted!\n      return\n    }\n    if (obj)\n      entries.push(obj)\n  })\n  return entries\n}\n\nmodule.exports.bucketDir = bucketDir\n\nfunction bucketDir (cache) {\n  return path.join(cache, `index-v${indexV}`)\n}\n\nmodule.exports.bucketPath = bucketPath\n\nfunction bucketPath (cache, key) {\n  const hashed = hashKey(key)\n  return path.join.apply(\n    path,\n    [bucketDir(cache)].concat(hashToSegments(hashed))\n  )\n}\n\nmodule.exports.hashKey = hashKey\n\nfunction hashKey (key) {\n  return hash(key, 'sha256')\n}\n\nmodule.exports.hashEntry = hashEntry\n\nfunction hashEntry (str) {\n  return hash(str, 'sha1')\n}\n\nfunction hash (str, digest) {\n  return crypto\n    .createHash(digest)\n    .update(str)\n    .digest('hex')\n}\n\nfunction formatEntry (cache, entry, keepAll) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity && !keepAll)\n    return null\n\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: entry.integrity ? contentPath(cache, entry.integrity) : undefined,\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata,\n  }\n}\n\nfunction readdirOrEmpty (dir) {\n  return readdir(dir).catch((err) => {\n    if (err.code === 'ENOENT' || err.code === 'ENOTDIR')\n      return []\n\n    throw err\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}